<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>注 转转  注 Three.js</title>
    <!-- 注转 住驻专转 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/FirstPersonControls.js"></script>
    <!-- 注转 住驻专转 Audio -->
    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: default;
        }
        
        #scene-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        
        #interaction-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            display: none;
            z-index: 100;
        }
        
        #interaction-button:hover {
            background-color: #45a049;
        }
        
        #controls-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        
        #next-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        
        #back-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 100;
        }
        #music-toggle {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    border-radius: 5px;
    padding: 5px 10px;
    font-size: 20px;
    cursor: pointer;
    z-index: 100;
}

#music-toggle:hover {
    background-color: rgba(0, 0, 0, 0.7);
}
/* Modal Styles */
/* Modal Styles - 转专  爪注  */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 1000;
    font-family: 'Varela Round', Arial, sans-serif;
}

.modal-content {
    position: relative;
    background-color: #f8f8f8;
    background-image: linear-gradient(to bottom, #e6f7ff, #ffffff);
    margin: 5% auto;
    width: 90%;
    max-width: 700px;
    border-radius: 25px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    animation: modalPopIn 0.7s;
    direction: rtl;
    border: 8px solid #4CAF50;
}

@keyframes modalPopIn {
    0% { transform: scale(0.5); opacity: 0; }
    50% { transform: scale(1.05); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

.modal-header {
    background: linear-gradient(to left, #4CAF50, #2E8B57);
    color: white;
    padding: 20px;
    border-radius: 17px 17px 0 0;
    display: flex;
    justify-content: center; /* 砖 -space-between -center */
    align-items: center;
    position: relative; /* 住驻 position relative */
}

.modal-header h2 {
    margin: 0;
    font-size: 32px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    font-weight: bold;
}

.close-modal {
    color: white;
    font-size: 36px;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.3s;
    position: absolute; /* 拽  */
    left: 20px; /* 拽 爪 砖 砖 转专转 */
    top: 50%; /* 专  */
    transform: translateY(-50%); /* 专  拽 */
}

.close-modal:hover {
    color: #ffcc00;
    transform: translateY(-50%) rotate(90deg);
}

.modal-body {
    padding: 30px;
    background-color: white;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="2" fill="%234CAF50" opacity="0.1"/></svg>');
}

.instruction {
    display: flex;
    align-items: center;
    margin-bottom: 25px;
    background-color: #f9f9f9;
    padding: 15px;
    border-radius: 15px;
    border-right: 8px solid #4CAF50;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    transition: all 0.3s;
}

.instruction:hover {
    background-color: #f0f8ff;
    transform: translateX(-10px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

.icon {
    font-size: 36px;
    margin-left: 20px;
    min-width: 50px;
    text-align: center;
    animation: bounce 2s infinite;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.text {
    font-size: 22px;
    font-weight: bold;
    color: #333;
}

.modal-footer {
    padding: 25px;
    text-align: center;
    background-color: #f0f0f0;
    border-radius: 0 0 17px 17px;
    background: linear-gradient(to bottom, #ffffff, #e6f7ff);
}

#start-game {
    background: linear-gradient(to bottom, #4CAF50, #3e8e41);
    color: white;
    border: none;
    padding: 15px 30px;
    font-size: 24px;
    border-radius: 50px;
    cursor: pointer;
    box-shadow: 0 6px 12px rgba(0,0,0,0.2);
    transition: all 0.3s;
    font-weight: bold;
    letter-spacing: 1px;
}


#start-game:hover {
    background: linear-gradient(to bottom, #3e8e41, #2e6b31);
    transform: scale(1.1);
    box-shadow: 0 8px 16px rgba(0,0,0,0.3);
}

/* 住专转 爪爪转 转专转 */
.modal-title-container {
    position: relative;
    display: inline-block;
}

.modal-title-container h2 {
    position: relative;
    z-index: 1;
}

.modal-title-container::before {
    content: '';
    position: absolute;
    top: -5px;
    left: -5px;
    right: -5px;
    bottom: -5px;
    border-radius: 10px;
    background: linear-gradient(45deg, 
        #ff0000, #ff7300, #fffb00, #48ff00, 
        #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
    background-size: 400%;
    z-index: 0;
    filter: blur(5px);
    opacity: 0;
    transition: opacity 0.3s;
}

.modal-header:hover .modal-title-container::before {
    opacity: 1;
    animation: glowing 20s linear infinite;
}
.adventure-button {
    background: linear-gradient(to bottom, #FF5722, #E64A19) !important;
    color: white !important;
    border: none !important;
    padding: 12px 25px !important;
    font-size: 20px !important;
    border-radius: 50px !important;
    cursor: pointer !important;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2) !important;
    transition: all 0.3s !important;
    font-weight: bold !important;
    margin-top: 10px !important;
    display: inline-block !important;
}

.adventure-button:hover {
    background: linear-gradient(to bottom, #E64A19, #D84315) !important;
    transform: scale(1.05) !important;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3) !important;
}
@keyframes glowing {
    0% { background-position: 0 0; }
    50% { background-position: 400% 0; }
    100% { background-position: 0 0; }
}


.mission-container {
    background: linear-gradient(135deg, rgba(230, 250, 240, 0.9), rgba(210, 240, 255, 0.95));
    border: 5px solid #4CAF50; /* 转 注 住专转 -3px -5px */
    border-radius: 20px; /* 转 专住 -15px -20px */
    padding: 5px; /* 转 padding */
    box-shadow: 0 0 20px rgba(76, 175, 80, 0.8), 0 0 35px rgba(0, 0, 0, 0.3); /* 爪 拽 转专 */
}


.mission-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, 
        rgba(100, 221, 23, 0.2) 0%, 
        rgba(0, 0, 0, 0) 40%, 
        rgba(0, 0, 0, 0) 60%, 
        rgba(100, 221, 23, 0.2) 100%);
    z-index: -1;
}

.mission-content {
    background: rgba(255, 255, 255, 0.85);
    border-radius: 15px; /* 转 专住 -12px */
    padding: 15px 25px; /* 转 padding -10px 20px */
}


.mission-icon {
    font-size: 40px; /* 转  拽 -28px */
    margin-left: 20px; /* 转专 专拽 拽住 */
    color: #4CAF50;
    text-shadow: 0 0 15px rgba(76, 175, 80, 0.9); /* 爪 拽 转专 */
}


.mission-text {
    text-align: right;
}

.mission-title {
    color: #64DD17;
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 5px;
    text-shadow: 0 0 8px rgba(100, 221, 23, 0.8);
}

.mission-desc {
    color: #333;
    font-size: 24px; /* 转  拽住 -16px */
    font-weight: bold;
    text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
}

@keyframes pulse-glow {
    from { text-shadow: 0 0 10px #64DD17, 0 0 20px #64DD17; }
    to { text-shadow: 0 0 15px #64DD17, 0 0 30px #64DD17, 0 0 40px #64DD17; }
}

#mission-popup {
    animation: float 3s ease-in-out infinite;
    width: auto; /* 砖 -auto -50% 专  转专 */
    max-width: 90%; /* 转 max-width -90% */
    transform: translate(-50%, 0); /* 砖专 注 专 驻拽 */
    top: 15px; /* 拽  转专 */
}

@keyframes float {
    0% { transform: translate(-50%, 0px); }
    50% { transform: translate(-50%, -10px); }
    100% { transform: translate(-50%, 0px); }
}
#video-modal .modal-content {
    max-width: 90%; /*  注专  转专  1200px */
    width: 90%; /* 住祝  砖 专  */
    background-color: #000;
    border: 8px solid #FF5722;
}

#video-modal .modal-header {
    background: linear-gradient(to left, #FF5722, #FF8A65);
}

#intro-video {
    display: block;
    border-radius: 0 0 17px 17px;
    width: 100%; /* 砖  转 专 */
    height: auto; /* 砖专 注 住 拽专 */
    max-height: 80vh; /* 拽住 80%   */
}
    </style>
</head>
<body>
<!-- Modal for video -->
<div id="video-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title-container">
                <h2>专  专驻转拽!</h2>
            </div>
        </div>
        <div class="modal-body" style="padding: 0;">
            <video id="intro-video" width="100%" controls>
                <source src="vid/1.mp4" type="video/mp4">
                驻驻 砖  转 转转 .
            </video>
        </div>
    </div>
</div>
    <div id="scene-container"></div>
    <div id="mission-popup" style="opacity: 1; position: fixed; top: 15px; left: 50%; transform: translateX(-50%); z-index: 999; width: auto; max-width: 95%;">        <div class="mission-container" style="background: linear-gradient(135deg, rgba(230, 250, 240, 0.9), rgba(210, 240, 255, 0.95)); border: 3px solid #4CAF50; border-radius: 15px; padding: -10px; box-shadow: 0 0 15px rgba(76, 175, 80, 0.6), 0 0 30px rgba(0, 0, 0, 0.3);">
            <div class="mission-content" style="background: rgba(255, 255, 255, 0.85); border-radius: 12px; padding: 10px 20px; display: flex; align-items: center; position: relative; z-index: 1;">
                <div class="mission-icon" style="font-size: 28px; margin-left: 15px; color: #4CAF50; text-shadow: 0 0 10px rgba(76, 175, 80, 0.7);"></div>
                <div class="mission-text" style="text-align: right;">
                    <div class="mission-desc" style="color: #333; font-size: 24px; font-weight: bold; text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);">注 注 住 专转 </div>                </div>
            </div>
        </div>
    </div>
    <button id="music-toggle" title="砖转拽/驻注 拽">
        
    </button>
    <div id="loading">注 转 注...</div>
    
    <div id="controls-info">
        <p>转注 拽: 拽砖 注 拽拽 砖 注专</p>
        <p>转注 专: 拽砖 注 拽拽  注专</p>
        <p>:  转 注专</p>
    </div>
    
    <div id="crosshair">+</div>
    
    <button id="interaction-button">抓  专拽爪</button>
    
    <div id="next-screen">
        <h1>注转 注!</h1>
        <p> 住 .</p>
        <button id="back-button">专 注</button>
    </div>
    <button id="music-toggle" title="砖转拽/驻注 拽">
    
</button>
<!-- Modal for navigation instructions -->
<!-- Modal for navigation instructions -->

    <script>
        // 爪专转 住爪, 爪 专专专
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 爪 专 转专
        
        // 专转 爪注 专拽注 砖 
        renderer.setClearColor(0x6495ED);
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // 砖转 
        let controls;
        let worldModel;
        let customModels = []; // 注专 砖专转  砖注 注- 砖转砖
        let treesWithColliders = [];
        let isLoaded = false;
        let clock = new THREE.Clock();
        let ground; // 砖转 砖专转 专爪驻
        
        // 砖转 
        let walkSound;
        let isWalking = false;
        
        // 拽转 专拽爪
        const interactionPoint = new THREE.Vector3(5, 0, 5);
        const interactionRadius = 2;
        let isNearInteractionPoint = false;
        
        // 拽转 注专 转 住 
        const specialPortalPoint = new THREE.Vector3(-66.88, 2.28, 4.96);
        const portalRadius = 10; // 专住  转专 专 驻专
        let portalParticles; // 砖转 砖专转 注专转 拽拽 砖 驻专
        
        // 爪专转 驻专 注 拽拽 注砖 住
        const createPortalEffect = () => {
            // 爪专转 专 拽拽
            const particleCount = 1000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            // 专转 注砖 注 住 拽转 驻专
            for (let i = 0; i < particleCount; i++) {
                // 拽 拽专 转 住驻专
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * portalRadius;
                const height = Math.random() * 8; //  拽拽
                
                // 住驻转 专转 拽 拽
                positions[i * 3] = specialPortalPoint.x + Math.cos(angle) * radius;
                positions[i * 3 + 1] = specialPortalPoint.y + height;
                positions[i * 3 + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                
                // 爪注 住 注 专爪转 拽转
                colors[i * 3] = 0.5 + Math.random() * 0.2; // 
                colors[i * 3 + 1] = 0; // 专拽
                colors[i * 3 + 2] = 0.8 + Math.random() * 0.2; // 
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // 爪专转 专 拽拽 注 住 注专 (Blending) 转 注砖
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.6,
                transparent: true,
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            // 爪专转 注专转 拽拽
            portalParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(portalParticles);
            
            // 住驻转 专 拽转 住 专 驻专
            const portalLight = new THREE.PointLight(0x9932CC, 1, 10);
            portalLight.position.copy(specialPortalPoint);
            portalLight.position.y += 1.5; // 专转 专 注
            scene.add(portalLight);
        };
        
        // 爪 驻专
        const animatePortal = () => {
            if (portalParticles) {
                const positions = portalParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // 转注 拽专转 拽
                    positions[i] += (Math.random() - 0.5) * 0.05;
                    positions[i + 1] += Math.random() * 0.05; // 转注 拽 注
                    positions[i + 2] += (Math.random() - 0.5) * 0.05;
                    
                    // 专 拽拽 砖爪 专 专 驻专
                    const dx = positions[i] - specialPortalPoint.x;
                    const dz = positions[i + 2] - specialPortalPoint.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance > portalRadius || positions[i + 1] > specialPortalPoint.y + 5) {
                        //  拽拽 爪 转, 专 转 拽 砖 转 驻专
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * portalRadius * 0.7;
                        
                        positions[i] = specialPortalPoint.x + Math.cos(angle) * radius;
                        positions[i + 1] = specialPortalPoint.y + Math.random() * 2.5;
                        positions[i + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                    }
                }
                
                portalParticles.geometry.attributes.position.needsUpdate = true;
            }
        };
        
        // 驻拽爪 拽转 拽 砖 注专 住 
        const checkCustomLocationPoints = (position) => {
    // 拽转 专拽 拽转 驻专 转
    const distanceToPortal = position.distanceTo(specialPortalPoint);
    
    if (distanceToPortal < portalRadius * 0.8) {
        // 注爪专转 转注 爪 驻 注专 祝
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
        
        // 注专 祝 tunnel.html
        window.location.href = 'tunnel.html';
        return true;
    }
    
    return false;
};
        
        // 拽注  砖拽 注 
        const PLAYER_HEIGHT = 1.7;
        
        // 转专 驻拽
        const setupLighting = () => {
            // 专 住
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // 专 砖砖 专砖
            const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.0);
            sunLight.position.set(10, 20, 15);
            sunLight.castShadow = true;
            
            // 专转 爪 转转 转专
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            sunLight.shadow.bias = -0.0003;
            
            scene.add(sunLight);
            
            // 拽转 专 砖转 转专转 
            const fillLight = new THREE.DirectionalLight(0xc2d1ff, 0.5);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
            
            // 专 拽转 注 专 住爪
            const pointLight = new THREE.PointLight(0xffedbe, 0.5, 20);
            pointLight.position.set(0, 3, 0);
            scene.add(pointLight);
            
            // 注专驻 转砖转 注拽
            scene.fog = new THREE.FogExp2(0x8eb5e0, 0.008);
        };
        
        // 拽住专转 砖 爪转转
        const createRealisticGrassTexture = () => {
            const grassTextureSize = 1024;
            const canvas = document.createElement('canvas');
            canvas.width = grassTextureSize;
            canvas.height = grassTextureSize;
            const ctx = canvas.getContext('2d');
            
            // 专拽注 专拽 住住
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#2d4c15');
            gradient.addColorStop(0.3, '#3a5a21');
            gradient.addColorStop(0.6, '#3e6b1d');
            gradient.addColorStop(1, '#345c14');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 驻拽爪 爪专转 注 砖 专住
            const drawGrassStrand = (x, y, width, height, color) => {
                ctx.beginPath();
                
                // 转转 拽 住住 注
                ctx.moveTo(x, y + height);
                
                // 爪专转 注拽 注 拽专转 注 砖
                const cp1x = x - width/2 + Math.random() * width;
                const cp1y = y + height * 0.7;
                const cp2x = x - width/3 + Math.random() * width;
                const cp2y = y + height * 0.4;
                
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                
                ctx.lineWidth = 1 + Math.random() * 1.5;
                ctx.strokeStyle = color;
                ctx.stroke();
            };
            
            // 爪专转 砖转 砖 注 砖  砖
            // 砖 1: 砖  转专 - 
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * 10; // 注 注专 住住
                const height = 15 + Math.random() * 30;
                const color = `hsl(${80 + Math.random() * 40}, ${60 + Math.random() * 30}%, ${20 + Math.random() * 10}%)`;
                
                drawGrassStrand(x, y, 2, height, color);
            }
            
            // 砖 2: 砖 专  - 专 转专
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * 15;
                const height = 10 + Math.random() * 20;
                const color = `hsl(${90 + Math.random() * 30}, ${70 + Math.random() * 20}%, ${30 + Math.random() * 15}%)`;
                
                drawGrassStrand(x, y, 1.5, height, color);
            }
            
            // 砖 3: 砖 拽爪专 - 专
            for (let i = 0; i < 10000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * 20;
                const height = 5 + Math.random() * 15;
                const color = `hsl(${100 + Math.random() * 20}, ${70 + Math.random() * 20}%, ${35 + Math.random() * 15}%)`;
                
                drawGrassStrand(x, y, 1, height, color);
            }
            
            // 住驻转 驻专 拽 驻专 拽专
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = 1 + Math.random() * 2;
                
                // 专 拽专转  爪  驻专 拽
                const flowerColors = ['#ffffff', '#ffffd0', '#ffff80', '#fbec5d'];
                ctx.fillStyle = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 爪专转 拽住专 拽住
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(8, 8); // 专 专 转专 驻专 拽 转专
            
            return texture;
        };
        
        // 爪专转 驻转 专 住住转
        const createNormalMap = () => {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            //  注 爪注 专专转  砖 专 驻 -  (0,0,1)
            ctx.fillStyle = 'rgb(128, 128, 255)';
            ctx.fillRect(0, 0, size, size);
            
            // 爪专转 专拽 拽专 专 驻
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = 1 + Math.random() * 3;
                
                // 爪专转 专爪 拽  专
                const r = 128 + Math.random() * 20 - 10;
                const g = 128 + Math.random() * 20 - 10;
                const b = 230 + Math.random() * 25;
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const normalMap = new THREE.CanvasTexture(canvas);
            normalMap.wrapS = THREE.RepeatWrapping;
            normalMap.wrapT = THREE.RepeatWrapping;
            normalMap.repeat.set(8, 8);
            
            return normalMap;
        };
        
        // 爪专转 拽专拽注 注 注转
        const createGround = () => {
            const size = 200;
            const segments = 64;
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            const vertices = geometry.attributes.position.array;
            
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.05) * Math.cos(vertices[i + 1] * 0.05) * 3;
            }
            
            geometry.computeVertexNormals();
            
            // 爪专转 专 注 拽住专 专
            const grassTexture = createRealisticGrassTexture();
            const normalMap = createNormalMap();
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                map: grassTexture,
                normalMap: normalMap,
                normalScale: new THREE.Vector2(1, 1),
                roughness: 0.8,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            
            ground = new THREE.Mesh(geometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            return ground;
        };
        
        // 驻拽爪 爪转   拽 住转
        const getGroundHeight = (x, z) => {
            return Math.sin(x * 0.05) * Math.cos(z * 0.05) * 3;
        };
        
        // 爪专转  注抓 爪转
        const createRealisticTree = (x, z, scale = 1.0, type = 'pine') => {
    const treeGroup = new THREE.Group();
    treeGroup.position.set(x, 0, z);
    treeGroup.scale.set(scale, scale, scale);
    
    if (type === 'pine') {
        // 注 注抓 专
        const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 4, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3d2817, 
            roughness: 0.9, 
            metalness: 0.0,
            side: THREE.DoubleSide
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 2; //  注
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        treeGroup.add(trunk);
        
        // 爪专转 住驻专 砖转 砖 爪专转 注抓 专
        const createPineLevel = (y, radius, height) => {
            const foliageGeometry = new THREE.ConeGeometry(radius, height, 16);
            const foliageMaterial = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color(0.0, 0.35 + Math.random() * 0.1, 0.0), 
                roughness: 0.8, 
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = y;
            foliage.castShadow = true;
            foliage.receiveShadow = true;
            return foliage;
        };
        
        // 住驻转 住驻专 砖转 爪专转 专
        treeGroup.add(createPineLevel(6, 1.5, 4));
        treeGroup.add(createPineLevel(4.5, 2, 3));
        treeGroup.add(createPineLevel(3, 2.5, 3));
    } else {
        // 注 注抓 专
        const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.3, 3, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4d3319, 
            roughness: 0.9, 
            metalness: 0.0,
            side: THREE.DoubleSide
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 1.5; //  注
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        treeGroup.add(trunk);
        
        // 爪专转 注抓 - 住驻专  住专转 
        const foliageGeometry = new THREE.SphereGeometry(1.5, 16, 16);
        // 住驻转 拽专转  爪专转
        const vertices = foliageGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            vertices[i] += (Math.random() - 0.5) * 0.6;
            vertices[i+1] += (Math.random() - 0.5) * 0.6;
            vertices[i+2] += (Math.random() - 0.5) * 0.6;
        }
        
        const foliageMaterial = new THREE.MeshStandardMaterial({ 
            color: new THREE.Color(0.1, 0.4 + Math.random() * 0.1, 0.1), 
            roughness: 0.8, 
            metalness: 0.1,
            side: THREE.DoubleSide
        });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.y = 4; //  爪专转 注 注
        foliage.castShadow = true;
        foliage.receiveShadow = true;
        treeGroup.add(foliage);
    }
    
    // 拽专 注抓
    const colliderRadius = 0.8; // 专住 拽专
    const treeCollider = new THREE.Mesh(
        new THREE.CylinderGeometry(colliderRadius, colliderRadius, 8, 8),
        new THREE.MeshBasicMaterial({ 
            visible: false 
            // 驻砖专 驻 专 注专 : visible: true, wireframe: true, opacity: 0.5, transparent: true
        })
    );
    treeCollider.position.y = 4;
    treeGroup.add(treeCollider);
    treeCollider.userData.isCollider = true;
    treeCollider.userData.radius = colliderRadius * scale; // 砖专转 专住 转
    
    // 转转  注抓  
    const groundHeight = getGroundHeight(x, z);
    treeGroup.position.y = groundHeight;
    
    // 住驻转 注抓 住爪
    scene.add(treeGroup);
    
    // 住驻转 注 拽专 注专
    treesWithColliders.push({
        position: new THREE.Vector3(x, groundHeight, z),
        radius: colliderRadius * scale
    });
    
    return treeGroup;
};

const checkTreeCollisions = (newPosition) => {
    // 专住 砖拽
    const playerRadius = 0.5;
    
    for (const tree of treesWithColliders) {
        // 拽转 专拽 驻拽  (X,Z)
        const dx = newPosition.x - tree.position.x;
        const dz = newPosition.z - tree.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        //  专拽 拽 住 专住, 砖 转砖转
        if (distance < (playerRadius + tree.radius)) {
            return true; // 砖 转砖转
        }
    }
    
    return false; //  转砖转
};
        
        // 爪专转 注专 注爪 爪转
        const createRealisticForest = () => {
            // 专转 注专
            const forestRadius = 50;  // 专住 注专
            const minDistance = 6;    // 专拽   注爪
            const numberOfTrees = 40;  // 住驻专 注爪
            const trees = [];
            
            //  爪专转 注爪 拽 拽专
            for (let i = 0; i < numberOfTrees; i++) {
                // 住 爪 拽 转
                let x, z, tooClose;
                let attempts = 0;
                
                do {
                    tooClose = false;
                    
                    // 拽 拽专 转 专住 注专
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 5 + Math.random() * (forestRadius - 5);
                    
                    x = Math.cos(angle) * distance;
                    z = Math.sin(angle) * distance;
                    
                    // 拽 砖注抓  拽专  注爪 专
                    for (const tree of trees) {
                        const dx = x - tree.position.x;
                        const dz = z - tree.position.z;
                        const distanceToTree = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distanceToTree < minDistance) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    // 转 住驻专 住转
                    attempts++;
                    if (attempts > 50) {
                        break;
                    }
                } while (tooClose);
                
                //  爪 拽 转, 爪专 注抓
                if (!tooClose) {
                    // 专 拽专转  住 注爪
                    const treeType = Math.random() < 0.6 ? 'pine' : 'normal';
                    const scale = 0.8 + Math.random() * 0.4;  //  拽专 
                    
                    const tree = createRealisticTree(x, z, scale, treeType);
                    trees.push(tree);
                }
            }
            
            return trees;
        };
        
        // 爪专转 注专转 砖 祝 专砖
        const setupFirstPersonControls = () => {
    controls = new THREE.FirstPersonControls(camera, renderer.domElement);
    controls.movementSpeed = 4;
    controls.lookSpeed = 0.03; // 专转 专砖转 -0.1 -0.05
    controls.lookVertical = true;
    controls.constrainVertical = true;
    controls.verticalMin = Math.PI / 6; // 转  注
    controls.verticalMax = Math.PI / 1.8; // 转  
    
    // 专转 专 转 拽爪转 住 砖注爪专 转 转
    const boundaryThreshold = 0.05; // 5% 拽爪 (95% 住 驻注)
    
    //  转转 注专
    document.addEventListener('mousemove', (e) => {
        const mouseX = e.clientX / window.innerWidth;
        const mouseY = e.clientY / window.innerHeight;
        
        // 拽  注专 爪 专 转 (拽专 拽爪转)
        const isNearLeftEdge = mouseX < boundaryThreshold;
        const isNearRightEdge = mouseX > (1 - boundaryThreshold);
        const isNearTopEdge = mouseY < boundaryThreshold;
        const isNearBottomEdge = mouseY > (1 - boundaryThreshold);
        
        // 注爪专转 转  注专 拽爪转
        if (isNearLeftEdge || isNearRightEdge || isNearTopEdge || isNearBottomEdge) {
            if (controls.activeLook !== false) {
                controls.activeLook = false;
            }
        } else {
            if (controls.activeLook !== true) {
                controls.activeLook = true;
            }
        }
    });
};
        
        // 注转  GLB ( 拽)
        const loadGLB = (url = '3d/world.glb', scale = 20, position = { x: 0, y: 20, z: 0 }, isCustom = false) => {
            const loader = new THREE.GLTFLoader();
            
            // 爪转 注转 注
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = '注 转 ...';
            
            loader.load(
                url,
                (gltf) => {
                    const model = gltf.scene;
                    
                    // 专转 爪  砖 
                    model.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            
                            // 驻 专     砖注 注- 砖转砖
                            if (!isCustom && node.geometry) {
                                node.geometry.scale(-1, 1, 1);
                                node.material.side = THREE.BackSide;
                            }
                        }
                    });
                    
                    // 住 拽 
                    model.scale.set(scale, scale, scale);
                    model.position.set(position.x, position.y, position.z);
                    
                    // 砖专转  砖转     拽专
                    if (!isCustom) {
                        worldModel = model;
                    } else {
                        // 住驻 注专  转 砖转
                        customModels.push(model);
                    }
                    
                    scene.add(model);
                    document.getElementById('loading').style.display = 'none';
                    isLoaded = true;
                    if (window.backgroundMusic && !window.backgroundMusic.playing()) {
    window.backgroundMusic.play();
    console.log('拽转 专拽注 驻注');
}
                },
                (xhr) => {
                    const percentComplete = (xhr.loaded / xhr.total) * 100;
                    document.getElementById('loading').textContent = 
                        `注 转 ... ${Math.round(percentComplete)}%`;
                },
                (error) => {
                    console.error('砖 注转 :', error);
                    document.getElementById('loading').style.display = 'none';
                    isLoaded = true;
                }
            );
        };
        
        // 拽  砖转砖 拽专 拽转 专拽爪
        const checkInteractionPoint = () => {
            const distance = camera.position.distanceTo(interactionPoint);
            
            if (distance < interactionRadius && !isNearInteractionPoint) {
                isNearInteractionPoint = true;
                document.getElementById('interaction-button').style.display = 'block';
            } 
            else if (distance >= interactionRadius && isNearInteractionPoint) {
                isNearInteractionPoint = false;
                document.getElementById('interaction-button').style.display = 'none';
            }
        };
        
        // 专拽爪 爪 注 驻转专
// 专拽爪 爪 注 驻转专
document.getElementById('interaction-button').addEventListener('click', () => {
    // 注爪专转 转注 爪
    if (controls) {
        controls.moveForward = false;
        controls.moveBackward = false;
    }
    movingForward = false;
    movingBackward = false;
    
    if (isWalking && walkSound) {
        walkSound.pause();
        isWalking = false;
    }
    
    document.getElementById('next-screen').style.display = 'flex';
    document.getElementById('interaction-button').style.display = 'none';
    controls.enabled = false; // 砖转转 砖 爪 住 
});
        
        // 专 注
        document.getElementById('back-button').addEventListener('click', () => {
            document.getElementById('next-screen').style.display = 'none';
            controls.enabled = true; // 驻注转 砖 砖
        });
        
        // 转转  
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (controls) {
                controls.handleResize();
            }
        });
        
        // 专转 住 
// 注 转 驻拽爪转 setupWalkSound
const setupWalkSound = () => {
    // 爪专转 拽 住  注 驻爪 驻注 专转 (loop)
    walkSound = new Howl({
        src: ['audio/walk.mp3'],
        loop: true,
        volume: 0.7
    });
};
            
            // 住驻转  专注 爪 注 驻转专 注专
            document.addEventListener('mousedown', (e) => {
                // 拽  抓 驻转专 砖 (0)   (2)
                if ((e.button === 0 || e.button === 2) && !isWalking) {
                    walkSound.play();
                    isWalking = true;
                }
            });
            
            // 住驻转  专注 砖专专 驻转专 注专
            document.addEventListener('mouseup', (e) => {
                // 拽  砖专专 驻转专 砖 (0)   (2)
                if ((e.button === 0 || e.button === 2) && isWalking) {
                    walkSound.pause();
                    isWalking = false;
                }
            });
            
            // 注转 转驻专 拽拽 
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

        // 专转 注专转 砖注转 拽转 专拽注 专转
const setupBackgroundMusic = () => {
    // 注专 砖 转 拽爪 拽
    const musicTracks = [
        'audio/park/1.mp3',
        'audio/park/2.mp3',
        'audio/park/3.mp3',
        'audio/park/4.mp3'
    ];
    
    // 专转 砖专 拽专 注专
    const randomTrackIndex = Math.floor(Math.random() * musicTracks.length);
    const selectedTrack = musicTracks[randomTrackIndex];
    
    // 爪专转 拽 住 拽转 专拽注
    const backgroundMusic = new Howl({
        src: [selectedTrack],
        loop: true,      //  专
        volume: 0.4,     // 注爪转 砖注 (0-1)
        autoplay: false  //  转 转
    });
    
    // 砖专转 拽 砖转   砖 转住  砖
    window.backgroundMusic = backgroundMusic;
    
    console.log(`专 砖专 专拽注: ${selectedTrack}`);
    
    // 住驻转 驻拽爪 驻注/砖转拽 注 拽砖 M
    document.addEventListener('keydown', (e) => {
        if (e.key === 'm' || e.key === 'M' || e.key === '') {
            if (backgroundMusic.playing()) {
                backgroundMusic.pause();
                console.log('拽 砖转拽');
            } else {
                backgroundMusic.play();
                console.log('拽 驻注');
            }
        }
    });
    // 住驻转  驻转专 砖转拽/驻注
const musicToggleBtn = document.getElementById('music-toggle');
if (musicToggleBtn) {
    musicToggleBtn.addEventListener('click', () => {
        if (backgroundMusic.playing()) {
            backgroundMusic.pause();
            musicToggleBtn.textContent = '';
            console.log('拽 砖转拽');
        } else {
            backgroundMusic.play();
            musicToggleBtn.textContent = '';
            console.log('拽 驻注');
        }
    });
}
    // 专转 拽 拽专 砖专爪 砖转砖 
    return backgroundMusic;
};
        // 转 住爪
// Modal functionality
// Modal functionality with improved effects for kids

// 住驻转 驻拽 驻注 转 砖
// 住驻转 驻拽 驻注 转 砖
// 住驻转 驻拽 驻注 转 砖
const setupMissionPopup = () => {
    const missionPopup = document.getElementById('mission-popup');
    console.log("Setting up mission popup:", missionPopup);
    
    //  转 转 转
    if (missionPopup) {
        // 专转 砖转 转  转
        missionPopup.style.opacity = '0';
        
        // 爪 转 转 专  专 转专 ( 驻砖专 住专 专 住转)
        setTimeout(() => {
            console.log("Showing mission popup");
            missionPopup.style.opacity = '1';
            missionPopup.style.transition = 'opacity 1.5s ease-out';
        }, 8000); //  转  -15 砖转
    } else {
        console.error("Mission popup element not found!");
    }
};
// 驻拽爪 爪转  住专
const setupVideoModal = () => {
    const videoModal = document.getElementById('video-modal');
    const introVideo = document.getElementById('intro-video');
    
    // 爪转  专 3 砖转
    setTimeout(() => {
        videoModal.style.display = 'block';
        
        // 砖转 砖  爪转 住专
        if (controls) {
            controls.enabled = false;
        }
        
        // 砖转 拽转 专拽注  驻注转
        if (window.backgroundMusic && window.backgroundMusic.playing()) {
            window.backgroundMusic.pause();
        }
        
        // 驻注转 住专 转
        introVideo.play();
        
        // 住驻转  住 住专
        introVideo.addEventListener('ended', () => {
    // 住专转  住专
    videoModal.style.display = 'none';
    
    // 驻注转 拽专转 专 住专
    if (controls) {
        controls.enabled = true;
    }
    
    // 驻注转 拽转 专拽注  转 砖转拽转
    if (window.backgroundMusic && !window.backgroundMusic.playing()) {
        window.backgroundMusic.play();
    }
});
    }, 3000); // 3 砖转
};
// Add this line to your init function
const init = () => {
    setupLighting();
    createGround();
    createRealisticForest();
    const backgroundMusic = setupBackgroundMusic();
    setupFirstPersonControls();
    setupWalkSound();
    setupMovementControls(); // 住祝 拽专 驻拽爪 砖
    createPortalEffect();
    loadGLB();
    loadTechnodaModels();
    
    // 驻注转  住专 转
    setupVideoModal();
    
    // 砖 :  专 驻注 转 专 住 住专
    //  爪专 拽专  -setupNavigationModal
    
    // 专转 转 砖 - 砖专 转  注 转 
    setupMissionPopup();
    
    // 拽 拽...
    animate();
};
// 住祝 住祝 驻拽爪转 init
// 拽 专注 注专 拽 注 砖
window.addEventListener('load', () => {
    isWalking = false;
    if (walkSound && walkSound.playing()) {
        walkSound.pause();
    }
});
        
        // 驻拽爪 注转  注 住驻专 拽转
        const loadTechnodaModels = () => {
            const technodaPath = '3d/technoda.glb';
            const numberOfModels = 5;
            
            // 注专 拽 专 注 专拽   
            const positions = [];
            const minDistance = 10; // 专拽   
            
            // 爪专转 拽 专
            for (let i = 0; i < numberOfModels; i++) {
                let posX, posZ, tooClose;
                let attempts = 0;
                
                do {
                    tooClose = false;
                    
                    // 拽 专 转 专住  专
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 15 + Math.random() * 30; // 专拽 砖 15-45 转
                    
                    posX = Math.cos(angle) * distance;
                    posZ = Math.sin(angle) * distance;
                    
                    // 拽 砖  拽专   专
                    for (const pos of positions) {
                        const dx = posX - pos.x;
                        const dz = posZ - pos.z;
                        const distanceBetweenModels = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distanceBetweenModels < minDistance) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    // 转 住驻专 住转
                    attempts++;
                    if (attempts > 50) {
                        break;
                    }
                } while (tooClose);
                
                //  爪 拽 转
                if (!tooClose) {
                    // 砖   拽 
                    const groundHeight = getGroundHeight(posX, posZ);
                    
                    // 砖专转 拽
                    positions.push({ x: posX, y: groundHeight + 1.3, z: posZ });
                }
            }
            
            // 注转  拽 砖爪专
            positions.forEach((position, index) => {
                // 住拽 拽专转 拽
                const scale = 1.2 + Math.random() * 0.6; //  1.2 -1.8
                
                // 注转  注 驻专专 砖
                setTimeout(() => {
                    loadGLB(technodaPath, scale, position, true);
                }, index * 500); // 注 拽  注转 拽 注 驻驻
            });
        };
        
        // 驻拽爪转 爪
        const animate = () => {
    requestAnimationFrame(animate);
    
    if (isLoaded) {
        const delta = clock.getDelta();
        
        if (controls) {
            // 砖专转 拽 拽 驻 注
            const previousPosition = camera.position.clone();
            
            // 注 砖
            controls.update(delta);
            
            // 拽转 转砖转 拽 砖
            if (checkTreeCollisions(camera.position)) {
                //  砖 转砖转, 专 拽 拽
                camera.position.copy(previousPosition);
            }
            
            // 注  爪 转  拽专拽注
            const groundHeight = getGroundHeight(camera.position.x, camera.position.z);
            camera.position.y = groundHeight + PLAYER_HEIGHT;
            
            // 驻住转 拽  砖 砖拽 拽住  2 砖转
            const currentTime = Date.now();
            if (!window.lastPositionLog || currentTime - window.lastPositionLog > 2000) {
                console.log(`拽 砖拽: X: ${camera.position.x.toFixed(2)}, Y: ${camera.position.y.toFixed(2)}, Z: ${camera.position.z.toFixed(2)}`);
                window.lastPositionLog = currentTime;
            }
            
            // 拽转 拽专 拽转 专拽爪 拽专转
            checkInteractionPoint();
            
            // 拽转  注 拽转 专拽爪 转转 砖转
            if (checkCustomLocationPoints(camera.position)) {
                // 专 驻注 转 住  转 驻拽爪
            }
        }
        
        // 爪 驻专 注 注砖 住
        animatePortal();
    }
    
    renderer.render(scene, camera);
};
        
        // 驻注转 转 砖祝 注
        window.addEventListener('load', init);
        
// 住祝 转 拽  住祝 转  转 驻拽爪转 setupWalkSound

// 注爪专转 爪  砖专 注 转 注
window.addEventListener('beforeunload', () => {
    if (isWalking && walkSound) {
        walkSound.pause();
        isWalking = false;
    }
});

// 注爪专转 爪  砖专 注 住转专
document.addEventListener('visibilitychange', () => {
    if (document.hidden && isWalking && walkSound) {
        walkSound.pause();
        isWalking = false;
    }
});
// 住祝 砖转  注拽 专 爪 转注
let movingForward = false;
let movingBackward = false;

// 砖转 转  专注 注专
const setupMovementControls = () => {
    // 住驻转  专注 爪 注 驻转专 注专
    document.addEventListener('mousedown', (e) => {
        // 拽  抓 驻转专 砖 (0)
        if (e.button === 0) {
            movingForward = true;
            if (controls) controls.moveForward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
        // 拽  抓 驻转专  (2)
        else if (e.button === 2) {
            movingBackward = true;
            if (controls) controls.moveBackward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
    });
    
    // 住驻转  专注 砖专专 驻转专 注专
    document.addEventListener('mouseup', (e) => {
        // 拽  砖专专 驻转专 砖 (0)
        if (e.button === 0) {
            movingForward = false;
            if (controls) controls.moveForward = false;
            
            // 注爪专 爪 专拽   拽  专  驻注
            if (isWalking && !movingBackward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
        // 拽  砖专专 驻转专  (2)
        else if (e.button === 2) {
            movingBackward = false;
            if (controls) controls.moveBackward = false;
            
            // 注爪专 爪 专拽   拽  专  驻注
            if (isWalking && !movingForward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // 注爪专转 转注 转 砖注 转 注  注专 砖转 专转
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            //  注 住转专, 注爪专 转  转注
            if (controls) {
                controls.moveForward = false;
                controls.moveBackward = false;
            }
            movingForward = false;
            movingBackward = false;
            
            if (isWalking && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // 注爪专转 转注 砖注 转 注
    window.addEventListener('beforeunload', () => {
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
    });
    
    // 注转 转驻专 拽拽 
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
};
    </script>