<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>注 转转  注 Three.js</title>
    <!-- 注转 住驻专转 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/FirstPersonControls.js"></script>
    <!-- 注转 住驻专转 Audio -->
    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/geometries/TextGeometry.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: default;
        }
        
        #scene-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        
        #controls-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        
        #next-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        
        #back-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 100;
        }
        .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 1000;
    font-family: 'Varela Round', Arial, sans-serif;
}

.modal-content {
    position: relative;
    background-color: #000;
    margin: 5% auto;
    width: 90%;
    max-width: 800px;
    border-radius: 25px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    animation: modalPopIn 0.7s;
    direction: rtl;
    border: 8px solid #9932CC;
}

@keyframes modalPopIn {
    0% { transform: scale(0.5); opacity: 0; }
    50% { transform: scale(1.05); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

.modal-header {
    background: linear-gradient(to left, #9932CC, #8A2BE2);
    color: white;
    padding: 20px;
    border-radius: 17px 17px 0 0;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
}

.modal-header h2 {
    margin: 0;
    font-size: 32px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    font-weight: bold;
}

.modal-body {
    padding: 0;
    background-color: black;
    border-radius: 0 0 17px 17px;
}

#intro-video {
    display: block;
    border-radius: 0 0 17px 17px;
}

.modal-title-container {
    position: relative;
    display: inline-block;
}

.modal-title-container h2 {
    position: relative;
    z-index: 1;
}
#mission-popup {
    animation: float 3s ease-in-out infinite;
    width: auto;
    max-width: 95%; /* 转 max-width -90% */
    transform: translate(-50%, 0);
    top: 15px; /* 拽  转专 */
}

@keyframes float {
    0% { transform: translate(-50%, 0px); }
    50% { transform: translate(-50%, -10px); }
    100% { transform: translate(-50%, 0px); }
}

.mission-container {
    background: linear-gradient(135deg, rgba(230, 250, 240, 0.9), rgba(210, 240, 255, 0.95));
    border: 5px solid #9932CC; /* 转 注 住专转 -3px -5px */
    border-radius: 20px; /* 转 专住 -15px -20px */
    padding: 5px; /* 转 padding */
    box-shadow: 0 0 20px rgba(153, 50, 204, 0.8), 0 0 35px rgba(0, 0, 0, 0.3); /* 爪 拽 转专 */
}

.mission-content {
    background: rgba(255, 255, 255, 0.85);
    border-radius: 15px; /* 转 专住 -12px */
    padding: 15px 25px; /* 转 padding -10px 20px */
}

.mission-icon {
    font-size: 40px; /* 转  拽 -28px */
    margin-left: 20px; /* 转专 专拽 拽住 */
    color: #9932CC;
    text-shadow: 0 0 15px rgba(153, 50, 204, 0.9); /* 爪 拽 转专 */
}

.mission-text {
    text-align: right;
}

.mission-desc {
    color: #333;
    font-size: 24px; /* 转  拽住 -16px */
    font-weight: bold;
    text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
}
    </style>
</head>
<body>
    <!-- Modal for video -->
    <div id="mission-popup" style="opacity: 1; position: fixed; top: 15px; left: 50%; transform: translateX(-50%); z-index: 999; width: auto; max-width: 95%;">
        <div class="mission-container" style="background: linear-gradient(135deg, rgba(230, 250, 240, 0.9), rgba(210, 240, 255, 0.95)); border: 5px solid #9932CC; border-radius: 20px; padding: 5px; box-shadow: 0 0 20px rgba(153, 50, 204, 0.8), 0 0 35px rgba(0, 0, 0, 0.3);">
            <div class="mission-content" style="background: rgba(255, 255, 255, 0.85); border-radius: 15px; padding: 15px 25px; display: flex; align-items: center; position: relative; z-index: 1;">
                <div class="mission-icon" style="font-size: 40px; margin-left: 20px; color: #9932CC; text-shadow: 0 0 15px rgba(153, 50, 204, 0.9);"></div>
                <div class="mission-text" style="text-align: right;">
                    <div class="mission-desc" style="color: #333; font-size: 24px; font-weight: bold; text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);">注 拽爪 专转 </div>
                </div>
            </div>
        </div>
    </div>
<div id="video-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title-container">
                <h2>专  专转 !</h2>
            </div>
        </div>
        <div class="modal-body" style="padding: 0;">
            <video id="intro-video" width="100%" controls>
                <source src="vid/2.mp4" type="video/mp4">
                驻驻 砖  转 转转 .
            </video>
        </div>
    </div>
</div>
    <div id="scene-container"></div>
    
    <div id="loading">注 转 注...</div>
    
    <div id="controls-info">
        <p>转注 拽: 拽砖 注 拽拽 砖 注专</p>
        <p>转注 专: 拽砖 注 拽拽  注专</p>
        <p>:  转 注专</p>
    </div>
    
    <div id="crosshair">+</div>
    
    <div id="next-screen">
        <h1>注转 注!</h1>
        <p> 住 .</p>
        <button id="back-button">专 注</button>
    </div>
    
    <script>
        // 爪专转 住爪, 爪 专专专
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-31.42, 10.20, 32.99);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 爪 专 转专
        
        // 专转 爪注 专拽注 砖 
        renderer.setClearColor(0x6495ED);
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // 砖转 
// 砖转 
let controls;
let worldModel;
let isLoaded = false;
let clock = new THREE.Clock();
let ground; // 砖转 砖专转 专爪驻
let tunnelObject; // 砖转 砖专转 专
let tunnelWalls = []; // 注专 砖专转 拽专 砖 拽专转 专
let tunnelTexture; // 砖转 砖专转 拽住专 住转转
let tunnelMaterial; // 砖转 砖专转 专 砖 专
        // 砖转 
        let walkSound;
        let isWalking = false;
        
        // 拽转 注专 转 住 
        const specialPortalPoint = new THREE.Vector3(29.11, 10.20, -34.25); // 拽 砖 驻专 住
        const portalRadius = 6; // 专住  转专 专 驻专
        let portalParticles; // 砖转 砖专转 注专转 拽拽 砖 驻专
        // 住祝 砖转  注拽 专 爪 转注
let movingForward = false;
let movingBackward = false;

// 驻拽爪 砖 转注
const setupMovementControls = () => {
    // 住驻转  专注 爪 注 驻转专 注专
    document.addEventListener('mousedown', (e) => {
        // 拽  抓 驻转专 砖 (0)
        if (e.button === 0) {
            movingForward = true;
            if (controls) controls.moveForward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
        // 拽  抓 驻转专  (2)
        else if (e.button === 2) {
            movingBackward = true;
            if (controls) controls.moveBackward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
    });
    
    // 住驻转  专注 砖专专 驻转专 注专
    document.addEventListener('mouseup', (e) => {
        // 拽  砖专专 驻转专 砖 (0)
        if (e.button === 0) {
            movingForward = false;
            if (controls) controls.moveForward = false;
            
            // 注爪专 爪 专拽   拽  专  驻注
            if (isWalking && !movingBackward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
        // 拽  砖专专 驻转专  (2)
        else if (e.button === 2) {
            movingBackward = false;
            if (controls) controls.moveBackward = false;
            
            // 注爪专 爪 专拽   拽  专  驻注
            if (isWalking && !movingForward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // 注爪专转 转注 转 砖注 转 注  注专 砖转 专转
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            //  注 住转专, 注爪专 转  转注
            if (controls) {
                controls.moveForward = false;
                controls.moveBackward = false;
            }
            movingForward = false;
            movingBackward = false;
            
            if (isWalking && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // 注爪专转 转注 砖注 转 注
    window.addEventListener('beforeunload', () => {
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
    });
    
    // 注转 转驻专 拽拽 
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
};
        // 爪专转 驻专 注 拽拽 注砖 住
        const createPortalEffect = () => {
            // 爪专转 专 拽拽
            const particleCount = 500;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            // 专转 注砖 注 住 拽转 驻专
            for (let i = 0; i < particleCount; i++) {
                // 拽 拽专 转 住驻专
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * portalRadius;
                const height = Math.random() * 5; //  拽拽
                
                // 住驻转 专转 拽 拽
                positions[i * 3] = specialPortalPoint.x + Math.cos(angle) * radius;
                positions[i * 3 + 1] = specialPortalPoint.y + height;
                positions[i * 3 + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                
                // 爪注 住 注 专爪转 拽转
                colors[i * 3] = 0.5 + Math.random() * 0.2; // 
                colors[i * 3 + 1] = 0; // 专拽
                colors[i * 3 + 2] = 0.8 + Math.random() * 0.2; // 
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // 爪专转 专 拽拽 注 住 注专 (Blending) 转 注砖
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.4,
                transparent: true,
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            // 爪专转 注专转 拽拽
            portalParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(portalParticles);
            
            // 住驻转 专 拽转 住 专 驻专
            const portalLight = new THREE.PointLight(0x9932CC, 1, 10);
            portalLight.position.copy(specialPortalPoint);
            portalLight.position.y += 1.5; // 专转 专 注
            scene.add(portalLight);
        };
        const setupTunnelBackgroundMusic = () => {
    // 注专 砖 转 拽爪 拽
    const musicTracks = [
        'audio/tunnel/1.mp3',
        'audio/tunnel/2.mp3',
        'audio/tunnel/3.mp3',
        'audio/tunnel/4.mp3'
    ];
    
    // 专转 砖专 拽专 注专
    const randomTrackIndex = Math.floor(Math.random() * musicTracks.length);
    const selectedTrack = musicTracks[randomTrackIndex];
    
    // 爪专转 拽 住 拽转 专拽注
    const backgroundMusic = new Howl({
        src: [selectedTrack],
        loop: true,      //  专
        volume: 0.5,     // 注爪转 砖注 (0-1)
        autoplay: false  //  转 转
    });
    
    // 砖专转 拽 砖转   砖 转住  砖
    window.tunnelBackgroundMusic = backgroundMusic;
    
    console.log(`专 砖专 专拽注 专: ${selectedTrack}`);
    
    // 住驻转 驻转专 砖转拽转/驻注转 拽
    createMusicToggleButton();
    
    // 专转 拽 拽专 砖专爪 砖转砖 
    return backgroundMusic;
};

// 爪专转 驻转专 砖转拽转 拽
const createMusicToggleButton = () => {
    // 拽  驻转专 专 拽
    if (document.getElementById('music-toggle')) {
        return;
    }
    
    // 爪专转 驻转专 砖转拽转 拽
    const musicToggleBtn = document.createElement('button');
    musicToggleBtn.id = 'music-toggle';
    musicToggleBtn.title = '砖转拽/驻注 拽';
    musicToggleBtn.textContent = '';
    musicToggleBtn.style.position = 'absolute';
    musicToggleBtn.style.top = '10px';
    musicToggleBtn.style.left = '10px';
    musicToggleBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    musicToggleBtn.style.color = 'white';
    musicToggleBtn.style.border = 'none';
    musicToggleBtn.style.borderRadius = '5px';
    musicToggleBtn.style.padding = '5px 10px';
    musicToggleBtn.style.fontSize = '20px';
    musicToggleBtn.style.cursor = 'pointer';
    musicToggleBtn.style.zIndex = '100';
    
    document.body.appendChild(musicToggleBtn);
    
    // 住驻转  专注 驻转专
    musicToggleBtn.addEventListener('click', () => {
        console.log('驻转专 砖转拽 抓');
        
        if (window.tunnelBackgroundMusic) {
            if (window.tunnelBackgroundMusic.playing()) {
                window.tunnelBackgroundMusic.pause();
                musicToggleBtn.textContent = '';
                console.log('拽 砖转拽');
            } else {
                window.tunnelBackgroundMusic.play();
                musicToggleBtn.textContent = '';
                console.log('拽 驻注');
            }
        } else {
            console.error('拽 拽  爪!');
        }
    });
    
    // 住驻转  专注 拽砖 M 砖转拽转/驻注转 拽
    document.addEventListener('keydown', (e) => {
        if (e.key === 'm' || e.key === 'M' || e.key === '') {
            if (window.tunnelBackgroundMusic) {
                if (window.tunnelBackgroundMusic.playing()) {
                    window.tunnelBackgroundMusic.pause();
                    musicToggleBtn.textContent = '';
                    console.log('拽 砖转拽');
                } else {
                    window.tunnelBackgroundMusic.play();
                    musicToggleBtn.textContent = '';
                    console.log('拽 驻注');
                }
            }
        }
    });
};
        // 爪 驻专
        const animatePortal = () => {
            if (portalParticles) {
                const positions = portalParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // 转注 拽专转 拽
                    positions[i] += (Math.random() - 0.5) * 0.05;
                    positions[i + 1] += Math.random() * 0.05; // 转注 拽 注
                    positions[i + 2] += (Math.random() - 0.5) * 0.05;
                    
                    // 专 拽拽 砖爪 专 专 驻专
                    const dx = positions[i] - specialPortalPoint.x;
                    const dz = positions[i + 2] - specialPortalPoint.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance > portalRadius || positions[i + 1] > specialPortalPoint.y + 5) {
                        //  拽拽 爪 转, 专 转 拽 砖 转 驻专
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * portalRadius * 0.7;
                        
                        positions[i] = specialPortalPoint.x + Math.cos(angle) * radius;
                        positions[i + 1] = specialPortalPoint.y + Math.random() * 2.5;
                        positions[i + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                    }
                }
                
                portalParticles.geometry.attributes.position.needsUpdate = true;
            }
        };
        
        // 驻拽爪 拽转 拽 砖 注专 住 
// 驻拽爪 拽转 拽 砖 注专 住 
const checkCustomLocationPoints = (position) => {
    // 拽转 专拽 拽转 驻专 转
    const distanceToPortal = position.distanceTo(specialPortalPoint);
    
    if (distanceToPortal < portalRadius / 2) {
        // 注爪专转 转注 爪 驻 注专 祝
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        // 注爪专转 拽 驻 注专 祝 专
        if (window.tunnelBackgroundMusic && window.tunnelBackgroundMusic.playing()) {
            window.tunnelBackgroundMusic.stop();
        }
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
        
        // 注专 祝 enter.html
        window.location.href = 'enter.html';
        return true;
    }
    
    return false;
};
        
        // 拽注  砖拽 注 
        const PLAYER_HEIGHT = 10.2;
        
        // 转专 驻拽
        const setupLighting = () => {
            // 专 住
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // 专 砖砖 专砖
            const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.0);
            sunLight.position.set(10, 20, 15);
            sunLight.castShadow = true;
            
            // 专转 爪 转转 转专
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            sunLight.shadow.bias = -0.0003;
            
            scene.add(sunLight);
            
            // 拽转 专 砖转 转专转 
            const fillLight = new THREE.DirectionalLight(0xc2d1ff, 0.5);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
            
            // 专 拽转 注 专 住爪
            const pointLight = new THREE.PointLight(0xffedbe, 0.5, 20);
            pointLight.position.set(0, 12, 0);
            scene.add(pointLight);
            
            // 注专驻 转砖转 注拽
            scene.fog = new THREE.FogExp2(0x8eb5e0, 0.006); // 拽转 注专 爪驻驻转   转专
        };
        
        // 爪专转 拽住专转 专爪驻 住 砖
// 爪专转 拽住专转 专爪驻 住 砖  住
const createRoadTexture = () => {
    const textureSize = 1024;
    const canvas = document.createElement('canvas');
    canvas.width = textureSize;
    canvas.height = textureSize;
    const ctx = canvas.getContext('2d');
    
    // 爪注 专拽注 住驻 - 驻专 
    ctx.fillStyle = '#333333';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 住驻转 专拽 住驻
    for (let i = 0; i < 10000; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 3;
        
        //  砖 驻专 专拽 住驻
        const shade = 50 + Math.random() * 30;
        ctx.fillStyle = `rgba(${shade}, ${shade}, ${shade}, 0.4)`;
        ctx.fillRect(x, y, size, size);
    }
    
    // 住驻转 驻 专转 砖
    for (let i = 0; i < 30; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = 5 + Math.random() * 20;
        
        // 专 砖 - 注 
        const shade = 20 + Math.random() * 30;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        gradient.addColorStop(0, `rgba(${shade}, ${shade}, ${shade}, 0.8)`);
        gradient.addColorStop(1, 'rgba(51, 51, 51, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
        
        // 住驻转 住拽 砖
        if (Math.random() > 0.5) {
            ctx.strokeStyle = `rgba(20, 20, 20, 0.5)`;
            ctx.lineWidth = 1;
            
            const crackPoints = 3 + Math.floor(Math.random() * 4);
            ctx.beginPath();
            ctx.moveTo(x, y);
            
            for (let j = 0; j < crackPoints; j++) {
                const angle = Math.random() * Math.PI * 2;
                const length = 5 + Math.random() * 15;
                ctx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
            }
            
            ctx.stroke();
        }
    }
    
    // 爪专转 拽住专 拽住
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(4, 4);
    
    return texture;
};
        
        // 爪专转 拽专拽注 砖 住 砖
// 爪专转 拽专拽注 砖 住 砖
const createFlatRoadGround = () => {
    const size = 100;
    const geometry = new THREE.PlaneGeometry(size, size);
    
    // 爪专转 专 注 拽住专转 砖
    const roadTexture = createRoadTexture();
    
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        map: roadTexture,
        roughness: 0.9,
        metalness: 0.1,
        side: THREE.DoubleSide
    });
    
    ground = new THREE.Mesh(geometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    // 转  -8.5
    ground.position.y = 8.5;
    ground.receiveShadow = true;
    scene.add(ground);
    
    return ground;
};
        
        // 爪专转 拽专 拽专转 专
        const createTunnelColliders = (startPoint, endPoint, tunnelRadius) => {
    // 拽 注专 拽专 拽
    tunnelWalls = [];
    
    // 砖  专 砖 专
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    const tunnelLength = direction.length();
    
    // 专 
    const normalizedDirection = direction.clone().normalize();
    
    // 爪专转 拽专 爪  专
    const perpendicular = new THREE.Vector3();
    if (Math.abs(normalizedDirection.y) < 0.99) {
        perpendicular.set(0, 1, 0);
    } else {
        perpendicular.set(1, 0, 0);
    }
    perpendicular.cross(normalizedDirection).normalize();
    
    // 住驻专 拽专 住 拽祝 专
    const numColliders = 8;
    
    // 爪专转 拽专 住 拽祝 专
    for (let i = 0; i < numColliders; i++) {
        const angle = (i / numColliders) * Math.PI * 2;
        
        // 拽专  拽专 
        const ringVector = perpendicular.clone().applyAxisAngle(normalizedDirection, angle);
        
        // 拽转 专 拽专
        const colliderPoints = [];
        
        // 住驻专 拽转 专 专
        const numPoints = 4;
        
        // 爪专转 拽转 专 专
        for (let j = 0; j <= numPoints; j++) {
            const t = j / numPoints;
            
            // 拽 注 拽 专
            const pointOnLine = new THREE.Vector3().lerpVectors(startPoint, endPoint, t);
            
            // 拽 注 拽专 专
            const pointOnWall = pointOnLine.clone().add(
                ringVector.clone().multiplyScalar(tunnelRadius * 0.9) // 注 驻 专住 转
            );
            
            colliderPoints.push(pointOnWall);
        }
        
        // 砖专转 注 拽专
        tunnelWalls.push({
    points: colliderPoints,
    radius: 0.5 //  拽专 专 转专 专 
});
    }
};
        
        // 拽转 转砖转 注 拽专转 专
        const checkTunnelCollisions = (position) => {
            // 专住 砖拽
            const playerRadius = 0.5;
            
            for (const wall of tunnelWalls) {
                // 拽转  拽注 砖 拽专
                for (let i = 0; i < wall.points.length - 1; i++) {
                    const start = wall.points[i];
                    const end = wall.points[i + 1];
                    
                    // 砖 专拽 拽爪专 转专 砖拽 拽注
                    const closestPoint = new THREE.Vector3();
                    const line = new THREE.Line3(start, end);
                    line.closestPointToPoint(position, true, closestPoint);
                    
                    const distance = position.distanceTo(closestPoint);
                    
                    //  专拽 拽 住 专住 - 砖 转砖转
                    if (distance < playerRadius + wall.radius) {
                        return true;
                    }
                }
            }
            
            return false;
        };
        
        // 爪专转 爪专/专 砖砖拽  住 
        const createTunnel = () => {
    // 拽转 转 住 专 (拽转 砖转)
    const startPoint = new THREE.Vector3(-24.63, 12.0, 26.94); // 转转 专 砖 注  13
    const endPoint = new THREE.Vector3(33.19, 12.0, -38.43); // 住祝 专 砖 注  13
    
    // 砖  专 砖 专
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    const tunnelLength = direction.length();
    
    // 专住 爪专 -  -8 专
    const tunnelRadius = 10; // 专住 砖
    // 住驻专 拽注 专 拽祝 爪专
    const radialSegments = 16;
    const heightSegments = 30;
// 爪 砖 专转 专 转砖转 住 住驻转
if (window.tunnelLights && window.tunnelLights.length > 0) {
    const time = performance.now() * 0.001; //  砖转
    
    for (let i = 0; i < window.tunnelLights.length; i++) {
        const light = window.tunnelLights[i];
        const bulb = window.tunnelBulbs[i];
        const glow = window.tunnelGlows[i];
        
        if (light && light.userData) {
            // 爪 注转 砖 专
            const angle = time * 0.5 + light.userData.phase;
            const x = Math.cos(angle) * light.userData.amplitude;
            const z = Math.sin(angle) * light.userData.amplitude;
            
            // 转 住 拽 住住
            const newPosition = light.userData.basePosition.clone();
            newPosition.x += x;
            newPosition.z += z;
            
            // 注 拽 砖 专  
            light.position.copy(newPosition);
            
            if (bulb) bulb.position.copy(newPosition);
            if (glow) glow.position.copy(newPosition);
            
            // 砖 注爪转 专 驻 专
            light.intensity = 0.4 + 0.3 * Math.sin(time * 2 + light.userData.phase);
            
            // 砖  专 驻 专
            if (glow) {
                glow.scale.set(
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase),
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase),
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase)
                );
            }
        }
    }
}
    
    // 爪专转 专转 爪专 驻转 砖 拽爪转
    const geometry = new THREE.CylinderGeometry(
        tunnelRadius, // 专住 注
        tunnelRadius, // 专住 转转
        tunnelLength, // 专
        radialSegments, // 住驻专 拽注 拽祝
        heightSegments, // 住驻专 拽注 专
        true // 驻转 砖 拽爪转
    );
    
    
    // 爪专转 拽住专 专 住 专专 住
// 爪专转 拽住专 专 住 专专 住
const createRetroTunnelTexture = () => {
    const textureSize = 1024;
    const canvas = document.createElement('canvas');
    canvas.width = textureSize;
    canvas.height = textureSize;
    const ctx = canvas.getContext('2d');
    
    // 爪注 专拽注 住 
    ctx.fillStyle = '#2a1a3a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 爪专转 拽 专砖转  住 专专
    const gridSpacing = 64; // 专  转专  拽 专砖转
    const gridColor = '#9c3fd4'; // 住  转专
    
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 3;
    
    // 爪专 拽 驻拽
    for (let y = 0; y < canvas.height; y += gridSpacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
        
        // 住驻转 驻拽 专 拽
        ctx.strokeStyle = 'rgba(200, 120, 255, 0.5)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
        
        // 专 住 拽专
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 3;
    }
    
    // 爪专 拽  -  砖 转专  砖 转专 驻拽 住
    for (let x = 0; x < canvas.width; x += gridSpacing) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        
        // 住驻转 驻拽 专 拽
        ctx.strokeStyle = 'rgba(200, 120, 255, 0.5)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        
        // 专 住 拽专
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 3;
    }
    
    // 住驻转  住 砖驻专 驻拽 住
    for (let i = 0; i < 20; i++) {
        const x1 = Math.random() * canvas.width;
        const y1 = 0;
        const x2 = Math.random() * canvas.width;
        const y2 = canvas.height;
        
        ctx.strokeStyle = `rgba(255, 100, 255, 0.3)`;
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    
    // 住驻转 拽转 专转 住 
    for (let i = 0; i < 300; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 3 + 1;
        
        // 爪注 专  砖 住/专
        const r = 200 + Math.random() * 55;
        const g = 50 + Math.random() * 100;
        const b = 200 + Math.random() * 55;
        
        // 爪专转 专 专 住 拽
        const glow = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
        glow.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
        glow.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.3)`);
        glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(x, y, size * 3, 0, Math.PI * 2);
        ctx.fill();
        
        // 拽 专转 专 转专
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // 住驻转  专 专专 (砖砖/专注)  砖
    for (let i = 0; i < 50; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 30 + 10;
        
        // 爪注   住/专
        const r = 130 + Math.random() * 50;
        const g = 20 + Math.random() * 40;
        const b = 180 + Math.random() * 70;
        const a = 0.2 + Math.random() * 0.3;
        
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
        
        // 专 拽专转  砖砖 专注
        if (Math.random() > 0.5) {
            // 砖砖
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2);
            ctx.lineTo(x - size / 2, y + size / 2);
            ctx.lineTo(x + size / 2, y + size / 2);
            ctx.closePath();
            ctx.fill();
            
            // 拽 转 专
            ctx.strokeStyle = `rgba(255, 200, 255, 0.7)`;
            ctx.lineWidth = 2;
            ctx.stroke();
        } else {
            // 专注 住 ()
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2);
            ctx.lineTo(x + size / 2, y);
            ctx.lineTo(x, y + size / 2);
            ctx.lineTo(x - size / 2, y);
            ctx.closePath();
            ctx.fill();
            
            // 拽 转 专
            ctx.strokeStyle = `rgba(255, 200, 255, 0.7)`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
    
    // 爪专转 拽住专 拽住
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(5, 10); // 转 专 驻拽 住  转专
    
    return texture;
};
    
    // 爪专转 专拽 专 专专
    const tunnelTexture = createRetroTunnelTexture();
    
    // 爪专转 专 爪专
    const material = new THREE.MeshStandardMaterial({
        map: tunnelTexture,
        roughness: 0.7,
        metalness: 0.3,
        side: THREE.DoubleSide, 
        emissive: new THREE.Color(0x4d0099), // 驻拽 驻  住
        emissiveIntensity: 0.2, // 注爪转 驻
        transparent: false
    });
    
    // 爪专转 专
    const tunnel = new THREE.Mesh(geometry, material);
    
    // 砖 专转 住 砖 专
    // 爪专 爪专 专 爪专 -Y,   爪专 住 转
    //  砖  
    
    // 砖 专 砖 
    direction.normalize();
    
    // 专转 拽专 住 - 专  爪专 -Y
    const yAxis = new THREE.Vector3(0, 1, 0);
    
    // 砖 拽专 住转转 爪专 -Y  砖
    const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction);
    tunnel.setRotationFromQuaternion(quaternion);
    
    // 拽 专 - 爪注  拽转 转 住
    const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
    tunnel.position.copy(midPoint);
    
    // 住驻转 爪
    tunnel.castShadow = true;
    tunnel.receiveShadow = true;
    
    // 住驻转 专 住爪
    scene.add(tunnel);
    
    // 砖专转 专 砖转 
    tunnelObject = tunnel;
    
    // 爪专转 拽专 拽专转 专
    createTunnelColliders(startPoint, endPoint, tunnelRadius);
    
    // 住驻转 专转 转 专 住 专专
    addRetroTunnelLights(tunnel, tunnelLength, startPoint, endPoint);
    
    return tunnel;
};
const addRetroTunnelLights = (tunnel, tunnelLength, startPoint, endPoint) => {
    // 住驻专 专转 专 专
    const numLights = 20;
    // 砖 拽专  拽转 转 拽转 住
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    // 专拽  专转
    const spacing = tunnelLength / numLights;
    
    // 爪注  转驻 住 专专
    const retroColors = [
        0xff00ff, // '
        0x9932CC, // 住 
        0xff1493, // 专 注拽
        0x8a2be2, // -住
        0x9400d3  // 住 
    ];
    
    // 注专 砖专转  专转 专转 爪
    window.tunnelLights = [];
    window.tunnelBulbs = [];
    window.tunnelGlows = [];
    
    // 爪专转 专转 专 专
    for (let i = 0; i < numLights; i++) {
        // 拽 专 拽 注 拽  拽转 转 拽转 住
        const ratio = (i * spacing) / tunnelLength;
        const lightPosition = new THREE.Vector3()
            .copy(startPoint)
            .lerp(endPoint, ratio);
        
        // 转 专 爪 注 驻拽 注 转专
        const offset = 6.5;
        const side = i % 2 === 0 ? 1 : -1; // 爪   砖 住专
        
        // 砖 拽专 爪  专
        const normalizedDirection = direction.clone().normalize();
        const perpendicular = new THREE.Vector3();
        
        if (Math.abs(normalizedDirection.y) < 0.99) {
            perpendicular.set(0, 1, 0);
        } else {
            perpendicular.set(1, 0, 0);
        }
        perpendicular.cross(normalizedDirection).normalize();
        
        // 转 专 爪 转 砖 专 注 注
        lightPosition.add(perpendicular.clone().multiplyScalar(side * offset * 0.7));
        lightPosition.y += 3 + Math.sin(i) * 1.5;
        
        // 专 拽转 爪注 
        const colorIndex = i % retroColors.length;
        const light = new THREE.PointLight(retroColors[colorIndex], 0.6, 8);
        light.position.copy(lightPosition);
        scene.add(light);
        window.tunnelLights.push(light);
        
        // 砖专转 注 住祝 爪
        light.userData = {
            basePosition: lightPosition.clone(),
            offset: perpendicular.clone().multiplyScalar(side * offset * 0.7),
            phase: Math.random() * Math.PI * 2, // 驻 拽专转 爪
            amplitude: 0.3 + Math.random() * 0.2 // 驻 拽专转
        };
        
        // 驻 转专  - 住驻专转 拽转 注 驻拽 专
        const bulbGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const bulbMaterial = new THREE.MeshBasicMaterial({ 
            color: retroColors[colorIndex],
            transparent: true,
            opacity: 0.9
        });
        const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
        bulb.position.copy(light.position);
        scene.add(bulb);
        window.tunnelBulbs.push(bulb);
        
        // 住驻转  住 专
        const glowGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({ 
            color: retroColors[colorIndex],
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.copy(light.position);
        scene.add(glow);
        window.tunnelGlows.push(glow);
    }
    
    // 住驻转 专 住 转驻砖 专 住 专
    const entranceLight = new THREE.PointLight(0x9400d3, 1, 10);
    entranceLight.position.copy(startPoint);
    entranceLight.position.y += 1;
    scene.add(entranceLight);
    
    // 住驻转 专 住 转驻砖 专 爪 专
    const exitLight = new THREE.PointLight(0xff00ff, 1, 10);
    exitLight.position.copy(endPoint);
    exitLight.position.y += 1;
    scene.add(exitLight);
};

        // 住驻转 专转 专 专
        const addTunnelLights = (tunnel, tunnelLength, startPoint, endPoint) => {
            // 住驻专 专转 专 专
            const numLights = 10;
            // 砖 拽专  拽转 转 拽转 住
            const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
            // 专拽  专转
            const spacing = tunnelLength / numLights;
            
            // 爪专转 专转 专 专
            for (let i = 0; i < numLights; i++) {
                // 拽 专 拽 注 拽  拽转 转 拽转 住
                const ratio = (i * spacing) / tunnelLength;
                const lightPosition = new THREE.Vector3()
                    .copy(startPoint)
                    .lerp(endPoint, ratio);
                
                // 转 专 驻 注 注  砖 注 专砖 砖拽
                lightPosition.y += 0.5;
                
                // 专 拽转
                const light = new THREE.PointLight(0xffffcc, 0.3, 5);
                light.position.copy(lightPosition);
                scene.add(light);
                
                // 驻 转专  - 住驻专转 拽转
                const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const bulbMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffee,
                    transparent: true,
                    opacity: 0.8
                });
                const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
                bulb.position.copy(light.position);
                scene.add(bulb);
            }
        };
        
        // 爪专转 注专转 砖 祝 专砖
        const setupFirstPersonControls = () => {
            controls = new THREE.FirstPersonControls(camera, renderer.domElement);
            controls.movementSpeed = 4;
            controls.lookSpeed = 0.03; // 专转 专砖转 -0.1 -0.05
            controls.lookVertical = true;
            controls.constrainVertical = true;
            controls.verticalMin = Math.PI / 6; // 转  注
            controls.verticalMax = Math.PI / 1.8; // 转  
            
            // 专转 专 转 拽爪转 住 砖注爪专 转 转
            const boundaryThreshold = 0.05; // 5% 拽爪 (95% 住 驻注)
            
            //  转转 注专
            document.addEventListener('mousemove', (e) => {
                const mouseX = e.clientX / window.innerWidth;
                const mouseY = e.clientY / window.innerHeight;
                
                // 拽  注专 爪 专 转 (拽专 拽爪转)
                const isNearLeftEdge = mouseX < boundaryThreshold;
                const isNearRightEdge = mouseX > (1 - boundaryThreshold);
                const isNearTopEdge = mouseY < boundaryThreshold;
                const isNearBottomEdge = mouseY > (1 - boundaryThreshold);
                
                // 注爪专转 转  注专 拽爪转
                if (isNearLeftEdge || isNearRightEdge || isNearTopEdge || isNearBottomEdge) {
                    if (controls.activeLook !== false) {
                        controls.activeLook = false;
                    }
                } else {
                    if (controls.activeLook !== true) {
                        controls.activeLook = true;
                    }
                }
            });
        };
        
        // 注转  GLB (专拽 tunnel.glb)
// 注转  GLB (tunnel.glb)
const loadTunnelModel = () => {
    const loader = new THREE.GLTFLoader();
    
    // 爪转 注转 注
    document.getElementById('loading').style.display = 'block';
    document.getElementById('loading').textContent = '注 转 ...';
    
    loader.load(
        '3d/tunnel.glb',
        (gltf) => {
            const model = gltf.scene;
            
            // 专转 爪  砖 
            model.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // 驻 专     砖注 注- 砖转砖
                    if (node.geometry) {
                        node.geometry.scale(-1, 1, 1);
                        node.material.side = THREE.BackSide;
                    }
                }
            });
            
            // 转 住拽 砖  住 专  转专
            model.scale.set(15, 10, 15); // 转 专 专  (注专 X -Z) -10 -15
            
            // 拽  -  拽  住转 转 专 砖
            model.position.set(2, 14, -2); // 砖 拽  转 专  转专
            
            // 砖专转  砖转 
            worldModel = model;
            
            scene.add(model);
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;

            // 驻注转 拽 砖 注
            if (window.tunnelBackgroundMusic && !window.tunnelBackgroundMusic.playing()) {
                window.tunnelBackgroundMusic.play();
                console.log('拽转 专拽注 驻注');
            }
        },
        (xhr) => {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            document.getElementById('loading').textContent = 
                `注 转 ... ${Math.round(percentComplete)}%`;
        },
        (error) => {
            console.error('砖 注转 :', error);
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;
        }
    );
};
        
// 专 注
// 专 注
document.getElementById('back-button').addEventListener('click', () => {
    document.getElementById('next-screen').style.display = 'none';
    
    // 驻住 爪 转注
    movingForward = false;
    movingBackward = false;
    if (controls) {
        controls.moveForward = false;
        controls.moveBackward = false;
    }
    
    controls.enabled = true; // 驻注转 砖 砖
    
    //  砖拽 转转 砖专 注
    if (window.tunnelBackgroundMusic && !window.tunnelBackgroundMusic.playing()) {
        window.tunnelBackgroundMusic.play();
    }
});
        // 转转  
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (controls) {
                controls.handleResize();
            }
        });
        
        // 专转 住 
        const setupWalkSound = () => {
    // 爪专转 拽 住  注 驻爪 驻注 专转 (loop)
    walkSound = new Howl({
        src: ['audio/walk.mp3'],
        loop: true,
        volume: 0.7
    });
            // 专转 注专转 砖注转 拽转 专拽注 专转 专

            
            // 住驻转  专注 爪 注 驻转专 注专
            document.addEventListener('mousedown', (e) => {
                // 拽  抓 驻转专 砖 (0)   (2)
                if ((e.button === 0 || e.button === 2) && !isWalking) {
                    walkSound.play();
                    isWalking = true;
                }
            });
            
            // 住驻转  专注 砖专专 驻转专 注专
            document.addEventListener('mouseup', (e) => {
                // 拽  砖专专 驻转专 砖 (0)   (2)
                if ((e.button === 0 || e.button === 2) && isWalking) {
                    walkSound.pause();
                    isWalking = false;
                }
            });
            
            // 注转 转驻专 拽拽 
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        };
        
        // 转 住爪
// 转 住爪
// 驻拽爪 爪转  住专
// 驻拽爪 爪转  住专
// 驻拽爪 爪转  住专
const setupVideoModal = () => {
    const videoModal = document.getElementById('video-modal');
    const introVideo = document.getElementById('intro-video');
    const missionPopup = document.getElementById('mission-popup');
    
    // 爪转  专 3 砖转
    setTimeout(() => {
        videoModal.style.display = 'block';
        
        // 注爪专转 转注 爪
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
        
        // 砖转 砖  爪转 住专
        if (controls) {
            controls.enabled = false;
        }
        
        //  砖拽  转转  住专
        if (window.tunnelBackgroundMusic && window.tunnelBackgroundMusic.playing()) {
            window.tunnelBackgroundMusic.pause();
        }
        
        // 驻注转 住专 转
        introVideo.play();
        
        // 住驻转  住 住专
        introVideo.addEventListener('ended', () => {
            // 住专转  住专
            videoModal.style.display = 'none';
            
            // 专转 砖 砖转砖
            if (controls) {
                controls.enabled = true;
            }
            
            // 驻注转 拽转 专拽注 专 住 住专
            if (window.tunnelBackgroundMusic && !window.tunnelBackgroundMusic.playing()) {
                window.tunnelBackgroundMusic.play();
                console.log('拽转 专拽注 驻注 专 住 住专');
                
                // 注 驻转专 拽  拽
                const musicToggleBtn = document.getElementById('music-toggle');
                if (musicToggleBtn) {
                    musicToggleBtn.textContent = '';
                }
            }
            
            // 爪转 砖 专 住 住专
            if (missionPopup) {
                setTimeout(() => {
                    console.log("Showing mission popup after video");
                    missionPopup.style.opacity = '1';
                    missionPopup.style.transition = 'opacity 1.5s ease-out';
                }, 1000); // 爪 专 砖 住驻转
            }
        });
        
        //  砖 驻转专 住专, 住祝   
        const closeBtn = document.querySelector('.close-modal');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                videoModal.style.display = 'none';
                introVideo.pause();
                
                // 专转 砖
                if (controls) {
                    controls.enabled = true;
                }
                
                // 驻注转 拽 专 住专转  转
                if (window.tunnelBackgroundMusic && !window.tunnelBackgroundMusic.playing()) {
                    window.tunnelBackgroundMusic.play();
                    console.log('拽转 专拽注 驻注 专 住专转 ');
                    
                    // 注 驻转专 拽  拽
                    const musicToggleBtn = document.getElementById('music-toggle');
                    if (musicToggleBtn) {
                        musicToggleBtn.textContent = '';
                    }
                }
                
                // 爪转 砖  专 住专 转
                if (missionPopup) {
                    setTimeout(() => {
                        console.log("Showing mission popup after manual close");
                        missionPopup.style.opacity = '1';
                        missionPopup.style.transition = 'opacity 1.5s ease-out';
                    }, 1000); // 爪 专 砖 住驻转
                }
            });
        }
    }, 3000); // 3 砖转
};
// 住驻转 驻拽 驻注 转 砖
const setupMissionPopup = () => {
    const missionPopup = document.getElementById('mission-popup');
    console.log("Setting up mission popup:", missionPopup);
    
    //  转 转 转
    if (missionPopup) {
        // 专转 砖转 转  转
        missionPopup.style.opacity = '0';
        
        // 爪 转 转 专 住 住专
        // 砖转砖 砖转   注转 转 住专 住转
        window.showMissionAfterVideo = true;
    } else {
        console.error("Mission popup element not found!");
    }
};
const init = () => {
    // 专转 转专
    setupLighting();
    camera.lookAt(specialPortalPoint);
    // 爪专转 拽专拽注 砖 住 砖
    createFlatRoadGround();
    
    // 爪专转 爪专/专
    createTunnel();
    
    // 爪专转 砖 砖拽
    createGameSigns();
    
    // 专转 砖 祝 专砖
    setupFirstPersonControls();
    
    // 专转 住 
    setupWalkSound();
    
    // 专转 拽专转 转注 - 住驻 驻
    setupMovementControls();
    
    // 专转 拽转 专拽注 专
    setupTunnelBackgroundMusic();
    
    // 爪专转 驻拽 驻专 注 注砖 住
    createPortalEffect();
    
    
    // 拽 砖拽 拽转 转 砖
    camera.position.set(-31.42, 10.20, 32.99); // 拽 转转 砖 砖拽    
    
    // 注转  GLB 砖 专 
    loadTunnelModel();
    
    // 注转 驻  爪专转 住驻专 砖
    loadFont().then(() => {
        createYearNumbers();
    }).catch(error => {
        console.error('砖 爪专转 住驻专 砖:', error);
    });
    
    // 专转 转 砖
    setupMissionPopup();
    
    // 驻注转  住专 (拽专 驻拽爪 砖住驻)
    setupVideoModal();
    
    // 专 注
    setTimeout(() => {
        if (document.getElementById('loading').style.display !== 'none') {
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;
        }
    }, 5000);
    
    // 转转 转 爪
    animate();
};
        
        // 驻拽爪转 爪
// 驻拽爪转 爪
const animate = () => {
    requestAnimationFrame(animate);
    
    if (isLoaded) {
        const delta = clock.getDelta();
        
        // 住 拽住专转 专
        if (tunnelTexture) {
            // 转 拽住专 爪专 驻拽 (住)
            tunnelTexture.offset.x += 0.002; // 注专 拽 注专 住 
            
            // 转 拽住专  爪专  驻拽 转转-
            tunnelTexture.offset.y += 0.001; // 注专 拽 祝 转专
        }
        
        if (controls) {
            // 砖专转 拽 拽 驻 注
            const previousPosition = camera.position.clone();
            
            // 注 砖
            controls.update(delta);
            
            // 拽转 转砖转 注 拽专转 专
            if (checkTunnelCollisions(camera.position)) {
                //  砖 转砖转, 专 拽 拽
                camera.position.copy(previousPosition);
            }
            
            // 砖专转  拽注 注 专爪驻 (专爪驻 砖)
            camera.position.y = PLAYER_HEIGHT;
            
            // 驻住转 拽  砖 砖拽 拽住 住  驻专
            const positionInfo = `拽 砖拽: X: ${camera.position.x.toFixed(2)}, Y: ${camera.position.y.toFixed(2)}, Z: ${camera.position.z.toFixed(2)}`;
            console.log(positionInfo);
            
            // 爪转 拽 注 住
            if (!window.positionDisplay) {
                window.positionDisplay = document.createElement('div');
                window.positionDisplay.style.position = 'absolute';
                window.positionDisplay.style.bottom = '10px';
                window.positionDisplay.style.left = '10px';
                window.positionDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                window.positionDisplay.style.color = 'white';
                window.positionDisplay.style.padding = '5px';
                window.positionDisplay.style.fontFamily = 'monospace';
                window.positionDisplay.style.fontSize = '14px';
                window.positionDisplay.style.borderRadius = '3px';
                window.positionDisplay.style.zIndex = '1000';
                document.body.appendChild(window.positionDisplay);
            }
            window.positionDisplay.textContent = positionInfo;
            
            // 拽转  注 拽转 驻专
            checkCustomLocationPoints(camera.position);
        }
        
        // 爪 驻专 注 注砖 住
        // 转 驻拽爪转 animate(), 拽 砖 转 注 拽 专:
animatePortal();
animateYearNumbers();
animateGameSigns(); // 住祝 转 
        
    }
    // 爪 砖 专转 专 转砖转 住 住驻转
if (window.tunnelLights && window.tunnelLights.length > 0) {
    const time = performance.now() * 0.001; //  砖转
    
    for (let i = 0; i < window.tunnelLights.length; i++) {
        const light = window.tunnelLights[i];
        const bulb = window.tunnelBulbs[i];
        const glow = window.tunnelGlows[i];
        
        if (light && light.userData) {
            // 爪 注转 砖 专
            const angle = time * 0.5 + light.userData.phase;
            const x = Math.cos(angle) * light.userData.amplitude;
            const z = Math.sin(angle) * light.userData.amplitude;
            
            // 转 住 拽 住住
            const newPosition = light.userData.basePosition.clone();
            newPosition.x += x;
            newPosition.z += z;
            
            // 注 拽 砖 专  
            light.position.copy(newPosition);
            
            if (bulb) bulb.position.copy(newPosition);
            if (glow) glow.position.copy(newPosition);
            
            // 砖 注爪转 专 驻 专
            light.intensity = 0.4 + 0.3 * Math.sin(time * 2 + light.userData.phase);
            
            // 砖  专 驻 专
            if (glow) {
                glow.scale.set(
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase),
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase),
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase)
                );
            }
        }
    }
}
    renderer.render(scene, camera);
};
        
        // 驻注转 转 砖祝 注
        window.addEventListener('load', init);
        // 注转 驻 拽住 转转-
const loadFont = () => {
    const fontLoader = new THREE.FontLoader();
    return new Promise((resolve, reject) => {
        fontLoader.load(
            'https://cdn.jsdelivr.net/npm/three@0.134.0/examples/fonts/helvetiker_bold.typeface.json',
            (font) => {
                window.yearFont = font;
                resolve(font);
            },
            undefined,
            (error) => {
                console.error('砖 注转 驻:', error);
                reject(error);
            }
        );
    });
};

// 爪专转 住驻专 砖 转拽专转 专
// 爪专转 住驻专 砖 转拽专转 专 - 转拽  专 住 拽住
// 爪专转 住驻专 砖 转拽专转 专 注 拽 专
const createYearNumbers = () => {
    // 注专 砖 - 砖 转 专
    const years = [];
    for (let year = 2025; year >= 1980; year--) {
        years.push(year);
    }
    
    // 拽转 转 住 专
    const startPoint = new THREE.Vector3(-24.63, 12.0, 26.94);
    const endPoint = new THREE.Vector3(33.19, 12.0, -38.43);
    
    // 专 专
    const tunnelLength = startPoint.distanceTo(endPoint);
    
    // 专拽   砖
    const spaceBetweenYears = tunnelLength / (years.length - 1);
    
    //  专
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
    
    // 砖 拽专 爪  专 (爪专  爪转)
    const perpendicular = new THREE.Vector3();
    if (Math.abs(direction.y) < 0.99) {
        perpendicular.set(0, 1, 0);
    } else {
        perpendicular.set(1, 0, 0);
    }
    perpendicular.cross(direction).normalize();
    
    // 注专 砖专转 拽
    window.yearObjects = [];
    
    // 爪专转  住驻专 砖
    years.forEach((year, index) => {
        // 爪专转 专 拽住
        const textGeometry = new THREE.TextGeometry(year.toString(), {
    font: window.yearFont,
    size: 0.6, // 拽 0.4
    height: 0.1, // 拽 0.05
    curveSegments: 5,
    bevelEnabled: false
});
        
        // 专 专 拽住
        const textMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x00ffff,
            emissive: 0x00ccff,
            emissiveIntensity: 1,
            metalness: 0.8,
            roughness: 0.2
        });
        
        // 爪专转 拽 拽住
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        
        // 砖 拽  专 专
        const distanceFromStart = index * spaceBetweenYears;
        const currentPosition = new THREE.Vector3().copy(startPoint).addScaledVector(direction, distanceFromStart);
        
        // 住驻转  专  2 -5 转 注 专爪驻转 专
        const randomHeight = 2 + Math.random() * 1; // 注专  2 -5
        currentPosition.y += randomHeight;
        
        // 住驻转  爪转 专转
        const randomSideOffset = (Math.random() * 9) - 3; // 注专  -3 +3
        currentPosition.add(perpendicular.clone().multiplyScalar(randomSideOffset));
        
        // 拽 拽住
        textMesh.position.copy(currentPosition);
        
        // 住 拽住  砖 拽  专
        textMesh.lookAt(new THREE.Vector3().copy(currentPosition).addScaledVector(direction, -1));
        
        // 住驻转 住 住  砖拽住  拽专
        textMesh.rotation.y = 150;
        
        // 住 住祝 转拽  拽住
        // 住驻转 住 专 拽
        const randomRotation = (Math.random() * 0.3) - 0.15; // 专爪 拽  住祝
        textMesh.rotation.z += randomRotation;
        
        // 专 拽住
        textGeometry.computeBoundingBox();
        const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
        textMesh.position.x -= textWidth / 2;
        
        // 住驻转 驻拽 专 住 拽住
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        
        const glowMesh = new THREE.Mesh(textGeometry, glowMaterial);
        glowMesh.position.copy(textMesh.position);
        glowMesh.rotation.copy(textMesh.rotation);
        glowMesh.scale.multiplyScalar(1.2);
        
        // 住驻 住爪
        scene.add(textMesh);
        scene.add(glowMesh);
        
        // 砖专转 拽 爪 砖
        window.yearObjects.push({
            text: textMesh,
            glow: glowMesh,
            year: year,
            basePosition: currentPosition.clone()
        });
    });
};

// 爪转 砖
const animateYearNumbers = () => {
    if (!window.yearObjects) return;
    
    const time = performance.now() * 0.001;
    
    window.yearObjects.forEach((yearObj, index) => {
        if (yearObj.text && yearObj.glow) {
            // 驻拽 专祝 注 
            const floatY = Math.sin(time + index * 0.2) * 0.2;
            
            // 注 拽
            yearObj.text.position.y = yearObj.basePosition.y + floatY;
            yearObj.glow.position.y = yearObj.basePosition.y + floatY;
            
            // 驻拽 专 砖转
            const glowFactor = 0.7 + 0.3 * Math.sin(time * 2 + index * 0.5);
            yearObj.glow.scale.set(1.1 + glowFactor * 0.1, 1.1 + glowFactor * 0.1, 1.1);
            
            // 驻拽 爪注 砖转 -  砖转拽  爪注 砖转
            // 转转 (2025) 住/专 (1980)
            if (yearObj.text.material) {
                // 砖  驻 拽 砖 注专
                // 0 = 砖 注砖转, 1 = 砖  砖
                const normalizedIndex = index / (window.yearObjects.length - 1);
                
                // 注专 专转 爪注 转转 (0x00ffff) 住/专 (0xff00ff)
                const r = Math.floor(normalizedIndex * 255);
                const g = Math.floor((1 - normalizedIndex) * 255);
                const b = 255;
                
                // 注 爪注 拽住 专
                yearObj.text.material.color.setRGB(r/255, g/255, b/255);
                yearObj.text.material.emissive.setRGB(r/255, g/255, b/255);
                yearObj.glow.material.color.setRGB(r/255, g/255, b/255);
            }
        }
    });
};
// 爪专转 砖 砖拽 注 专爪驻转 专
// 爪专转 砖 注 砖拽 专 -  转 砖爪专驻
const createGameSigns = () => {
    // 注专 砖 - 砖 转 专
    const years = [];
    for (let year = 2025; year >= 1980; year -= 5) {
        years.push(year);
    }
    
    // 拽转 转 住 专
    const startPoint = new THREE.Vector3(-24.63, 12.0, 26.94);
    const endPoint = new THREE.Vector3(33.19, 12.0, -38.43);
    
    // 专 专
    const tunnelLength = startPoint.distanceTo(endPoint);
    
    // 专拽   砖
    const spaceBetweenSigns = tunnelLength / (years.length - 1);
    
    //  专
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
    
    // 砖 拽专 爪  专 (爪专  爪转)
    const perpendicular = new THREE.Vector3();
    if (Math.abs(direction.y) < 0.99) {
        perpendicular.set(0, 1, 0);
    } else {
        perpendicular.set(1, 0, 0);
    }
    perpendicular.cross(direction).normalize();
    
    // 注专 砖专转 拽
    window.gameSigns = [];
    
    // 注转 拽住专转 专砖  注 注
    const textureLoader = new THREE.TextureLoader();
    const textures = {};
    
    // 爪专转 转 注转  拽住专转
    const texturePromises = years.map(year => {
        return new Promise((resolve, reject) => {
            const url = `signs/${year}.jpg`;
            textureLoader.load(
                url,
                texture => {
                    textures[year] = texture;
                    resolve();
                },
                undefined,
                error => {
                    console.error(`砖 注转 转 砖转 ${year}:`, error);
                    //  砖 砖, 爪专 拽住专 驻转 注 砖
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.font = 'bold 48px Arial';
                    ctx.fillStyle = '#333333';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(year.toString(), canvas.width / 2, canvas.height / 2);
                    
                    // 住驻转 转专转 
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('砖拽 ', canvas.width / 2, canvas.height / 4);
                    
                    textures[year] = new THREE.CanvasTexture(canvas);
                    resolve();
                }
            );
        });
    });
    
    // 转 注转  拽住专转 驻 爪专转 砖
    Promise.all(texturePromises).then(() => {
        // 爪专转  砖
        years.forEach((year, index) => {
            // 砖 拽 专 专
            const distanceFromStart = index * spaceBetweenSigns;
            const currentPosition = new THREE.Vector3().copy(startPoint).addScaledVector(direction, distanceFromStart);
            
            // 拽 注 注 专爪驻
            const basePosition = currentPosition.clone();
            basePosition.y = 8.5; // 注 专爪驻
            
            // 住驻转  爪转 拽
            // 驻  爪 砖  转 拽住
            const sideOffset = (index % 2 === 0) ? 4 : -4;
            basePosition.add(perpendicular.clone().multiplyScalar(sideOffset));
            
            // ===== 爪专转 注 =====
            // 1. 住住 注
            const baseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.1, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0xCCCCCC,
                metalness: 0.8,
                roughness: 0.2
            });
            const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
            baseMesh.position.copy(basePosition);
            baseMesh.position.y += 0.05; // 爪  住住
            
            // 2. 注 注爪
            const poleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0xCCCCCC,
                metalness: 0.8,
                roughness: 0.2
            });
            const poleMesh = new THREE.Mesh(poleGeometry, poleMaterial);
            poleMesh.position.copy(basePosition);
            poleMesh.position.y += 1; // 爪  注 +  住住
            
            // 3. 专   注 砖
            const connectorGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.3, 8);
            const connectorMaterial = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA,
                metalness: 0.7,
                roughness: 0.3
            });
            const connectorMesh = new THREE.Mesh(connectorGeometry, connectorMaterial);
            connectorMesh.position.copy(basePosition);
            connectorMesh.position.y += 2.1; // 专砖 注
            connectorMesh.rotation.x = Math.PI / 2; // 住  驻拽
            
            // ===== 爪专转 砖 =====
            // 住专转 砖
            const frameGeometry = new THREE.BoxGeometry(2.5, 3.5, 0.1);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                metalness: 0.3,
                roughness: 0.7
            });
            const frameMesh = new THREE.Mesh(frameGeometry, frameMaterial);
            frameMesh.position.copy(basePosition);
            frameMesh.position.y += 4; // 拽 砖 注 注
            
            // 住驻转 拽住专 砖
            const signGeometry = new THREE.PlaneGeometry(2.3, 3.3);
// 驻 拽专转 -UV  转拽 转 驻拽 专
const uvs = signGeometry.attributes.uv.array;
for (let i = 0; i < uvs.length; i += 2) {
    uvs[i] = 1 - uvs[i]; // 驻 拽专转 -x 砖 -UV
}
            const signMaterial = new THREE.MeshStandardMaterial({
                map: textures[year],
                roughness: 0.4,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            const signMesh = new THREE.Mesh(signGeometry, signMaterial);
            signMesh.position.copy(frameMesh.position);
            signMesh.position.z += 0.1; // 注 拽 住专转
            
            // 住 砖  砖驻   砖 专
            // 专爪 砖砖 驻   砖 专  砖专转 专
            // 专转 转 拽注  砖,  砖 砖 1995
// 砖转砖 专爪 拽注 拽 lookAt
const fixedRotation = new THREE.Euler(0, Math.PI * 0.75, 0); // 转 拽注 (注专 135 注转)
frameMesh.setRotationFromEuler(fixedRotation);
signMesh.setRotationFromEuler(fixedRotation);
connectorMesh.rotation.x = Math.PI / 2; // 砖专 转 住 驻拽 砖 专
connectorMesh.rotation.y = fixedRotation.y; // 转 转 住 驻拽 转 拽注
            
            // 住驻转 转专 转 砖
            const spotLight = new THREE.SpotLight(0xffffff, 0.8);
            spotLight.position.copy(frameMesh.position);
            spotLight.position.y += 1; // 拽 专 注 砖
            spotLight.position.z += 0.5; // 拽爪转 拽
            spotLight.target = signMesh;
            spotLight.angle = Math.PI / 6; // 专 
            spotLight.penumbra = 0.2; // 专转 拽爪转 专
            spotLight.distance = 5; // 专拽 专
            spotLight.castShadow = true;
            
            // 砖驻专 转 爪
            spotLight.shadow.mapSize.width = 512;
            spotLight.shadow.mapSize.height = 512;
            spotLight.shadow.camera.near = 0.5;
            spotLight.shadow.camera.far = 5;
            
            // 拽爪  拽 砖
            const signGroup = new THREE.Group();
            signGroup.add(baseMesh);
            signGroup.add(poleMesh);
            signGroup.add(connectorMesh);
            signGroup.add(frameMesh);
            signGroup.add(signMesh);
            
            // 住驻 住爪
            scene.add(signGroup);
            scene.add(spotLight);
            
            // 砖专转 拽
            window.gameSigns.push({
                group: signGroup,
                sign: signMesh,
                frame: frameMesh,
                light: spotLight,
                year: year,
                basePosition: basePosition.clone()
            });
            
            // 住驻转 拽住 砖 砖 转转 砖
            // 爪专转 专 拽住
            if (window.yearFont) {
                const textGeometry = new THREE.TextGeometry(year.toString(), {
    font: window.yearFont,
    size: 0.6, // 拽 0.4
    height: 0.1, // 拽 0.05
    curveSegments: 5,
    bevelEnabled: false
});
                
                // 专 拽住
                //
                /*
                const textMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    emissive: 0x222222,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                
                // 爪专转 拽 拽住
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                
                // 拽 拽住 转转 砖
                textMesh.position.copy(frameMesh.position);
                textMesh.position.y -= 0.5; // 转转 砖
                
                // 住 拽住  砖
                textMesh.rotation.copy(frameMesh.rotation);
                
                // 专 拽住
                textGeometry.computeBoundingBox();
                const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                textMesh.position.x -= textWidth / 2;
                textMesh.position.z += 0.2;
                // 住驻 住爪 拽爪
                signGroup.add(textMesh);
                */
            }
        });
    });
};

// 爪转 砖
const animateGameSigns = () => {
    if (!window.gameSigns) return;
    
    const time = performance.now() * 0.001;
    
    window.gameSigns.forEach((signObj, index) => {
        if (signObj.group && signObj.light) {
            // 驻拽 注注 拽 砖 砖
            const swayAngle = Math.sin(time * 0.5 + index * 0.2) * 0.01;
            
            // 注 专爪 砖 拽爪
            //signObj.group.rotation.y = signObj.group.rotation.y * 0.95 + swayAngle * 0.05;
            
            // 砖 注爪转 专 驻 专
            signObj.light.intensity = 0.6 + 0.4 * Math.sin(time * 0.7 + index * 0.3);
        }
    });
};
    </script>
</body>
</html>