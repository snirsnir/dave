<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>עולם תלת מימדי עם Three.js</title>
    <!-- טעינת ספריות Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/FirstPersonControls.js"></script>
    <!-- טעינת ספריית Audio -->
    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/geometries/TextGeometry.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: default;
        }
        
        #scene-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        
        #controls-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        
        #next-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        
        #back-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 100;
        }
        .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 1000;
    font-family: 'Varela Round', Arial, sans-serif;
}

.modal-content {
    position: relative;
    background-color: #000;
    margin: 5% auto;
    width: 90%;
    max-width: 800px;
    border-radius: 25px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    animation: modalPopIn 0.7s;
    direction: rtl;
    border: 8px solid #9932CC;
}

@keyframes modalPopIn {
    0% { transform: scale(0.5); opacity: 0; }
    50% { transform: scale(1.05); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

.modal-header {
    background: linear-gradient(to left, #9932CC, #8A2BE2);
    color: white;
    padding: 20px;
    border-radius: 17px 17px 0 0;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
}

.modal-header h2 {
    margin: 0;
    font-size: 32px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    font-weight: bold;
}

.modal-body {
    padding: 0;
    background-color: black;
    border-radius: 0 0 17px 17px;
}

#intro-video {
    display: block;
    border-radius: 0 0 17px 17px;
}

.modal-title-container {
    position: relative;
    display: inline-block;
}

.modal-title-container h2 {
    position: relative;
    z-index: 1;
}
#mission-popup {
    animation: float 3s ease-in-out infinite;
    width: auto;
    max-width: 95%; /* הגדלת max-width מ-90% */
    transform: translate(-50%, 0);
    top: 15px; /* מיקום גבוה יותר */
}

@keyframes float {
    0% { transform: translate(-50%, 0px); }
    50% { transform: translate(-50%, -10px); }
    100% { transform: translate(-50%, 0px); }
}

.mission-container {
    background: linear-gradient(135deg, rgba(230, 250, 240, 0.9), rgba(210, 240, 255, 0.95));
    border: 5px solid #9932CC; /* הגדלת עובי המסגרת מ-3px ל-5px */
    border-radius: 20px; /* הגדלת הרדיוס מ-15px ל-20px */
    padding: 5px; /* הגדלת padding */
    box-shadow: 0 0 20px rgba(153, 50, 204, 0.8), 0 0 35px rgba(0, 0, 0, 0.3); /* צל חזק יותר */
}

.mission-content {
    background: rgba(255, 255, 255, 0.85);
    border-radius: 15px; /* הגדלת רדיוס מ-12px */
    padding: 15px 25px; /* הגדלת padding מ-10px 20px */
}

.mission-icon {
    font-size: 40px; /* הגדלת גודל האייקון מ-28px */
    margin-left: 20px; /* יותר מרחק מהטקסט */
    color: #9932CC;
    text-shadow: 0 0 15px rgba(153, 50, 204, 0.9); /* צל חזק יותר */
}

.mission-text {
    text-align: right;
}

.mission-desc {
    color: #333;
    font-size: 24px; /* הגדלת גודל הטקסט מ-16px */
    font-weight: bold;
    text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
}
    </style>
</head>
<body>
    <!-- Modal for video -->
    <div id="mission-popup" style="opacity: 1; position: fixed; top: 15px; left: 50%; transform: translateX(-50%); z-index: 999; width: auto; max-width: 95%;">
        <div class="mission-container" style="background: linear-gradient(135deg, rgba(230, 250, 240, 0.9), rgba(210, 240, 255, 0.95)); border: 5px solid #9932CC; border-radius: 20px; padding: 5px; box-shadow: 0 0 20px rgba(153, 50, 204, 0.8), 0 0 35px rgba(0, 0, 0, 0.3);">
            <div class="mission-content" style="background: rgba(255, 255, 255, 0.85); border-radius: 15px; padding: 15px 25px; display: flex; align-items: center; position: relative; z-index: 1;">
                <div class="mission-icon" style="font-size: 40px; margin-left: 20px; color: #9932CC; text-shadow: 0 0 15px rgba(153, 50, 204, 0.9);">🔮</div>
                <div class="mission-text" style="text-align: right;">
                    <div class="mission-desc" style="color: #333; font-size: 24px; font-weight: bold; text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);">הגיעו לקצה מנהרת הזמן</div>
                </div>
            </div>
        </div>
    </div>
<div id="video-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title-container">
                <h2>ברוכים הבאים למנהרת הזמן!</h2>
            </div>
        </div>
        <div class="modal-body" style="padding: 0;">
            <video id="intro-video" width="100%" controls>
                <source src="vid/2.mp4" type="video/mp4">
                הדפדפן שלך לא תומך בתגית וידאו.
            </video>
        </div>
    </div>
</div>
    <div id="scene-container"></div>
    
    <div id="loading">טוען את העולם...</div>
    
    <div id="controls-info">
        <p>תנועה קדימה: הקשה על קליק שמאלי בעכבר</p>
        <p>תנועה אחורה: הקשה על קליק ימני בעכבר</p>
        <p>מבט: הזיזו את העכבר</p>
    </div>
    
    <div id="crosshair">+</div>
    
    <div id="next-screen">
        <h1>הגעת ליעד!</h1>
        <p>זהו המסך הבא.</p>
        <button id="back-button">חזרה לעולם</button>
    </div>
    
    <script>
        // יצירת סצנה, מצלמה ורנדרר
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-31.42, 10.20, 32.99);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // צללים רכים יותר
        
        // הגדרת צבע רקע שמיים כחול
        renderer.setClearColor(0x6495ED);
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // משתנים גלובליים
// משתנים גלובליים
let controls;
let worldModel;
let isLoaded = false;
let clock = new THREE.Clock();
let ground; // משתנה לשמירת הרצפה
let tunnelObject; // משתנה לשמירת המנהרה
let tunnelWalls = []; // מערך לשמירת קולידרים של קירות המנהרה
let tunnelTexture; // משתנה לשמירת הטקסטורה המסתובבת
let tunnelMaterial; // משתנה לשמירת המטריאל של המנהרה
        // משתנים לאודיו
        let walkSound;
        let isWalking = false;
        
        // נקודת המעבר המיוחדת למסך הבא
        const specialPortalPoint = new THREE.Vector3(29.11, 10.20, -34.25); // מיקום חדש לפורטל הסגול
        const portalRadius = 6; // רדיוס גדול יותר לאזור הפורטל
        let portalParticles; // משתנה לשמירת מערכת החלקיקים של הפורטל
        // הוסף משתנה גלובלי לעקוב אחרי מצב התנועה
let movingForward = false;
let movingBackward = false;

// פונקציה לשליטה בתנועה
const setupMovementControls = () => {
    // הוספת מאזין לאירוע לחיצה על כפתור העכבר
    document.addEventListener('mousedown', (e) => {
        // בדיקה אם לחץ כפתור שמאלי (0)
        if (e.button === 0) {
            movingForward = true;
            if (controls) controls.moveForward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
        // בדיקה אם לחץ כפתור ימני (2)
        else if (e.button === 2) {
            movingBackward = true;
            if (controls) controls.moveBackward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
    });
    
    // הוספת מאזין לאירוע שחרור כפתור העכבר
    document.addEventListener('mouseup', (e) => {
        // בדיקה אם שוחרר כפתור שמאלי (0)
        if (e.button === 0) {
            movingForward = false;
            if (controls) controls.moveForward = false;
            
            // עוצר צליל רק אם גם קדימה וגם אחורה לא פעילים
            if (isWalking && !movingBackward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
        // בדיקה אם שוחרר כפתור ימני (2)
        else if (e.button === 2) {
            movingBackward = false;
            if (controls) controls.moveBackward = false;
            
            // עוצר צליל רק אם גם קדימה וגם אחורה לא פעילים
            if (isWalking && !movingForward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // עצירת תנועה אוטומטית כשעוזבים את העמוד או עוברים ללשונית אחרת
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            // אם העמוד הוסתר, עצור את כל התנועה
            if (controls) {
                controls.moveForward = false;
                controls.moveBackward = false;
            }
            movingForward = false;
            movingBackward = false;
            
            if (isWalking && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // עצירת תנועה כשעוזבים את העמוד
    window.addEventListener('beforeunload', () => {
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
    });
    
    // מניעת תפריט קליק ימני
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
};
        // יצירת פורטל עם חלקיקי עשן סגול
        const createPortalEffect = () => {
            // יצירת גיאומטריה לחלקיקים
            const particleCount = 500;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            // הגדרת עשן במעגל סביב נקודת הפורטל
            for (let i = 0; i < particleCount; i++) {
                // מיקום אקראי בתוך ספירה
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * portalRadius;
                const height = Math.random() * 5; // גובה החלקיקים
                
                // הוספת רנדומיות קטנה למיקום
                positions[i * 3] = specialPortalPoint.x + Math.cos(angle) * radius;
                positions[i * 3 + 1] = specialPortalPoint.y + height;
                positions[i * 3 + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                
                // צבע סגול עם וריאציות קלות
                colors[i * 3] = 0.5 + Math.random() * 0.2; // אדום
                colors[i * 3 + 1] = 0; // ירוק
                colors[i * 3 + 2] = 0.8 + Math.random() * 0.2; // כחול
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // יצירת מטריאל לחלקיקים עם סוג ערבוב (Blending) מתאים לעשן
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.4,
                transparent: true,
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            // יצירת המערכת חלקיקים
            portalParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(portalParticles);
            
            // הוספת אור נקודתי סגול באזור הפורטל
            const portalLight = new THREE.PointLight(0x9932CC, 1, 10);
            portalLight.position.copy(specialPortalPoint);
            portalLight.position.y += 1.5; // הרמת האור מעט
            scene.add(portalLight);
        };
        const setupTunnelBackgroundMusic = () => {
    // מערך של נתיבים לקבצי המוזיקה
    const musicTracks = [
        'audio/tunnel/1.mp3',
        'audio/tunnel/2.mp3',
        'audio/tunnel/3.mp3',
        'audio/tunnel/4.mp3'
    ];
    
    // בחירת שיר אקראי מהמערך
    const randomTrackIndex = Math.floor(Math.random() * musicTracks.length);
    const selectedTrack = musicTracks[randomTrackIndex];
    
    // יצירת אובייקט סאונד למוזיקת רקע
    const backgroundMusic = new Howl({
        src: [selectedTrack],
        loop: true,      // ניגון חוזר
        volume: 0.5,     // עוצמת שמע (0-1)
        autoplay: false  // לא להתחיל אוטומטית
    });
    
    // שמירת האובייקט למשתנה גלובלי כדי שנוכל להתייחס אליו בהמשך
    window.tunnelBackgroundMusic = backgroundMusic;
    
    console.log(`נבחר שיר רקע למנהרה: ${selectedTrack}`);
    
    // הוספת כפתור להשתקת/הפעלת המוזיקה
    createMusicToggleButton();
    
    // החזרת האובייקט במקרה שנרצה להשתמש בו
    return backgroundMusic;
};

// יצירת כפתור השתקת מוזיקה
const createMusicToggleButton = () => {
    // בדיקה אם הכפתור כבר קיים
    if (document.getElementById('music-toggle')) {
        return;
    }
    
    // יצירת כפתור השתקת מוזיקה
    const musicToggleBtn = document.createElement('button');
    musicToggleBtn.id = 'music-toggle';
    musicToggleBtn.title = 'השתק/הפעל מוזיקה';
    musicToggleBtn.textContent = '🔊';
    musicToggleBtn.style.position = 'absolute';
    musicToggleBtn.style.top = '10px';
    musicToggleBtn.style.left = '10px';
    musicToggleBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    musicToggleBtn.style.color = 'white';
    musicToggleBtn.style.border = 'none';
    musicToggleBtn.style.borderRadius = '5px';
    musicToggleBtn.style.padding = '5px 10px';
    musicToggleBtn.style.fontSize = '20px';
    musicToggleBtn.style.cursor = 'pointer';
    musicToggleBtn.style.zIndex = '100';
    
    document.body.appendChild(musicToggleBtn);
    
    // הוספת מאזין אירועים לכפתור
    musicToggleBtn.addEventListener('click', () => {
        console.log('כפתור השתקה נלחץ');
        
        if (window.tunnelBackgroundMusic) {
            if (window.tunnelBackgroundMusic.playing()) {
                window.tunnelBackgroundMusic.pause();
                musicToggleBtn.textContent = '🔇';
                console.log('מוזיקה הושתקה');
            } else {
                window.tunnelBackgroundMusic.play();
                musicToggleBtn.textContent = '🔊';
                console.log('מוזיקה הופעלה');
            }
        } else {
            console.error('אובייקט המוזיקה לא נמצא!');
        }
    });
    
    // הוספת מאזין אירועים למקש M להשתקת/הפעלת המוזיקה
    document.addEventListener('keydown', (e) => {
        if (e.key === 'm' || e.key === 'M' || e.key === 'מ') {
            if (window.tunnelBackgroundMusic) {
                if (window.tunnelBackgroundMusic.playing()) {
                    window.tunnelBackgroundMusic.pause();
                    musicToggleBtn.textContent = '🔇';
                    console.log('מוזיקה הושתקה');
                } else {
                    window.tunnelBackgroundMusic.play();
                    musicToggleBtn.textContent = '🔊';
                    console.log('מוזיקה הופעלה');
                }
            }
        }
    });
};
        // אנימציה לפורטל
        const animatePortal = () => {
            if (portalParticles) {
                const positions = portalParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // תנועה אקראית קלה
                    positions[i] += (Math.random() - 0.5) * 0.05;
                    positions[i + 1] += Math.random() * 0.05; // תנועה קלה למעלה
                    positions[i + 2] += (Math.random() - 0.5) * 0.05;
                    
                    // החזר חלקיקים שיצאו חזרה לאזור הפורטל
                    const dx = positions[i] - specialPortalPoint.x;
                    const dz = positions[i + 2] - specialPortalPoint.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance > portalRadius || positions[i + 1] > specialPortalPoint.y + 5) {
                        // אם החלקיק יצא מהגבולות, החזר אותו למיקום חדש בתוך הפורטל
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * portalRadius * 0.7;
                        
                        positions[i] = specialPortalPoint.x + Math.cos(angle) * radius;
                        positions[i + 1] = specialPortalPoint.y + Math.random() * 2.5;
                        positions[i + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                    }
                }
                
                portalParticles.geometry.attributes.position.needsUpdate = true;
            }
        };
        
        // פונקציה לבדיקת מיקום חדש ומעבר למסך הבא
// פונקציה לבדיקת מיקום חדש ומעבר למסך הבא
const checkCustomLocationPoints = (position) => {
    // בדיקת מרחק מנקודת הפורטל המיוחדת
    const distanceToPortal = position.distanceTo(specialPortalPoint);
    
    if (distanceToPortal < portalRadius / 2) {
        // עצירת התנועה והצליל לפני מעבר דף
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        // עצירת המוזיקה לפני המעבר לדף אחר
        if (window.tunnelBackgroundMusic && window.tunnelBackgroundMusic.playing()) {
            window.tunnelBackgroundMusic.stop();
        }
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
        
        // מעבר לדף enter.html
        window.location.href = 'enter.html';
        return true;
    }
    
    return false;
};
        
        // קבוע גובה השחקן מעל האדמה
        const PLAYER_HEIGHT = 10.2;
        
        // תאורה ואפקטים
        const setupLighting = () => {
            // אור סביבה
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // אור השמש הראשי
            const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.0);
            sunLight.position.set(10, 20, 15);
            sunLight.castShadow = true;
            
            // הגדרות צל איכותיות יותר
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            sunLight.shadow.bias = -0.0003;
            
            scene.add(sunLight);
            
            // נקודת אור משנית לתאורת מילוי
            const fillLight = new THREE.DirectionalLight(0xc2d1ff, 0.5);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
            
            // אור נקודתי עדין במרכז הסצנה
            const pointLight = new THREE.PointLight(0xffedbe, 0.5, 20);
            pointLight.position.set(0, 12, 0);
            scene.add(pointLight);
            
            // ערפל לתחושת עומק
            scene.fog = new THREE.FogExp2(0x8eb5e0, 0.006); // הקטנת ערך הצפיפות לגובה הגדול יותר
        };
        
        // יצירת טקסטורת רצפה בסגנון כביש
// יצירת טקסטורת רצפה בסגנון כביש ללא סימונים
const createRoadTexture = () => {
    const textureSize = 1024;
    const canvas = document.createElement('canvas');
    canvas.width = textureSize;
    canvas.height = textureSize;
    const ctx = canvas.getContext('2d');
    
    // צבע רקע אספלט - אפור כהה
    ctx.fillStyle = '#333333';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // הוספת מרקם לאספלט
    for (let i = 0; i < 10000; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 3;
        
        // גוונים של אפור למרקם האספלט
        const shade = 50 + Math.random() * 30;
        ctx.fillStyle = `rgba(${shade}, ${shade}, ${shade}, 0.4)`;
        ctx.fillRect(x, y, size, size);
    }
    
    // הוספת פגמים ובורות בכביש
    for (let i = 0; i < 30; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = 5 + Math.random() * 20;
        
        // בור בכביש - עיגול כהה
        const shade = 20 + Math.random() * 30;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        gradient.addColorStop(0, `rgba(${shade}, ${shade}, ${shade}, 0.8)`);
        gradient.addColorStop(1, 'rgba(51, 51, 51, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
        
        // הוספת סדקים בכביש
        if (Math.random() > 0.5) {
            ctx.strokeStyle = `rgba(20, 20, 20, 0.5)`;
            ctx.lineWidth = 1;
            
            const crackPoints = 3 + Math.floor(Math.random() * 4);
            ctx.beginPath();
            ctx.moveTo(x, y);
            
            for (let j = 0; j < crackPoints; j++) {
                const angle = Math.random() * Math.PI * 2;
                const length = 5 + Math.random() * 15;
                ctx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
            }
            
            ctx.stroke();
        }
    }
    
    // יצירת טקסטורה מהקנבס
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(4, 4);
    
    return texture;
};
        
        // יצירת קרקע שטוחה בסגנון כביש
// יצירת קרקע שטוחה בסגנון כביש
const createFlatRoadGround = () => {
    const size = 100;
    const geometry = new THREE.PlaneGeometry(size, size);
    
    // יצירת המטריאל עם טקסטורת כביש
    const roadTexture = createRoadTexture();
    
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        map: roadTexture,
        roughness: 0.9,
        metalness: 0.1,
        side: THREE.DoubleSide
    });
    
    ground = new THREE.Mesh(geometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    // הגבהת האדמה ל-8.5
    ground.position.y = 8.5;
    ground.receiveShadow = true;
    scene.add(ground);
    
    return ground;
};
        
        // יצירת קולידרים לקירות המנהרה
        const createTunnelColliders = (startPoint, endPoint, tunnelRadius) => {
    // ניקוי מערך הקולידרים הקיים
    tunnelWalls = [];
    
    // חישוב הכיוון והאורך של המנהרה
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    const tunnelLength = direction.length();
    
    // נרמול הכיוון
    const normalizedDirection = direction.clone().normalize();
    
    // יצירת וקטור ניצב לכיוון המנהרה
    const perpendicular = new THREE.Vector3();
    if (Math.abs(normalizedDirection.y) < 0.99) {
        perpendicular.set(0, 1, 0);
    } else {
        perpendicular.set(1, 0, 0);
    }
    perpendicular.cross(normalizedDirection).normalize();
    
    // מספר הקולידרים סביב היקף המנהרה
    const numColliders = 8;
    
    // יצירת קולידרים סביב היקף המנהרה
    for (let i = 0; i < numColliders; i++) {
        const angle = (i / numColliders) * Math.PI * 2;
        
        // וקטור בכיוון הקולידר הנוכחי
        const ringVector = perpendicular.clone().applyAxisAngle(normalizedDirection, angle);
        
        // נקודות לאורך הקולידר
        const colliderPoints = [];
        
        // מספר הנקודות לאורך המנהרה
        const numPoints = 4;
        
        // יצירת נקודות לאורך המנהרה
        for (let j = 0; j <= numPoints; j++) {
            const t = j / numPoints;
            
            // נקודה על קו המנהרה
            const pointOnLine = new THREE.Vector3().lerpVectors(startPoint, endPoint, t);
            
            // נקודה על קיר המנהרה
            const pointOnWall = pointOnLine.clone().add(
                ringVector.clone().multiplyScalar(tunnelRadius * 0.9) // מעט פנימה מהרדיוס האמיתי
            );
            
            colliderPoints.push(pointOnWall);
        }
        
        // שמירת מידע הקולידר
        tunnelWalls.push({
    points: colliderPoints,
    radius: 0.5 // הגדלה לקולידרים רחבים יותר למנהרה הגדולה
});
    }
};
        
        // בדיקת התנגשות עם קירות המנהרה
        const checkTunnelCollisions = (position) => {
            // רדיוס השחקן
            const playerRadius = 0.5;
            
            for (const wall of tunnelWalls) {
                // בדיקת כל מקטע של הקיר
                for (let i = 0; i < wall.points.length - 1; i++) {
                    const start = wall.points[i];
                    const end = wall.points[i + 1];
                    
                    // חישוב המרחק הקצר ביותר מהשחקן למקטע
                    const closestPoint = new THREE.Vector3();
                    const line = new THREE.Line3(start, end);
                    line.closestPointToPoint(position, true, closestPoint);
                    
                    const distance = position.distanceTo(closestPoint);
                    
                    // אם המרחק קטן מסכום הרדיוסים - יש התנגשות
                    if (distance < playerRadius + wall.radius) {
                        return true;
                    }
                }
            }
            
            return false;
        };
        
        // יצירת צינור/מנהרה שהשחקן יוכל להיכנס אליו
        const createTunnel = () => {
    // נקודות התחלה וסיום המנהרה (נקודות חדשות)
    const startPoint = new THREE.Vector3(-24.63, 12.0, 26.94); // התחלת המנהרה החדשה עם גובה 13
    const endPoint = new THREE.Vector3(33.19, 12.0, -38.43); // סוף המנהרה החדש עם גובה 13
    
    // חישוב הכיוון והאורך של המנהרה
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    const tunnelLength = direction.length();
    
    // רדיוס הצינור - מוגדל ל-8 מטר
    const tunnelRadius = 10; // רדיוס חדש
    // מספר המקטעים לאורך ובהיקף הצינור
    const radialSegments = 16;
    const heightSegments = 30;
// אנימציה של האורות במנהרה לתחושת סיבוב נוספת
if (window.tunnelLights && window.tunnelLights.length > 0) {
    const time = performance.now() * 0.001; // זמן בשניות
    
    for (let i = 0; i < window.tunnelLights.length; i++) {
        const light = window.tunnelLights[i];
        const bulb = window.tunnelBulbs[i];
        const glow = window.tunnelGlows[i];
        
        if (light && light.userData) {
            // אנימציה מעגלית של האור
            const angle = time * 0.5 + light.userData.phase;
            const x = Math.cos(angle) * light.userData.amplitude;
            const z = Math.sin(angle) * light.userData.amplitude;
            
            // תזוזה ביחס למיקום הבסיסי
            const newPosition = light.userData.basePosition.clone();
            newPosition.x += x;
            newPosition.z += z;
            
            // עדכון המיקום של האור והאלמנטים הויזואליים
            light.position.copy(newPosition);
            
            if (bulb) bulb.position.copy(newPosition);
            if (glow) glow.position.copy(newPosition);
            
            // שינוי עוצמת האור באופן מחזורי
            light.intensity = 0.4 + 0.3 * Math.sin(time * 2 + light.userData.phase);
            
            // שינוי גודל הזוהר באופן מחזורי
            if (glow) {
                glow.scale.set(
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase),
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase),
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase)
                );
            }
        }
    }
}
    
    // יצירת גיאומטרית צילינדר פתוח בשני הקצוות
    const geometry = new THREE.CylinderGeometry(
        tunnelRadius, // רדיוס עליון
        tunnelRadius, // רדיוס תחתון
        tunnelLength, // אורך
        radialSegments, // מספר מקטעים בהיקף
        heightSegments, // מספר מקטעים לאורך
        true // פתוח בשני הקצוות
    );
    
    
    // יצירת טקסטורה למנהרה בסגנון רטרו סגלגל
// יצירת טקסטורה למנהרה בסגנון רטרו סגלגל
const createRetroTunnelTexture = () => {
    const textureSize = 1024;
    const canvas = document.createElement('canvas');
    canvas.width = textureSize;
    canvas.height = textureSize;
    const ctx = canvas.getContext('2d');
    
    // צבע רקע סגול כהה
    ctx.fillStyle = '#2a1a3a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // יצירת קווי רשת ניאון בסגנון רטרו
    const gridSpacing = 64; // מרווח גדול יותר בין קווי הרשת
    const gridColor = '#9c3fd4'; // סגול ניאוני יותר
    
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 3;
    
    // ציור קווים אופקיים
    for (let y = 0; y < canvas.height; y += gridSpacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
        
        // הוספת אפקט זוהר לקווים
        ctx.strokeStyle = 'rgba(200, 120, 255, 0.5)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
        
        // חזרה לסגנון המקורי
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 3;
    }
    
    // ציור קווים אנכיים - כדאי שיהיו יותר כדי שיהיה יותר אפקט סיבוב
    for (let x = 0; x < canvas.width; x += gridSpacing) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        
        // הוספת אפקט זוהר לקווים
        ctx.strokeStyle = 'rgba(200, 120, 255, 0.5)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        
        // חזרה לסגנון המקורי
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 3;
    }
    
    // הוספת אלמנטים אלכסוניים לשיפור אפקט הסיבוב
    for (let i = 0; i < 20; i++) {
        const x1 = Math.random() * canvas.width;
        const y1 = 0;
        const x2 = Math.random() * canvas.width;
        const y2 = canvas.height;
        
        ctx.strokeStyle = `rgba(255, 100, 255, 0.3)`;
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    
    // הוספת נקודות זוהרות בסגנון כוכבים
    for (let i = 0; i < 300; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 3 + 1;
        
        // צבע זוהר בגוונים של סגול/ורוד
        const r = 200 + Math.random() * 55;
        const g = 50 + Math.random() * 100;
        const b = 200 + Math.random() * 55;
        
        // יצירת זוהר בגרדיאנט סביב הנקודה
        const glow = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
        glow.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
        glow.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.3)`);
        glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(x, y, size * 3, 0, Math.PI * 2);
        ctx.fill();
        
        // נקודה מרכזית בהירה יותר
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // הוספת אלמנטים גיאומטריים רטרו (משולשים/מרובעים) בגדלים שונים
    for (let i = 0; i < 50; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 30 + 10;
        
        // צבע למלא בגווני סגול/ורוד
        const r = 130 + Math.random() * 50;
        const g = 20 + Math.random() * 40;
        const b = 180 + Math.random() * 70;
        const a = 0.2 + Math.random() * 0.3;
        
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
        
        // בחירה אקראית בין משולש ומרובע
        if (Math.random() > 0.5) {
            // משולש
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2);
            ctx.lineTo(x - size / 2, y + size / 2);
            ctx.lineTo(x + size / 2, y + size / 2);
            ctx.closePath();
            ctx.fill();
            
            // קו תוחם זוהר
            ctx.strokeStyle = `rgba(255, 200, 255, 0.7)`;
            ctx.lineWidth = 2;
            ctx.stroke();
        } else {
            // מרובע מסובב (יהלום)
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2);
            ctx.lineTo(x + size / 2, y);
            ctx.lineTo(x, y + size / 2);
            ctx.lineTo(x - size / 2, y);
            ctx.closePath();
            ctx.fill();
            
            // קו תוחם זוהר
            ctx.strokeStyle = `rgba(255, 200, 255, 0.7)`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
    
    // יצירת טקסטורה מהקנבס
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(5, 10); // הגדלת החזרה לאפקט סיבוב טוב יותר
    
    return texture;
};
    
    // יצירת מרקם מנהרה רטרו
    const tunnelTexture = createRetroTunnelTexture();
    
    // יצירת מטריאל לצינור
    const material = new THREE.MeshStandardMaterial({
        map: tunnelTexture,
        roughness: 0.7,
        metalness: 0.3,
        side: THREE.DoubleSide, 
        emissive: new THREE.Color(0x4d0099), // אפקט פליטה בגוון סגול
        emissiveIntensity: 0.2, // עוצמת הפליטה
        transparent: false
    });
    
    // יצירת המנהרה
    const tunnel = new THREE.Mesh(geometry, material);
    
    // חישוב והגדרת הסיבוב של המנהרה
    // הצילינדר מיוצר לאורך ציר ה-Y, אז אנחנו צריכים לסובב אותו
    // כדי שיהיה בכיוון הנכון
    
    // חישוב הנורמל של הכיוון
    direction.normalize();
    
    // הגדרת וקטור ייחוס - בדרך כלל ציר ה-Y
    const yAxis = new THREE.Vector3(0, 1, 0);
    
    // חישוב הקווטרניון להסתובבות מציר ה-Y לכיוון שלנו
    const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction);
    tunnel.setRotationFromQuaternion(quaternion);
    
    // מיקום המנהרה - באמצע בין נקודת ההתחלה והסיום
    const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
    tunnel.position.copy(midPoint);
    
    // הוספת צללים
    tunnel.castShadow = true;
    tunnel.receiveShadow = true;
    
    // הוספת המנהרה לסצנה
    scene.add(tunnel);
    
    // שמירת המנהרה למשתנה הגלובלי
    tunnelObject = tunnel;
    
    // יצירת קולידרים לקירות המנהרה
    createTunnelColliders(startPoint, endPoint, tunnelRadius);
    
    // הוספת אורות בתוך המנהרה בסגנון רטרו
    addRetroTunnelLights(tunnel, tunnelLength, startPoint, endPoint);
    
    return tunnel;
};
const addRetroTunnelLights = (tunnel, tunnelLength, startPoint, endPoint) => {
    // מספר האורות לאורך המנהרה
    const numLights = 20;
    // חישוב הוקטור בין נקודת ההתחלה לנקודת הסיום
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    // מרחק בין האורות
    const spacing = tunnelLength / numLights;
    
    // צבעים ניאון מתחלפים לסגנון רטרו
    const retroColors = [
        0xff00ff, // מג'נטה
        0x9932CC, // סגול כהה
        0xff1493, // ורוד עמוק
        0x8a2be2, // כחול-סגול
        0x9400d3  // סגול כהה
    ];
    
    // מערך לשמירת כל האורות והנורות לאנימציה
    window.tunnelLights = [];
    window.tunnelBulbs = [];
    window.tunnelGlows = [];
    
    // יצירת אורות לאורך המנהרה
    for (let i = 0; i < numLights; i++) {
        // מיקום האור כנקודה על הקו בין נקודת ההתחלה לנקודת הסיום
        const ratio = (i * spacing) / tunnelLength;
        const lightPosition = new THREE.Vector3()
            .copy(startPoint)
            .lerp(endPoint, ratio);
        
        // הזזת האור לצדדים ולמעלה לאפקט מעניין יותר
        const offset = 6.5;
        const side = i % 2 === 0 ? 1 : -1; // צד ימין או שמאל לסירוגין
        
        // חישוב וקטור ניצב לכיוון המנהרה
        const normalizedDirection = direction.clone().normalize();
        const perpendicular = new THREE.Vector3();
        
        if (Math.abs(normalizedDirection.y) < 0.99) {
            perpendicular.set(0, 1, 0);
        } else {
            perpendicular.set(1, 0, 0);
        }
        perpendicular.cross(normalizedDirection).normalize();
        
        // הזזת האור לצד המתאים של המנהרה ומעט למעלה
        lightPosition.add(perpendicular.clone().multiplyScalar(side * offset * 0.7));
        lightPosition.y += 3 + Math.sin(i) * 1.5;
        
        // אור נקודתי בצבע ניאון
        const colorIndex = i % retroColors.length;
        const light = new THREE.PointLight(retroColors[colorIndex], 0.6, 8);
        light.position.copy(lightPosition);
        scene.add(light);
        window.tunnelLights.push(light);
        
        // שמירת מידע נוסף לאנימציה
        light.userData = {
            basePosition: lightPosition.clone(),
            offset: perpendicular.clone().multiplyScalar(side * offset * 0.7),
            phase: Math.random() * Math.PI * 2, // פאזה אקראית לאנימציה
            amplitude: 0.3 + Math.random() * 0.2 // אמפליטודה אקראית
        };
        
        // גופי תאורה ויזואליים - ספירות קטנות עם אפקט זוהר
        const bulbGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const bulbMaterial = new THREE.MeshBasicMaterial({ 
            color: retroColors[colorIndex],
            transparent: true,
            opacity: 0.9
        });
        const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
        bulb.position.copy(light.position);
        scene.add(bulb);
        window.tunnelBulbs.push(bulb);
        
        // הוספת הילה מסביב לאור
        const glowGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({ 
            color: retroColors[colorIndex],
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.copy(light.position);
        scene.add(glow);
        window.tunnelGlows.push(glow);
    }
    
    // הוספת אור סגול מתפשט באזור הכניסה למנהרה
    const entranceLight = new THREE.PointLight(0x9400d3, 1, 10);
    entranceLight.position.copy(startPoint);
    entranceLight.position.y += 1;
    scene.add(entranceLight);
    
    // הוספת אור סגול מתפשט באזור היציאה מהמנהרה
    const exitLight = new THREE.PointLight(0xff00ff, 1, 10);
    exitLight.position.copy(endPoint);
    exitLight.position.y += 1;
    scene.add(exitLight);
};

        // הוספת אורות לאורך המנהרה
        const addTunnelLights = (tunnel, tunnelLength, startPoint, endPoint) => {
            // מספר האורות לאורך המנהרה
            const numLights = 10;
            // חישוב הוקטור בין נקודת ההתחלה לנקודת הסיום
            const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
            // מרחק בין האורות
            const spacing = tunnelLength / numLights;
            
            // יצירת אורות לאורך המנהרה
            for (let i = 0; i < numLights; i++) {
                // מיקום האור כנקודה על הקו בין נקודת ההתחלה לנקודת הסיום
                const ratio = (i * spacing) / tunnelLength;
                const lightPosition = new THREE.Vector3()
                    .copy(startPoint)
                    .lerp(endPoint, ratio);
                
                // הזזת האור כלפי מעלה במעט כדי שיהיה מעל ראש השחקן
                lightPosition.y += 0.5;
                
                // אור נקודתי
                const light = new THREE.PointLight(0xffffcc, 0.3, 5);
                light.position.copy(lightPosition);
                scene.add(light);
                
                // גופי תאורה ויזואליים - ספירות קטנות
                const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const bulbMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffee,
                    transparent: true,
                    opacity: 0.8
                });
                const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
                bulb.position.copy(light.position);
                scene.add(bulb);
            }
        };
        
        // יצירת מערכת שליטה בגוף ראשון
        const setupFirstPersonControls = () => {
            controls = new THREE.FirstPersonControls(camera, renderer.domElement);
            controls.movementSpeed = 4;
            controls.lookSpeed = 0.03; // הורדת הרגישות מ-0.1 ל-0.05
            controls.lookVertical = true;
            controls.constrainVertical = true;
            controls.verticalMin = Math.PI / 6; // הגבלת מבט למעלה
            controls.verticalMax = Math.PI / 1.8; // הגבלת מבט למטה
            
            // הגדרת אזור מת בקצוות המסך שיעצור את התזוזה
            const boundaryThreshold = 0.05; // 5% מהקצה (95% מהמסך פעיל)
            
            // האזנה לתזוזת העכבר
            document.addEventListener('mousemove', (e) => {
                const mouseX = e.clientX / window.innerWidth;
                const mouseY = e.clientY / window.innerHeight;
                
                // בדיקה אם העכבר נמצא באזור המת (קרוב לקצוות)
                const isNearLeftEdge = mouseX < boundaryThreshold;
                const isNearRightEdge = mouseX > (1 - boundaryThreshold);
                const isNearTopEdge = mouseY < boundaryThreshold;
                const isNearBottomEdge = mouseY > (1 - boundaryThreshold);
                
                // עצירת התזוזה אם העכבר בקצוות
                if (isNearLeftEdge || isNearRightEdge || isNearTopEdge || isNearBottomEdge) {
                    if (controls.activeLook !== false) {
                        controls.activeLook = false;
                    }
                } else {
                    if (controls.activeLook !== true) {
                        controls.activeLook = true;
                    }
                }
            });
        };
        
        // טעינת מודל GLB (רק tunnel.glb)
// טעינת מודל GLB (tunnel.glb)
const loadTunnelModel = () => {
    const loader = new THREE.GLTFLoader();
    
    // הצגת הודעת טעינה
    document.getElementById('loading').style.display = 'block';
    document.getElementById('loading').textContent = 'טוען את המודל...';
    
    loader.load(
        '3d/tunnel.glb',
        (gltf) => {
            const model = gltf.scene;
            
            // הגדרת צללים לכל המשים במודל
            model.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // היפוך הנורמלים אם זה לא מודל שהועלה על-ידי המשתמש
                    if (node.geometry) {
                        node.geometry.scale(-1, 1, 1);
                        node.material.side = THREE.BackSide;
                    }
                }
            });
            
            // הגדלת הסקייל של המודל לכיסוי אזור גדול יותר
            model.scale.set(15, 10, 15); // הגדלת רוחב ואורך המודל (ערך X ו-Z) מ-10 ל-15
            
            // מיקום המודל - הזזנו קדימה כדי לכסות את האזור החדש
            model.position.set(2, 14, -2); // שינוי מיקום המודל להתאים לאזור הגדול יותר
            
            // שמירת המודל למשתנה הגלובלי
            worldModel = model;
            
            scene.add(model);
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;

            // הפעלת המוזיקה כשהמודל נטען
            if (window.tunnelBackgroundMusic && !window.tunnelBackgroundMusic.playing()) {
                window.tunnelBackgroundMusic.play();
                console.log('מוזיקת רקע הופעלה');
            }
        },
        (xhr) => {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            document.getElementById('loading').textContent = 
                `טוען את המודל... ${Math.round(percentComplete)}%`;
        },
        (error) => {
            console.error('שגיאה בטעינת המודל:', error);
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;
        }
    );
};
        
// חזרה לעולם
// חזרה לעולם
document.getElementById('back-button').addEventListener('click', () => {
    document.getElementById('next-screen').style.display = 'none';
    
    // איפוס מצב התנועה
    movingForward = false;
    movingBackward = false;
    if (controls) {
        controls.moveForward = false;
        controls.moveBackward = false;
    }
    
    controls.enabled = true; // הפעלת השליטה מחדש
    
    // וודא שהמוזיקה מתנגנת כשחוזרים לעולם
    if (window.tunnelBackgroundMusic && !window.tunnelBackgroundMusic.playing()) {
        window.tunnelBackgroundMusic.play();
    }
});
        // התאמת גודל החלון
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (controls) {
                controls.handleResize();
            }
        });
        
        // הגדרת סאונד להליכה
        const setupWalkSound = () => {
    // יצירת אובייקט סאונד להליכה עם האופציה להפעלה חוזרת (loop)
    walkSound = new Howl({
        src: ['audio/walk.mp3'],
        loop: true,
        volume: 0.7
    });
            // הגדרת מערכת השמעת מוזיקת רקע רנדומלית למנהרה

            
            // הוספת מאזין לאירוע לחיצה על כפתור העכבר
            document.addEventListener('mousedown', (e) => {
                // בדיקה אם לחץ כפתור שמאלי (0) או ימני (2)
                if ((e.button === 0 || e.button === 2) && !isWalking) {
                    walkSound.play();
                    isWalking = true;
                }
            });
            
            // הוספת מאזין לאירוע שחרור כפתור העכבר
            document.addEventListener('mouseup', (e) => {
                // בדיקה אם שוחרר כפתור שמאלי (0) או ימני (2)
                if ((e.button === 0 || e.button === 2) && isWalking) {
                    walkSound.pause();
                    isWalking = false;
                }
            });
            
            // מניעת תפריט קליק ימני
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        };
        
        // אתחול הסצנה
// אתחול הסצנה
// פונקציה להצגת מודל הסרטון
// פונקציה להצגת מודל הסרטון
// פונקציה להצגת מודל הסרטון
const setupVideoModal = () => {
    const videoModal = document.getElementById('video-modal');
    const introVideo = document.getElementById('intro-video');
    const missionPopup = document.getElementById('mission-popup');
    
    // הצגת המודל אחרי 3 שניות
    setTimeout(() => {
        videoModal.style.display = 'block';
        
        // עצירת התנועה והצליל
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
        
        // השבת שליטה בזמן הצגת הסרטון
        if (controls) {
            controls.enabled = false;
        }
        
        // וידוא שהמוזיקה לא מתנגנת במהלך הסרטון
        if (window.tunnelBackgroundMusic && window.tunnelBackgroundMusic.playing()) {
            window.tunnelBackgroundMusic.pause();
        }
        
        // הפעלת הסרטון אוטומטית
        introVideo.play();
        
        // הוספת מאזין לסיום הסרטון
        introVideo.addEventListener('ended', () => {
            // סגירת מודל הסרטון
            videoModal.style.display = 'none';
            
            // החזרת השליטה למשתמש
            if (controls) {
                controls.enabled = true;
            }
            
            // הפעלת מוזיקת הרקע לאחר סיום הסרטון
            if (window.tunnelBackgroundMusic && !window.tunnelBackgroundMusic.playing()) {
                window.tunnelBackgroundMusic.play();
                console.log('מוזיקת רקע הופעלה לאחר סיום הסרטון');
                
                // עדכון כפתור המוזיקה אם קיים
                const musicToggleBtn = document.getElementById('music-toggle');
                if (musicToggleBtn) {
                    musicToggleBtn.textContent = '🔊';
                }
            }
            
            // הצגת המשימה אחרי סיום הסרטון
            if (missionPopup) {
                setTimeout(() => {
                    console.log("Showing mission popup after video");
                    missionPopup.style.opacity = '1';
                    missionPopup.style.transition = 'opacity 1.5s ease-out';
                }, 1000); // הצגה אחרי שניה נוספת
            }
        });
        
        // אם יש כפתור סגירה, הוסף האזנה גם לו
        const closeBtn = document.querySelector('.close-modal');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                videoModal.style.display = 'none';
                introVideo.pause();
                
                // החזרת השליטה
                if (controls) {
                    controls.enabled = true;
                }
                
                // הפעלת המוזיקה אחרי סגירת המודל ידנית
                if (window.tunnelBackgroundMusic && !window.tunnelBackgroundMusic.playing()) {
                    window.tunnelBackgroundMusic.play();
                    console.log('מוזיקת רקע הופעלה לאחר סגירת המודל');
                    
                    // עדכון כפתור המוזיקה אם קיים
                    const musicToggleBtn = document.getElementById('music-toggle');
                    if (musicToggleBtn) {
                        musicToggleBtn.textContent = '🔊';
                    }
                }
                
                // הצגת המשימה גם אחרי סגירה ידנית
                if (missionPopup) {
                    setTimeout(() => {
                        console.log("Showing mission popup after manual close");
                        missionPopup.style.opacity = '1';
                        missionPopup.style.transition = 'opacity 1.5s ease-out';
                    }, 1000); // הצגה אחרי שניה נוספת
                }
            });
        }
    }, 3000); // 3 שניות
};
// הוספת אפקט הופעה לחלונית המשימה
const setupMissionPopup = () => {
    const missionPopup = document.getElementById('mission-popup');
    console.log("Setting up mission popup:", missionPopup);
    
    // מחביאים את החלונית בהתחלה
    if (missionPopup) {
        // הגדרת המשתנה להיות מוחבא בהתחלה
        missionPopup.style.opacity = '0';
        
        // מציגים את החלונית אחרי סיום הסרטון
        // נשתמש במשתנה גלובלי כדי לדעת מתי הסרטון הסתיים
        window.showMissionAfterVideo = true;
    } else {
        console.error("Mission popup element not found!");
    }
};
const init = () => {
    // הגדרת תאורה
    setupLighting();
    camera.lookAt(specialPortalPoint);
    // יצירת קרקע שטוחה בסגנון כביש
    createFlatRoadGround();
    
    // יצירת הצינור/מנהרה
    createTunnel();
    
    // יצירת שלטי משחקים
    createGameSigns();
    
    // הגדרת שליטה בגוף ראשון
    setupFirstPersonControls();
    
    // הגדרת סאונד להליכה
    setupWalkSound();
    
    // הגדרת בקרות תנועה - הוספנו פה
    setupMovementControls();
    
    // הגדרת מוזיקת רקע למנהרה
    setupTunnelBackgroundMusic();
    
    // יצירת אפקט פורטל עם עשן סגול
    createPortalEffect();
    
    
    // מיקום השחקן בנקודת ההתחלה החדשה
    camera.position.set(-31.42, 10.20, 32.99); // מיקום התחלתי חדש לשחקן    
    
    // טעינת מודל GLB של המנהרה בלבד
    loadTunnelModel();
    
    // טעינת הפונט ואז יצירת מספרי השנים
    loadFont().then(() => {
        createYearNumbers();
    }).catch(error => {
        console.error('שגיאה ביצירת מספרי השנים:', error);
    });
    
    // הגדרת חלונית המשימה
    setupMissionPopup();
    
    // הפעלת מודל הסרטון (קורא לפונקציה שהוספנו)
    setupVideoModal();
    
    // טיימר לטעינה
    setTimeout(() => {
        if (document.getElementById('loading').style.display !== 'none') {
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;
        }
    }, 5000);
    
    // התחלת לולאת האנימציה
    animate();
};
        
        // פונקציית אנימציה
// פונקציית אנימציה
const animate = () => {
    requestAnimationFrame(animate);
    
    if (isLoaded) {
        const delta = clock.getDelta();
        
        // סיבוב טקסטורת המנהרה
        if (tunnelTexture) {
            // הזזת הטקסטורה בציר האופקי (סיבוב)
            tunnelTexture.offset.x += 0.002; // ערך קטן עבור סיבוב איטי
            
            // הזזת הטקסטורה גם בציר האנכי לאפקט תלת-ממדי
            tunnelTexture.offset.y += 0.001; // ערך קטן אף יותר
        }
        
        if (controls) {
            // שמירת המיקום הקודם לפני העדכון
            const previousPosition = camera.position.clone();
            
            // עדכון השליטה
            controls.update(delta);
            
            // בדיקת התנגשות עם קירות המנהרה
            if (checkTunnelCollisions(camera.position)) {
                // אם יש התנגשות, חזרה למיקום הקודם
                camera.position.copy(previousPosition);
            }
            
            // שמירת גובה קבוע מעל הרצפה (רצפה שטוחה)
            camera.position.y = PLAYER_HEIGHT;
            
            // הדפסת המיקום הנוכחי של השחקן לקונסול ולמסך בכל פריים
            const positionInfo = `מיקום שחקן: X: ${camera.position.x.toFixed(2)}, Y: ${camera.position.y.toFixed(2)}, Z: ${camera.position.z.toFixed(2)}`;
            console.log(positionInfo);
            
            // הצגת המיקום על המסך
            if (!window.positionDisplay) {
                window.positionDisplay = document.createElement('div');
                window.positionDisplay.style.position = 'absolute';
                window.positionDisplay.style.bottom = '10px';
                window.positionDisplay.style.left = '10px';
                window.positionDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                window.positionDisplay.style.color = 'white';
                window.positionDisplay.style.padding = '5px';
                window.positionDisplay.style.fontFamily = 'monospace';
                window.positionDisplay.style.fontSize = '14px';
                window.positionDisplay.style.borderRadius = '3px';
                window.positionDisplay.style.zIndex = '1000';
                document.body.appendChild(window.positionDisplay);
            }
            window.positionDisplay.textContent = positionInfo;
            
            // בדיקת אם הגענו לנקודת הפורטל
            checkCustomLocationPoints(camera.position);
        }
        
        // אנימציה לפורטל עם עשן סגול
        // בתוך פונקציית animate(), במקום שבו אתה מעדכן אובייקטים אחרים:
animatePortal();
animateYearNumbers();
animateGameSigns(); // הוסף את זה
        
    }
    // אנימציה של האורות במנהרה לתחושת סיבוב נוספת
if (window.tunnelLights && window.tunnelLights.length > 0) {
    const time = performance.now() * 0.001; // זמן בשניות
    
    for (let i = 0; i < window.tunnelLights.length; i++) {
        const light = window.tunnelLights[i];
        const bulb = window.tunnelBulbs[i];
        const glow = window.tunnelGlows[i];
        
        if (light && light.userData) {
            // אנימציה מעגלית של האור
            const angle = time * 0.5 + light.userData.phase;
            const x = Math.cos(angle) * light.userData.amplitude;
            const z = Math.sin(angle) * light.userData.amplitude;
            
            // תזוזה ביחס למיקום הבסיסי
            const newPosition = light.userData.basePosition.clone();
            newPosition.x += x;
            newPosition.z += z;
            
            // עדכון המיקום של האור והאלמנטים הויזואליים
            light.position.copy(newPosition);
            
            if (bulb) bulb.position.copy(newPosition);
            if (glow) glow.position.copy(newPosition);
            
            // שינוי עוצמת האור באופן מחזורי
            light.intensity = 0.4 + 0.3 * Math.sin(time * 2 + light.userData.phase);
            
            // שינוי גודל הזוהר באופן מחזורי
            if (glow) {
                glow.scale.set(
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase),
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase),
                    1 + 0.2 * Math.sin(time * 3 + light.userData.phase)
                );
            }
        }
    }
}
    renderer.render(scene, camera);
};
        
        // הפעלת האתחול כשהדף נטען
        window.addEventListener('load', init);
        // טעינת פונט לטקסט התלת-מימדי
const loadFont = () => {
    const fontLoader = new THREE.FontLoader();
    return new Promise((resolve, reject) => {
        fontLoader.load(
            'https://cdn.jsdelivr.net/npm/three@0.134.0/examples/fonts/helvetiker_bold.typeface.json',
            (font) => {
                window.yearFont = font;
                resolve(font);
            },
            undefined,
            (error) => {
                console.error('שגיאה בטעינת הפונט:', error);
                reject(error);
            }
        );
    });
};

// יצירת מספרי שנים בתקרת המנהרה
// יצירת מספרי שנים בתקרת המנהרה - תיקון כיוון הראייה וסיבוב הטקסט
// יצירת מספרי שנים בתקרת המנהרה עם מיקום רנדומלי
const createYearNumbers = () => {
    // מערך השנים - מהשנה הנוכחית אחורה
    const years = [];
    for (let year = 2025; year >= 1980; year--) {
        years.push(year);
    }
    
    // נקודות התחלה וסיום המנהרה
    const startPoint = new THREE.Vector3(-24.63, 12.0, 26.94);
    const endPoint = new THREE.Vector3(33.19, 12.0, -38.43);
    
    // אורך המנהרה
    const tunnelLength = startPoint.distanceTo(endPoint);
    
    // מרחק בין כל שנה
    const spaceBetweenYears = tunnelLength / (years.length - 1);
    
    // כיוון המנהרה
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
    
    // חישוב וקטור ניצב לכיוון המנהרה (לצורך הזזה צדדית)
    const perpendicular = new THREE.Vector3();
    if (Math.abs(direction.y) < 0.99) {
        perpendicular.set(0, 1, 0);
    } else {
        perpendicular.set(1, 0, 0);
    }
    perpendicular.cross(direction).normalize();
    
    // מערך לשמירת האובייקטים
    window.yearObjects = [];
    
    // יצירת כל מספרי השנים
    years.forEach((year, index) => {
        // יצירת גיאומטריה לטקסט
        const textGeometry = new THREE.TextGeometry(year.toString(), {
    font: window.yearFont,
    size: 0.6, // במקום 0.4
    height: 0.1, // במקום 0.05
    curveSegments: 5,
    bevelEnabled: false
});
        
        // חומר זוהר לטקסט
        const textMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x00ffff,
            emissive: 0x00ccff,
            emissiveIntensity: 1,
            metalness: 0.8,
            roughness: 0.2
        });
        
        // יצירת אובייקט טקסט
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        
        // חישוב המיקום הנוכחי לאורך המנהרה
        const distanceFromStart = index * spaceBetweenYears;
        const currentPosition = new THREE.Vector3().copy(startPoint).addScaledVector(direction, distanceFromStart);
        
        // הוספת גובה רנדומלי בין 2 ל-5 יחידות מעל רצפת המנהרה
        const randomHeight = 2 + Math.random() * 1; // ערכים בין 2 ל-5
        currentPosition.y += randomHeight;
        
        // הוספת הזזה צדדית רנדומלית
        const randomSideOffset = (Math.random() * 9) - 3; // ערכים בין -3 ל+3
        currentPosition.add(perpendicular.clone().multiplyScalar(randomSideOffset));
        
        // מיקום הטקסט
        textMesh.position.copy(currentPosition);
        
        // סיבוב הטקסט כדי שיהיה מקביל לכיוון המנהרה
        textMesh.lookAt(new THREE.Vector3().copy(currentPosition).addScaledVector(direction, -1));
        
        // הוספת סיבוב ניסיוני כדי שהטקסט יהיה קריא
        textMesh.rotation.y = 150;
        
        // ניסוי נוסף לתיקון כיוון הטקסט
        // הוספת סיבוב רנדומלי קטן
        const randomRotation = (Math.random() * 0.3) - 0.15; // רוטציה קטנה לגיוון נוסף
        textMesh.rotation.z += randomRotation;
        
        // מרכוז הטקסט
        textGeometry.computeBoundingBox();
        const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
        textMesh.position.x -= textWidth / 2;
        
        // הוספת אפקט זוהר מסביב לטקסט
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        
        const glowMesh = new THREE.Mesh(textGeometry, glowMaterial);
        glowMesh.position.copy(textMesh.position);
        glowMesh.rotation.copy(textMesh.rotation);
        glowMesh.scale.multiplyScalar(1.2);
        
        // הוספה לסצנה
        scene.add(textMesh);
        scene.add(glowMesh);
        
        // שמירת האובייקטים לאנימציה בהמשך
        window.yearObjects.push({
            text: textMesh,
            glow: glowMesh,
            year: year,
            basePosition: currentPosition.clone()
        });
    });
};

// אנימציית השנים
const animateYearNumbers = () => {
    if (!window.yearObjects) return;
    
    const time = performance.now() * 0.001;
    
    window.yearObjects.forEach((yearObj, index) => {
        if (yearObj.text && yearObj.glow) {
            // אפקט ריחוף למעלה ולמטה
            const floatY = Math.sin(time + index * 0.2) * 0.2;
            
            // עדכון מיקום
            yearObj.text.position.y = yearObj.basePosition.y + floatY;
            yearObj.glow.position.y = yearObj.basePosition.y + floatY;
            
            // אפקט זוהר משתנה
            const glowFactor = 0.7 + 0.3 * Math.sin(time * 2 + index * 0.5);
            yearObj.glow.scale.set(1.1 + glowFactor * 0.1, 1.1 + glowFactor * 0.1, 1.1);
            
            // אפקט צבע משתנה - ככל שמתקדמים בזמן הצבע משתנה
            // מתכלת (2025) לסגול/ורוד (1980)
            if (yearObj.text.material) {
                // חישוב הגוון לפי מיקום השנה במערך
                // 0 = השנה העכשווית, 1 = השנה הכי ישנה
                const normalizedIndex = index / (window.yearObjects.length - 1);
                
                // מעבר הדרגתי מצבע תכלת (0x00ffff) לסגול/ורוד (0xff00ff)
                const r = Math.floor(normalizedIndex * 255);
                const g = Math.floor((1 - normalizedIndex) * 255);
                const b = 255;
                
                // עדכון צבע הטקסט והזוהר
                yearObj.text.material.color.setRGB(r/255, g/255, b/255);
                yearObj.text.material.emissive.setRGB(r/255, g/255, b/255);
                yearObj.glow.material.color.setRGB(r/255, g/255, b/255);
            }
        }
    });
};
// יצירת שלטי משחקים על רצפת המנהרה
// יצירת שלטי עמוד למשחקים במנהרה - דומים לתמונה שצורפה
const createGameSigns = () => {
    // מערך השנים - מהשנה הנוכחית אחורה
    const years = [];
    for (let year = 2025; year >= 1980; year -= 5) {
        years.push(year);
    }
    
    // נקודות התחלה וסיום המנהרה
    const startPoint = new THREE.Vector3(-24.63, 12.0, 26.94);
    const endPoint = new THREE.Vector3(33.19, 12.0, -38.43);
    
    // אורך המנהרה
    const tunnelLength = startPoint.distanceTo(endPoint);
    
    // מרחק בין כל שלט
    const spaceBetweenSigns = tunnelLength / (years.length - 1);
    
    // כיוון המנהרה
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
    
    // חישוב וקטור ניצב לכיוון המנהרה (לצורך הזזה צדדית)
    const perpendicular = new THREE.Vector3();
    if (Math.abs(direction.y) < 0.99) {
        perpendicular.set(0, 1, 0);
    } else {
        perpendicular.set(1, 0, 0);
    }
    perpendicular.cross(direction).normalize();
    
    // מערך לשמירת האובייקטים
    window.gameSigns = [];
    
    // טעינת הטקסטורות מראש כדי למנוע עיכובים
    const textureLoader = new THREE.TextureLoader();
    const textures = {};
    
    // יצירת הבטחות לטעינת כל הטקסטורות
    const texturePromises = years.map(year => {
        return new Promise((resolve, reject) => {
            const url = `signs/${year}.jpg`;
            textureLoader.load(
                url,
                texture => {
                    textures[year] = texture;
                    resolve();
                },
                undefined,
                error => {
                    console.error(`שגיאה בטעינת תמונה לשנת ${year}:`, error);
                    // אם יש שגיאה, ניצור טקסטורה חלופית עם השנה
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.font = 'bold 48px Arial';
                    ctx.fillStyle = '#333333';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(year.toString(), canvas.width / 2, canvas.height / 2);
                    
                    // הוספת כותרת מיני
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('משחקי וידאו', canvas.width / 2, canvas.height / 4);
                    
                    textures[year] = new THREE.CanvasTexture(canvas);
                    resolve();
                }
            );
        });
    });
    
    // המתנה לטעינת כל הטקסטורות לפני יצירת השלטים
    Promise.all(texturePromises).then(() => {
        // יצירת כל השלטים
        years.forEach((year, index) => {
            // חישוב המיקום לאורך המנהרה
            const distanceFromStart = index * spaceBetweenSigns;
            const currentPosition = new THREE.Vector3().copy(startPoint).addScaledVector(direction, distanceFromStart);
            
            // מיקום העמוד על הרצפה
            const basePosition = currentPosition.clone();
            basePosition.y = 8.5; // על הרצפה
            
            // הוספת הזזה צדדית קלה
            // החלפה בין צד שמאל וימין בהתאם לאינדקס
            const sideOffset = (index % 2 === 0) ? 4 : -4;
            basePosition.add(perpendicular.clone().multiplyScalar(sideOffset));
            
            // ===== יצירת העמוד =====
            // 1. בסיס עגול
            const baseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 0.1, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0xCCCCCC,
                metalness: 0.8,
                roughness: 0.2
            });
            const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
            baseMesh.position.copy(basePosition);
            baseMesh.position.y += 0.05; // חצי גובה הבסיס
            
            // 2. העמוד עצמו
            const poleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0xCCCCCC,
                metalness: 0.8,
                roughness: 0.2
            });
            const poleMesh = new THREE.Mesh(poleGeometry, poleMaterial);
            poleMesh.position.copy(basePosition);
            poleMesh.position.y += 1; // חצי גובה העמוד + גובה הבסיס
            
            // 3. חיבור מיוחד בין העמוד לשלט
            const connectorGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.3, 8);
            const connectorMaterial = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA,
                metalness: 0.7,
                roughness: 0.3
            });
            const connectorMesh = new THREE.Mesh(connectorGeometry, connectorMaterial);
            connectorMesh.position.copy(basePosition);
            connectorMesh.position.y += 2.1; // בראש העמוד
            connectorMesh.rotation.x = Math.PI / 2; // סיבוב לכיוון אופקי
            
            // ===== יצירת השלט =====
            // מסגרת השלט
            const frameGeometry = new THREE.BoxGeometry(2.5, 3.5, 0.1);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                metalness: 0.3,
                roughness: 0.7
            });
            const frameMesh = new THREE.Mesh(frameGeometry, frameMaterial);
            frameMesh.position.copy(basePosition);
            frameMesh.position.y += 4; // מיקום השלט מעל העמוד
            
            // הוספת טקסטורה לשלט
            const signGeometry = new THREE.PlaneGeometry(2.3, 3.3);
// היפוך קואורדינטות ה-UV כדי לתקן את אפקט המראה
const uvs = signGeometry.attributes.uv.array;
for (let i = 0; i < uvs.length; i += 2) {
    uvs[i] = 1 - uvs[i]; // היפוך קואורדינטת ה-x של ה-UV
}
            const signMaterial = new THREE.MeshStandardMaterial({
                map: textures[year],
                roughness: 0.4,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            const signMesh = new THREE.Mesh(signGeometry, signMaterial);
            signMesh.position.copy(frameMesh.position);
            signMesh.position.z += 0.1; // מעט קדימה מהמסגרת
            
            // סיבוב השלט כך שיפנה לכיוון הכללי של המנהרה
            // נרצה שהשלט יפנה לכיוון הכללי של המנהרה ולא ישירות למרכז
            // הגדרת זווית קבועה לכל השלטים, דומה לשלט של 1995
// נשתמש ברוטציה קבועה במקום lookAt
const fixedRotation = new THREE.Euler(0, Math.PI * 0.75, 0); // זווית קבועה (בערך 135 מעלות)
frameMesh.setRotationFromEuler(fixedRotation);
signMesh.setRotationFromEuler(fixedRotation);
connectorMesh.rotation.x = Math.PI / 2; // משאירים את הסיבוב האופקי של המחבר
connectorMesh.rotation.y = fixedRotation.y; // מתאימים את הסיבוב האופקי לזווית הקבועה
            
            // הוספת תאורה מיוחדת לשלט
            const spotLight = new THREE.SpotLight(0xffffff, 0.8);
            spotLight.position.copy(frameMesh.position);
            spotLight.position.y += 1; // מיקום האור מעל השלט
            spotLight.position.z += 0.5; // קצת קדימה
            spotLight.target = signMesh;
            spotLight.angle = Math.PI / 6; // רוחב האלומה
            spotLight.penumbra = 0.2; // רכות בקצוות האור
            spotLight.distance = 5; // מרחק האור
            spotLight.castShadow = true;
            
            // שיפור איכות הצללים
            spotLight.shadow.mapSize.width = 512;
            spotLight.shadow.mapSize.height = 512;
            spotLight.shadow.camera.near = 0.5;
            spotLight.shadow.camera.far = 5;
            
            // קבוצה לכל חלקי השלט
            const signGroup = new THREE.Group();
            signGroup.add(baseMesh);
            signGroup.add(poleMesh);
            signGroup.add(connectorMesh);
            signGroup.add(frameMesh);
            signGroup.add(signMesh);
            
            // הוספה לסצנה
            scene.add(signGroup);
            scene.add(spotLight);
            
            // שמירת האובייקטים
            window.gameSigns.push({
                group: signGroup,
                sign: signMesh,
                frame: frameMesh,
                light: spotLight,
                year: year,
                basePosition: basePosition.clone()
            });
            
            // הוספת הטקסט של השנה מתחת לשלט
            // יצירת גיאומטריה לטקסט
            if (window.yearFont) {
                const textGeometry = new THREE.TextGeometry(year.toString(), {
    font: window.yearFont,
    size: 0.6, // במקום 0.4
    height: 0.1, // במקום 0.05
    curveSegments: 5,
    bevelEnabled: false
});
                
                // חומר לטקסט
                //
                /*
                const textMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    emissive: 0x222222,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                
                // יצירת אובייקט טקסט
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                
                // מיקום הטקסט מתחת לשלט
                textMesh.position.copy(frameMesh.position);
                textMesh.position.y -= 0.5; // מתחת לשלט
                
                // סיבוב הטקסט כמו השלט
                textMesh.rotation.copy(frameMesh.rotation);
                
                // מרכוז הטקסט
                textGeometry.computeBoundingBox();
                const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                textMesh.position.x -= textWidth / 2;
                textMesh.position.z += 0.2;
                // הוספה לסצנה ולקבוצה
                signGroup.add(textMesh);
                */
            }
        });
    });
};

// אנימציית השלטים
const animateGameSigns = () => {
    if (!window.gameSigns) return;
    
    const time = performance.now() * 0.001;
    
    window.gameSigns.forEach((signObj, index) => {
        if (signObj.group && signObj.light) {
            // אפקט נענוע קל של השלט
            const swayAngle = Math.sin(time * 0.5 + index * 0.2) * 0.01;
            
            // עדכון רוטציה של הקבוצה
            //signObj.group.rotation.y = signObj.group.rotation.y * 0.95 + swayAngle * 0.05;
            
            // שינוי עוצמת האור באופן מחזורי
            signObj.light.intensity = 0.6 + 0.4 * Math.sin(time * 0.7 + index * 0.3);
        }
    });
};
    </script>
</body>
</html>