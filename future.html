<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×¢×•×œ× ×ª×œ×ª ××™××“×™ ×¢× Three.js</title>
    <!-- ×˜×¢×™× ×ª ×¡×¤×¨×™×•×ª Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/FirstPersonControls.js"></script>
    <!-- ×˜×¢×™× ×ª ×¡×¤×¨×™×™×ª Audio -->
    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: default;
        }
        
        #scene-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        
        #controls-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        
        #next-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        
        #back-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 100;
        }
        .modal {
  display: none;
  position: fixed;
  z-index: 1001;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  overflow: hidden;
}

.modal-content {
  position: relative;
  background-color: #ffffff;
  margin:  auto;
  width: 80%;
  height: 95%; /* ×©×•× ×” ×-80% ×œ-95% */
  border-radius: 10px;
  box-shadow: 0 0 20px rgba(128, 0, 255, 0.7);
}

.close-btn {
  position: absolute;
  top: 10px;
  right: 15px;
  color: #333;
  font-size: 28px;
  font-weight: bold;
  background-color: white;
  width: 30px;
  height: 30px;
  line-height: 30px;
  text-align: center;
  border-radius: 50%;
  cursor: pointer;
  z-index: 1002;
  transition: all 0.3s;
}

.close-btn:hover {
  color: #FF00FF;
  transform: scale(1.1);
}

#computer-iframe {
  width: 100%;
  height: 100%;
  border: none;
  border-radius: 10px;
}

#interaction-hint {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
  z-index: 50;
  font-size: 16px;
  text-align: center;
  pointer-events: none;
}
    </style>
</head>
<body>
    <!-- Modal for video -->
<div id="video-modal" style="
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
z-index: 1000;
font-family: 'Varela Round', Arial, sans-serif;
">
<div style="
    position: relative;
    background-color: #000;
    margin: 5% auto;
    width: 90%;
    max-width: 800px;
    border-radius: 25px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    animation: modalPopIn 0.7s;
    direction: rtl;
    border: 8px solid #FF5722;
">
    <div style="
        background: linear-gradient(to left, #FF5722, #FF8A65);
        color: white;
        padding: 20px;
        border-radius: 17px 17px 0 0;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
    ">
        <div style="position: relative; display: inline-block;">
            <h2 style="margin: 0; font-size: 32px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); font-weight: bold;">×‘×¨×•×›×™× ×”×©×‘×™× ×œ×”×•×•×”!</h2>
        </div>
        <span id="close-video-modal" style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); color: white; font-size: 36px; font-weight: bold; cursor: pointer;">âœ–ï¸</span>
    </div>
    <div style="padding: 0; background-color: black; border-radius: 0 0 17px 17px;">
        <video id="intro-video" width="100%" controls style="display: block; border-radius: 0 0 17px 17px;">
            <source src="vid/6.mp4" type="video/mp4">
            ×”×“×¤×“×¤×Ÿ ×©×œ×š ×œ× ×ª×•××š ×‘×ª×’×™×ª ×•×™×“××•.
        </video>
    </div>
</div>
</div>

<style>
@keyframes modalPopIn {
0% { transform: scale(0.5); opacity: 0; }
50% { transform: scale(1.05); opacity: 0.8; }
100% { transform: scale(1); opacity: 1; }
}
</style>
<!-- Mission popup -->
<div id="mission-popup" style="
    opacity: 0;
    position: fixed;
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 999;
    width: auto;
    max-width: 90%;
    animation: float 3s ease-in-out infinite;
">
    <div style="
        background: linear-gradient(135deg, rgba(230, 250, 240, 0.9), rgba(210, 240, 255, 0.95));
        border: 3px solid #FF5722;
        border-radius: 15px;
        padding: -10px;
        box-shadow: 0 0 15px rgba(255, 87, 34, 0.6), 0 0 30px rgba(0, 0, 0, 0.3);
    ">
        <div style="
            background: rgba(255, 255, 255, 0.85);
            border-radius: 12px;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            position: relative;
            z-index: 1;
        ">
            <div style="
                font-size: 28px;
                margin-left: 15px;
                color: #FF5722;
                text-shadow: 0 0 10px rgba(255, 87, 34, 0.7);
            ">ğŸ®</div>
<div style="text-align: right;">
    <div style="
        color: #FF5722;
        font-size: 30px;
        font-weight: bold;
        text-shadow: 0 0 4px rgba(255, 255, 255, 0.9);
        letter-spacing: 1px;
        padding: 5px 0;
    ">×—×¤×©×• ××ª ×”××—×©×‘ ×’×™×™××™× ×’</div>
</div>
        </div>
    </div>
</div>

<style>
@keyframes float {
    0% { transform: translate(-50%, 0px); }
    50% { transform: translate(-50%, -10px); }
    100% { transform: translate(-50%, 0px); }
}
</style>
    <div id="scene-container"></div>
    
    <div id="loading">×˜×•×¢×Ÿ ××ª ×”×¢×•×œ×...</div>
    
    <div id="controls-info">
        <p>×ª× ×•×¢×” ×§×“×™××”: ×”×§×©×” ×¢×œ ×§×œ×™×§ ×©×××œ×™ ×‘×¢×›×‘×¨</p>
        <p>×ª× ×•×¢×” ××—×•×¨×”: ×”×§×©×” ×¢×œ ×§×œ×™×§ ×™×× ×™ ×‘×¢×›×‘×¨</p>
        <p>××‘×˜: ×”×–×™×–×• ××ª ×”×¢×›×‘×¨</p>
    </div>
    
    <div id="crosshair">+</div>
    
    <div id="next-screen">
        <h1>×”×’×¢×ª ×œ×™×¢×“!</h1>
        <p>×–×”×• ×”××¡×š ×”×‘×.</p>
        <button id="back-button">×—×–×¨×” ×œ×¢×•×œ×</button>
    </div>
    <div id="computer-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <iframe id="computer-iframe" src="" frameborder="0"></iframe>
        </div>
    </div>
    <script>
        
        // ×™×¦×™×¨×ª ×¡×¦× ×”, ××¦×œ××” ×•×¨× ×“×¨×¨
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(1.12, 1.60, 7.13); // ××™×§×•× ×”×ª×—×œ×ª×™ ×¢×“×›× ×™
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ×¦×œ×œ×™× ×¨×›×™× ×™×•×ª×¨
        
        // ×”×’×“×¨×ª ×¦×‘×¢ ×¨×§×¢ ×©××™×™× ×›×—×•×œ
        renderer.setClearColor(0x6495ED);
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // ××©×ª× ×™× ×’×œ×•×‘×œ×™×™×
        let controls;
        let worldModel;
        let isLoaded = false;
        let clock = new THREE.Clock();
        let ground; // ××©×ª× ×” ×œ×©××™×¨×ª ×”×¨×¦×¤×”
        let tunnelObject; // ××©×ª× ×” ×œ×©××™×¨×ª ×”×× ×”×¨×”
        let tunnelWalls = []; // ××¢×¨×š ×œ×©××™×¨×ª ×§×•×œ×™×“×¨×™× ×©×œ ×§×™×¨×•×ª ×”×× ×”×¨×”
        let yossiModel;
let jordanModel;
let omerModel;
        // ××©×ª× ×™× ×œ××•×“×™×•
        let walkSound;
        let isWalking = false;
        const PLAYER_HEIGHT = 1.6;
        // × ×§×•×“×ª ×”××¢×‘×¨ ×”××™×•×—×“×ª ×œ××¡×š ×”×‘×
        const specialPortalPoint = new THREE.Vector3(33.42, PLAYER_HEIGHT, -23.09); // ×¢×“×›×•×Ÿ ×’×•×‘×” ×”×¤×•×¨×˜×œ
        const portalRadius = 12; // ×¨×“×™×•×¡ ×’×“×•×œ ×™×•×ª×¨ ×œ××–×•×¨ ×”×¤×•×¨×˜×œ
        let portalParticles; // ××©×ª× ×” ×œ×©××™×¨×ª ××¢×¨×›×ª ×”×—×œ×§×™×§×™× ×©×œ ×”×¤×•×¨×˜×œ
        // ××©×ª× ×” ×’×œ×•×‘×œ×™ ×œ×©×œ×™×˜×” ×‘××•×“×œ
let isComputerModalCooldown = false;
let computerCheckTimer = null;
// ××©×ª× ×” ×’×œ×•×‘×œ×™ ×œ×‘×§×¨×ª ×”××•×“××œ ×”×—×“×©
let isNewPcModalCooldown = false;
let newPcCheckTimer = null;
let newPcModel; // ×œ×©××™×¨×ª ×”×¤× ×™×” ×œ××•×“×œ
// ×¤×•× ×§×¦×™×” ×œ×”×•×¡×¤×ª ×ª××•× ×ª ×”××©×—×§ Oneline
// ××©×ª× ×” ×’×œ×•×‘×œ×™ ×œ×©××™×¨×ª ×”×¤× ×™×™×” ×œ××™×©×•×¨ ×”×ª××•× ×”
let gameImagePlane;

// ×¤×•× ×§×¦×™×” ×œ×”×•×¡×¤×ª ×ª××•× ×ª ×”××©×—×§ Oneline
const addGameImage = () => {
    // ×˜×¢×™× ×ª ×”×˜×§×¡×˜×•×¨×” ×©×œ ×”×ª××•× ×”
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(
        'img/oneline.jpg', // × ×ª×™×‘ ×œ×ª××•× ×” ×”×¨××©×•× ×™×ª
        (texture) => {
            // ×™×¦×™×¨×ª ××™×©×•×¨ ×œ×”×¦×’×ª ×”×ª××•× ×”
            const aspectRatio = texture.image.width / texture.image.height;
            const width = 2; // ×¨×•×—×‘ ×”×ª××•× ×” ×‘××¨×—×‘ ×”×ª×œ×ª-×××“×™
            const height = width / aspectRatio;
            
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                side: THREE.DoubleSide,
                transparent: true
            });
            
            gameImagePlane = new THREE.Mesh(geometry, material);
            
            // ××™×§×•× ×”×ª××•× ×” ×‘×”×ª×× ×œ×§×•××•×¨×“×™× ×˜×•×ª ×©×”×•×’×“×¨×•
            gameImagePlane.position.set(25.23, 1.60, -0.05);
            
            // ×¡×™×‘×•×‘ ×”×ª××•× ×” ×›×š ×©×ª×”×™×” ×‘×›×™×•×•×Ÿ ×”× ×›×•×Ÿ ×•×œ× ×”×¤×•×›×”
            gameImagePlane.rotation.y = Math.PI / -2; // ×¡×™×‘×•×‘ ×‘-90 ××¢×œ×•×ª ×¡×‘×™×‘ ×¦×™×¨ ×”-Y
           
            
            // ×”×•×¡×¤×ª ×”×ª××•× ×” ×œ×¡×¦× ×”
            scene.add(gameImagePlane);
            
            console.log('×ª××•× ×ª Oneline × ×•×¡×¤×” ×‘×”×¦×œ×—×”');
        },
        undefined, // ×¤×•× ×§×¦×™×™×ª ×”×ª×§×“××•×ª (×œ× × ×“×¨×©×ª)
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª ×ª××•× ×ª Oneline:', error);
        }
    );
};

// ×¤×•× ×§×¦×™×” ×œ×”×—×œ×¤×ª ×”×ª××•× ×” ×œ-oneline2.jpg
const updateGameImage = () => {
    if (!gameImagePlane) return;
    
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(
        'img/oneline2.jpg', // × ×ª×™×‘ ×œ×ª××•× ×” ×”×—×“×©×”
        (texture) => {
            // ×¢×“×›×•×Ÿ ×”×˜×§×¡×˜×•×¨×” ×©×œ ×”××™×©×•×¨ ×”×§×™×™×
            gameImagePlane.material.map = texture;
            gameImagePlane.material.needsUpdate = true;
            
            console.log('×ª××•× ×ª Oneline ×”×•×—×œ×¤×” ×œ-oneline2.jpg ×‘×”×¦×œ×—×”');
        },
        undefined,
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×ª××•× ×” ×”×—×“×©×”:', error);
        }
    );
};
// ×¤×•× ×§×¦×™×” ×œ×˜×¢×™× ×ª ××•×“×œ ×”-newPc
// ×¤×•× ×§×¦×™×” ×œ×˜×¢×™× ×ª ××•×“×œ ×”-newPc
const loadNewPcModel = () => {
    const loader = new THREE.GLTFLoader();
    
    loader.load(
        '3d/newPc.glb',
        (gltf) => {
            newPcModel = gltf.scene;
            
            // ×”×’×“×¨×ª ×¦×œ×œ×™×
            newPcModel.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // ×”×¤×—×ª×ª ×”×‘×”×™×¨×•×ª ×©×œ ×”×—×•××¨×™× - ×‘××§×•× ×œ×”×›×¤×™×œ ×‘-2.0 × ×©××™×¨ ×¨×’×™×œ
                    if (node.material) {
                        if (!Array.isArray(node.material)) {
                            // × ×©××™×¨ ××ª ×”×¦×‘×¢ ×”××§×•×¨×™ ×‘××§×•× ×œ×”×›×¤×™×œ
                            // node.material.color.multiplyScalar(2.0);
                            // × ×¤×—×™×ª ××ª ×¢×•×¦××ª ×”××•×¨ ×”×¤× ×™××™
                            node.material.emissive = new THREE.Color(0x111111);
                        } else {
                            node.material.forEach(mat => {
                                // × ×©××™×¨ ××ª ×”×¦×‘×¢ ×”××§×•×¨×™ ×‘××§×•× ×œ×”×›×¤×™×œ
                                // mat.color.multiplyScalar(2.0);
                                // × ×¤×—×™×ª ××ª ×¢×•×¦××ª ×”××•×¨ ×”×¤× ×™××™
                                mat.emissive = new THREE.Color(0x111111);
                            });
                        }
                    }
                }
            });
            
            // ××™×§×•× ×”××•×“×œ
            newPcModel.position.set(24.17, 0, -0.10);
            newPcModel.scale.set(3.2, 3.2, 3.2);
            newPcModel.rotation.y = Math.PI / -2; 
            // ×”×•×¡×¤×ª ××•×¨ ××™×•×—×“ ×œ××—×©×‘ ×”×—×“×© - ×”×¤×—×ª×ª ×¢×•×¦××ª ×”××•×¨ ×-1.5 ×œ-0.8
            const pcLight = new THREE.PointLight(0xFFFFFF, 0.8, 3);
            pcLight.position.copy(newPcModel.position).add(new THREE.Vector3(0, 0.6, 0));
            scene.add(pcLight);
            
            scene.add(newPcModel);
            console.log('××•×“×œ newPc × ×˜×¢×Ÿ ×‘×”×¦×œ×—×”');
            
            // ×ª×—×™×œ×ª ×‘×“×™×§×ª ××¨×—×§ ××”××•×“×œ ×”×—×“×©
            startNewPcProximityCheck();
        },
        (xhr) => {
            console.log('×˜×¢×™× ×ª newPc: ' + (xhr.loaded / xhr.total * 100) + '% ×˜×¢×•×Ÿ');
        },
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª newPc:', error);
        }
    );
};

// ×¤×•× ×§×¦×™×” ×œ×”×ª×—×œ×ª ×‘×“×™×§×ª ×”××¨×—×§ ××”××•×“×œ ×”×—×“×©
const startNewPcProximityCheck = () => {
    if (newPcCheckTimer) clearInterval(newPcCheckTimer);
    newPcCheckTimer = setInterval(checkNewPcProximity, 200);
};

// ×¤×•× ×§×¦×™×” ×œ×‘×“×™×§×ª ××¨×—×§ ××”××•×“×œ ×”×—×“×©
// ×¢×“×›×•×Ÿ ×‘×¤×•× ×§×¦×™×™×ª ×‘×“×™×§×ª ×”×§×¨×‘×” ×œ××•×“×œ ×”×—×“×©
const checkNewPcProximity = () => {
    // ×‘×“×™×§×” ×× ×”×˜×™×™××¨ ×‘×× ×•×—×” ××• ×©×”××•×“×œ ×œ× ×§×™×™×
    if (!newPcModel) return;

    // ×œ× × ×¤×ª×— ×©×•×‘ ×× ×›×‘×¨ × ×¡×’×¨ ×œ×¦××™×ª×•×ª
    if (newPcModalHasBeenClosed) return;

    const pcPosition = new THREE.Vector3(20.86, 1.60, -0.27);
    const distance = camera.position.distanceTo(pcPosition);
    const activationDistance = 2.0;

    if (distance <= activationDistance && !isNewPcModalCooldown) {
        openNewPcModal();
        isNewPcModalCooldown = true;
        setTimeout(() => {
            isNewPcModalCooldown = false;
        }, 5000);
    }
};




// ×¤×•× ×§×¦×™×” ×œ×”×¦×’×ª ×—×™×•×•×™ ××™× ×˜×¨××§×¦×™×” ×œ××•×“×œ ×”×—×“×©
const showInteractionHintForNewPc = () => {
    let hintEl = document.getElementById('interaction-hint-new-pc');
    
    if (!hintEl) {
        hintEl = document.createElement('div');
        hintEl.id = 'interaction-hint-new-pc';
        hintEl.textContent = '×œ×—×¥ ×›×“×™ ×œ×”×©×ª××© ×‘××—×©×‘ ×”×—×“×©';
        hintEl.style.display = 'none';
        hintEl.style.position = 'absolute';
        hintEl.style.top = '50%';
        hintEl.style.left = '50%';
        hintEl.style.transform = 'translate(-50%, -50%)';
        hintEl.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        hintEl.style.color = 'white';
        hintEl.style.padding = '10px 20px';
        hintEl.style.borderRadius = '5px';
        hintEl.style.zIndex = '50';
        hintEl.style.fontSize = '16px';
        hintEl.style.textAlign = 'center';
        hintEl.style.pointerEvents = 'none';
        document.body.appendChild(hintEl);
    }
    
    hintEl.style.display = 'block';
};

// ×¤×•× ×§×¦×™×” ×œ×”×¡×ª×¨×ª ×—×™×•×•×™ ×”××™× ×˜×¨××§×¦×™×” ×œ××•×“×œ ×”×—×“×©
const hideInteractionHintForNewPc = () => {
    const hintEl = document.getElementById('interaction-hint-new-pc');
    if (hintEl) {
        hintEl.style.display = 'none';
    }
};

// ×¤×•× ×§×¦×™×” ×œ×˜×™×¤×•×œ ×‘×œ×—×™×¦×” ×¢×œ ×”××•×“×œ ×”×—×“×©
// ×¢×“×›×•×Ÿ ×’× ×‘×¤×•× ×§×¦×™×™×ª ×”×˜×™×¤×•×œ ×‘×œ×—×™×¦×”
// ×¤×•× ×§×¦×™×” ×œ×˜×™×¤×•×œ ×‘×œ×—×™×¦×” ×¢×œ ×”××•×“×œ ×”×—×“×©

// ×¤×•× ×§×¦×™×” ×œ×”×¡×ª×¨×ª ××•×“×œ×™×
const hideModels = () => {
    // ×”×¡×ª×¨ ××ª ×”×©×•×œ×—×Ÿ, ×”××—×©×‘×™× ×•×”×“××•×™×•×ª
    scene.traverse((object) => {
        if (object.userData && (object.userData.isTable || 
                               object.userData.isOldComputer || 
                               object.userData.isNewComputer ||
                               object.userData.isCharacter)) {  // ×”×•×¡×¤× ×• ××ª ×”×“××•×™×•×ª
            object.visible = false;
        }
    });
};

// ×¤×•× ×§×¦×™×” ×œ×”×—×–×¨×ª ××•×“×œ×™×
// ×¤×•× ×§×¦×™×” ×œ×”×—×–×¨×ª ××•×“×œ×™× - ××©××™×¨×™× ×¨×™×§×” ×›×“×™ ×œ×× ×•×¢ ×§×¨×™××•×ª ××§×•××•×ª ××—×¨×™×
const showModels = () => {
    // ×¤×•× ×§×¦×™×” ××‘×•×˜×œ×ª - ×œ× ×œ×”×©×ª××© ×‘×”
    console.warn("×”×¤×•× ×§×¦×™×” showModels() × ×§×¨××” ×™×©×™×¨×•×ª - ××™×Ÿ ×œ×”×©×ª××© ×‘×”. ×”××•×“×œ×™× ×™×•×¦×’×• ×¨×§ ×“×¨×š showModelsAfterGameClosure()");
};
// ×¤×•× ×§×¦×™×” ×œ×¤×ª×™×—×ª ×”××•×“××œ ×œ××•×“×œ ×”×—×“×©
const openNewPcModal = () => {
    // ×™×¦×™×¨×ª ×”××•×“××œ ×× ×œ× ×§×™×™×
    if (newPcModalHasBeenClosed) {
        console.log("ğŸš« × ×™×¡×• ×œ×¤×ª×•×— ××ª ×”××•×“××œ ×©×œ newGame, ××‘×œ ×”×•× ×›×‘×¨ × ×¡×’×¨ ×œ×¦××™×ª×•×ª.");
        return;
    }
    let modal = document.getElementById('new-pc-modal');
    
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'new-pc-modal';
        modal.className = 'modal';
        
        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';
        
        const iframe = document.createElement('iframe');
        iframe.id = 'new-game-iframe';
        iframe.src = 'iframe/newGame.html';
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.borderRadius = '10px';
      
        modalContent.appendChild(iframe);
        modal.appendChild(modalContent);
        
        document.body.appendChild(modal);
    }
    
    // ×”×¦×’ ××ª ×”××•×“××œ
    modal.style.display = 'block';
    
    // ×”×©×‘×ª ××ª ×”×©×œ×™×˜×”
    if (controls) {
        controls.enabled = false;
    }
    
    // ×¢×¦×™×¨×ª ×”×ª× ×•×¢×” ×•×”×¦×œ×™×œ
    if (controls) {
        controls.moveForward = false;
        controls.moveBackward = false;
    }
    movingForward = false;
    movingBackward = false;
    
    // ×¢×¦×•×¨ ××ª ×¦×œ×™×œ ×”×”×œ×™×›×”
    if (isWalking && walkSound) {
        walkSound.pause();
        isWalking = false;
    }
    
    // ×”×¡×ª×¨ ××ª ×”×—×™×•×•×™ ×•×”×›×•×•× ×ª
    hideInteractionHintForNewPc();
    document.getElementById('crosshair').style.display = 'none';
    
    // ×”×¡×ª×¨ ××ª ×ª×¦×•×’×ª ×”××™×§×•× ×× ×§×™×™××ª
    if (window.positionDisplay) {
        window.positionDisplay.style.display = 'none';
    }
    
    // ×”×¡×ª×¨ ××ª ×”××•×“×œ×™×
    hideModels();
};

// ×¤×•× ×§×¦×™×” ×œ×¡×’×™×¨×ª ×”××•×“××œ ×œ××•×“×œ ×”×—×“×©
// ×“×’×œ ×œ×¡×’×™×¨×” ×¡×•×¤×™×ª ×©×œ ×”××•×“××œ (×›×‘×¨ ×œ××¢×œ×” ×‘×§×•×“ ×©×œ×š)
let newPcModalHasBeenClosed = false;

// ×¤×•× ×§×¦×™×” ×œ×¡×’×™×¨×ª ×”××•×“××œ ×©×œ ×”××—×©×‘ ×”×—×“×© - ×œ×¦××™×ª×•×ª
const closeNewPcModal = () => {
    const modal = document.getElementById('new-pc-modal');

    // ×× ×”××•×“××œ ×§×™×™× â€“ ×”×¡×¨ ××•×ª×• ××”-DOM
    if (modal) {
        modal.remove();
        console.log("ğŸ›‘ ×”××•×“××œ ×©×œ newGame × ×¡×’×¨ â€“ ×œ× ×™×™×¤×ª×— ×©×•×‘!");
    }

    // ×§×‘×™×¢×ª ×”×“×’×œ ×›×š ×©×œ× ×™×™×¤×ª×— ×©×•×‘ ×œ×¢×•×œ×
    newPcModalHasBeenClosed = true;

    // ×”×¤×¡×§×ª ×‘×“×™×§×ª ×§×¨×‘×”
    if (newPcCheckTimer) {
        clearInterval(newPcCheckTimer);
        newPcCheckTimer = null;
    }

    // ×”×¤×¢×œ×ª ×”×©×œ×™×˜×” ××—×“×©
    if (controls) {
        controls.enabled = true;
    }

    // ×•×™×“×•× ×©×”×ª× ×•×¢×” ××•×¤×¡×§×ª
    if (controls) {
        controls.moveForward = false;
        controls.moveBackward = false;
    }
    movingForward = false;
    movingBackward = false;

    // ×”×—×–×¨×ª ×”×›×•×•× ×ª
    document.getElementById('crosshair').style.display = 'block';

    // ×”×—×–×¨×ª ×ª×¦×•×’×ª ×”××™×§×•× ×× ×§×™×™××ª
    if (window.positionDisplay) {
        window.positionDisplay.style.display = 'block';
    }
};

// ×¤×•× ×§×¦×™×” ×œ×‘×“×™×§×ª ××¨×—×§ ××”××—×©×‘
const checkComputerProximity = () => {
    if (!areModelsVisible() || isComputerModalCooldown) return;

    const computerPosition = new THREE.Vector3(1.86, 1.60, -0.97); // â† ××™×§×•× ×—×“×©
    const distance = camera.position.distanceTo(computerPosition);
    const activationDistance = 2.0;

    if (distance <= activationDistance) {
        if (!isComputerModalCooldown) {
            openComputerModal(); // â† ×¤×ª×™×—×” ××•×˜×•××˜×™×ª
            isComputerModalCooldown = true;
            setTimeout(() => {
                isComputerModalCooldown = false;
            }, 5000); // ×§×™×¨×•×¨ ×©×œ 5 ×©× ×™×•×ª
        }
    }
};

// ×¤×•× ×§×¦×™×” ×œ×˜×™×¤×•×œ ×‘×œ×—×™×¦×” ×¢×œ ××—×©×‘
const handleComputerClick = () => {
    // ×‘×“×™×§×” ×× ×× ×—× ×• ×¢×“×™×™×Ÿ ×‘×˜×•×•×—
    if (!areModelsVisible()) return;
    const computerPosition = new THREE.Vector3(8.76, 1.6, 2.69);
    const distance = camera.position.distanceTo(computerPosition);
    
    if (distance <= 2.0 && !isComputerModalCooldown) {
        // ×¤×ª×™×—×ª ×”××•×“×œ
        openComputerModal();
    }
    
    // ×”×¡×¨×ª ×”××–× ×” ××—×¨×™ ×œ×—×™×¦×”
};

// ×¤×•× ×§×¦×™×” ×œ×”×¦×’×ª ×—×™×•×•×™ ××™× ×˜×¨××§×¦×™×”
const showInteractionHint = () => {
    let hintEl = document.getElementById('interaction-hint');
    
    if (!hintEl) {
        hintEl = document.createElement('div');
        hintEl.id = 'interaction-hint';
        hintEl.textContent = '×œ×—×¥ ×›×“×™ ×œ×”×©×ª××© ×‘××—×©×‘';
        document.body.appendChild(hintEl);
    }
    
    hintEl.style.display = 'block';
};

// ×¤×•× ×§×¦×™×” ×œ×”×¡×ª×¨×ª ×—×™×•×•×™ ×”××™× ×˜×¨××§×¦×™×”
const hideInteractionHint = () => {
    const hintEl = document.getElementById('interaction-hint');
    if (hintEl) {
        hintEl.style.display = 'none';
    }
};

// ×¤×•× ×§×¦×™×” ×œ×¤×ª×™×—×ª ×”××•×“×œ
// ×¤×•× ×§×¦×™×” ×œ×¤×ª×™×—×ª ×”××•×“×œ
const openComputerModal = () => {
    window.location.href = 'computers.html';
};

// ×¤×•× ×§×¦×™×” ×œ×¡×’×™×¨×ª ×”××•×“×œ ×¢× ×”×©×”×™×™×”
// ×¤×•× ×§×¦×™×” ×œ×¡×’×™×¨×ª ×”××•×“×œ ×¢× ×”×©×”×™×™×”
// ×¤×•× ×§×¦×™×” ×œ×¡×’×™×¨×ª ×”××•×“×œ ×¢× ×”×©×”×™×™×”
const closeComputerModal = () => {
    // ×”×¡×ª×¨ ××ª ×”××•×“×œ
    const modal = document.getElementById('computer-modal');
    modal.style.display = 'none';
    
    // × ×§×” ××ª ×”-iframe ×›×“×™ ×œ×¢×¦×•×¨ ××ª ×”××•×“×™×•
    document.getElementById('computer-iframe').src = '';
    
    // ×”×¤×¢×œ×ª ××¦×‘ ×”××ª× ×” ×œ××©×š 5 ×©× ×™×•×ª
    isComputerModalCooldown = true;
    
    // ×”×¤×¢×œ ×˜×™×™××¨ ×œ×”×¡×¨×ª ×”×”××ª× ×”
    setTimeout(() => {
        isComputerModalCooldown = false;
    }, 5000); // 5 ×©× ×™×•×ª
    
    // ×”×¤×¢×œ ××ª ×”×©×œ×™×˜×” ××—×“×©
    if (controls) {
        controls.enabled = true;
    }
    
    // ×•×™×“×•× ×©×”×ª× ×•×¢×” ××•×¤×¡×§×ª
    if (controls) {
        controls.moveForward = false;
        controls.moveBackward = false;
    }
    movingForward = false;
    movingBackward = false;
    
    // ×”×—×–×¨ ××ª ×”×›×•×•× ×ª
    document.getElementById('crosshair').style.display = 'block';
    
    // ×”×—×–×¨ ××ª ×ª×¦×•×’×ª ×”××™×§×•× ×× ×§×™×™××ª
    if (window.positionDisplay) {
        window.positionDisplay.style.display = 'block';
    }
};
// ×¤×•× ×§×¦×™×” ×œ××ª×—×•×œ ×”××•×“×œ ×•×”××™×¨×•×¢×™×
const setupComputerModal = () => {
    // ×”×’×“×¨×ª ××™×¨×•×¢×™× ×œ××•×“×œ
    const modal = document.getElementById('computer-modal');
    const closeBtn = modal.querySelector('.close-btn');
    
    // ×¡×’×™×¨×” ×‘×œ×—×™×¦×” ×¢×œ X
    closeBtn.addEventListener('click', closeComputerModal);
    
    // ×¡×’×™×¨×” ×‘×œ×—×™×¦×” ××—×•×¥ ×œ×ª×•×›×Ÿ
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeComputerModal();
        }
    });
    
    // ×¡×’×™×¨×” ×‘×œ×—×™×¦×” ×¢×œ ××§×© Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.style.display === 'block') {
            closeComputerModal();
        }
    });
    
    // ×”×¤×¢×œ×ª ×‘×“×™×§×ª ××¨×—×§ ××”××—×©×‘ (×›×œ 200 ××™×œ×™×©× ×™×•×ª)
    computerCheckTimer = setInterval(checkComputerProximity, 200);
};
        // ×™×¦×™×¨×ª ×¤×•×¨×˜×œ ×¢× ×—×œ×§×™×§×™ ×¢×©×Ÿ ×¡×’×•×œ
        const createPortalEffect = () => {
            // ×™×¦×™×¨×ª ×’×™××•××˜×¨×™×” ×œ×—×œ×§×™×§×™×
            const particleCount = 500;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            // ×”×’×“×¨×ª ×¢×©×Ÿ ×‘××¢×’×œ ×¡×‘×™×‘ × ×§×•×“×ª ×”×¤×•×¨×˜×œ
            for (let i = 0; i < particleCount; i++) {
                // ××™×§×•× ××§×¨××™ ×‘×ª×•×š ×¡×¤×™×¨×”
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * portalRadius;
                const height = Math.random() * 5; // ×’×•×‘×” ×”×—×œ×§×™×§×™×
                
                // ×”×•×¡×¤×ª ×¨× ×“×•××™×•×ª ×§×˜× ×” ×œ××™×§×•×
                positions[i * 3] = specialPortalPoint.x + Math.cos(angle) * radius;
                positions[i * 3 + 1] = specialPortalPoint.y + height;
                positions[i * 3 + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                
                // ×¦×‘×¢ ×¡×’×•×œ ×¢× ×•×¨×™××¦×™×•×ª ×§×œ×•×ª
                colors[i * 3] = 0.5 + Math.random() * 0.2; // ××“×•×
                colors[i * 3 + 1] = 0; // ×™×¨×•×§
                colors[i * 3 + 2] = 0.8 + Math.random() * 0.2; // ×›×—×•×œ
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // ×™×¦×™×¨×ª ××˜×¨×™××œ ×œ×—×œ×§×™×§×™× ×¢× ×¡×•×’ ×¢×¨×‘×•×‘ (Blending) ××ª××™× ×œ×¢×©×Ÿ
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.4,
                transparent: true,
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            // ×™×¦×™×¨×ª ×”××¢×¨×›×ª ×—×œ×§×™×§×™×
            portalParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(portalParticles);
            
            // ×”×•×¡×¤×ª ××•×¨ × ×§×•×“×ª×™ ×¡×’×•×œ ×‘××–×•×¨ ×”×¤×•×¨×˜×œ
            const portalLight = new THREE.PointLight(0x9932CC, 1, 10);
            portalLight.position.copy(specialPortalPoint);
            portalLight.position.y += 1.5; // ×”×¨××ª ×”××•×¨ ××¢×˜
            scene.add(portalLight);
        };
        
        // ×× ×™××¦×™×” ×œ×¤×•×¨×˜×œ
        const animatePortal = () => {
            if (portalParticles) {
                const positions = portalParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // ×ª× ×•×¢×” ××§×¨××™×ª ×§×œ×”
                    positions[i] += (Math.random() - 0.5) * 0.05;
                    positions[i + 1] += Math.random() * 0.05; // ×ª× ×•×¢×” ×§×œ×” ×œ××¢×œ×”
                    positions[i + 2] += (Math.random() - 0.5) * 0.05;
                    
                    // ×”×—×–×¨ ×—×œ×§×™×§×™× ×©×™×¦××• ×—×–×¨×” ×œ××–×•×¨ ×”×¤×•×¨×˜×œ
                    const dx = positions[i] - specialPortalPoint.x;
                    const dz = positions[i + 2] - specialPortalPoint.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance > portalRadius || positions[i + 1] > specialPortalPoint.y + 5) {
                        // ×× ×”×—×œ×§×™×§ ×™×¦× ××”×’×‘×•×œ×•×ª, ×”×—×–×¨ ××•×ª×• ×œ××™×§×•× ×—×“×© ×‘×ª×•×š ×”×¤×•×¨×˜×œ
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * portalRadius * 0.7;
                        
                        positions[i] = specialPortalPoint.x + Math.cos(angle) * radius;
                        positions[i + 1] = specialPortalPoint.y + Math.random() * 2.5;
                        positions[i + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                    }
                }
                
                portalParticles.geometry.attributes.position.needsUpdate = true;
            }
        };
        
        // ×¤×•× ×§×¦×™×” ×œ×‘×“×™×§×ª ××™×§×•× ×—×“×© ×•××¢×‘×¨ ×œ××¡×š ×”×‘×
        const checkCustomLocationPoints = (position) => {
    // ×‘×“×™×§×ª ××¨×—×§ ×× ×§×•×“×ª ×”×¤×•×¨×˜×œ ×”××™×•×—×“×ª
    const distanceToPortal = position.distanceTo(specialPortalPoint);
    
    if (distanceToPortal < portalRadius / 2) { // ×›××©×¨ ×”×©×—×§×Ÿ ×‘×××ª ×§×¨×•×‘ ×œ×¤×•×¨×˜×œ
        // ×¢×¦×™×¨×ª ×”×ª× ×•×¢×” ×•×”×¦×œ×™×œ ×œ×¤× ×™ ××¢×‘×¨ ×“×£
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
        
        // ××¢×‘×¨ ×œ×“×£ back.html
        window.location.href = 'back.html';
        return true;
    }
    
    return false;
};
        
        // ×§×‘×•×¢ ×’×•×‘×” ×”×©×—×§×Ÿ ××¢×œ ×”××“××”
        
        
        // ×ª××•×¨×” ×•××¤×§×˜×™×
        const setupLighting = () => {
            // ××•×¨ ×¡×‘×™×‘×”
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // ××•×¨ ×”×©××© ×”×¨××©×™
            const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.0);
            sunLight.position.set(10, 20, 15);
            sunLight.castShadow = true;
            
            // ×”×’×“×¨×•×ª ×¦×œ ××™×›×•×ª×™×•×ª ×™×•×ª×¨
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            sunLight.shadow.bias = -0.0003;
            
            scene.add(sunLight);
            
            // × ×§×•×“×ª ××•×¨ ××©× ×™×ª ×œ×ª××•×¨×ª ××™×œ×•×™
            const fillLight = new THREE.DirectionalLight(0xc2d1ff, 0.5);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
            
            // ××•×¨ × ×§×•×“×ª×™ ×¢×“×™×Ÿ ×‘××¨×›×– ×”×¡×¦× ×”
            const pointLight = new THREE.PointLight(0xffedbe, 0.5, 20);
            pointLight.position.set(0, 12, 0);
            scene.add(pointLight);
            
            // ×¢×¨×¤×œ ×œ×ª×—×•×©×ª ×¢×•××§
            scene.fog = new THREE.FogExp2(0x8eb5e0, 0.006); // ×”×§×˜× ×ª ×¢×¨×š ×”×¦×¤×™×¤×•×ª ×œ×’×•×‘×” ×”×’×“×•×œ ×™×•×ª×¨
        };
        
        // ×™×¦×™×¨×ª ×˜×§×¡×˜×•×¨×ª ×¨×¦×¤×” ×‘×¡×’× ×•×Ÿ ×›×‘×™×©
// ×™×¦×™×¨×ª ×˜×§×¡×˜×•×¨×ª ×¨×¦×¤×” ×‘×¡×’× ×•×Ÿ ×›×‘×™×© ×œ×œ× ×¡×™××•× ×™×
// ×™×¦×™×¨×ª ×˜×§×¡×˜×•×¨×ª ×¨×¦×¤×” ×‘×¡×’× ×•×Ÿ ×¨×—×•×‘ ×™×©×Ÿ ×¢× ××¨×¦×¤×•×ª ××œ×‘× ×™×•×ª ×‘×’×•×•×Ÿ ×—×•× ×›×”×”
const createOfficeFloorTexture = () => {
    const textureSize = 1024;
    const canvas = document.createElement('canvas');
    canvas.width = textureSize;
    canvas.height = textureSize;
    const ctx = canvas.getContext('2d');
    
    // ×¦×‘×¢ ×¨×§×¢ ×‘×’×•×•×Ÿ ××¤×•×¨ ×›×”×”
    ctx.fillStyle = '#555555';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ×’×•×“×œ ×”××¨×™×—×™× - ×’×“×•×œ×™× ×™×•×ª×¨ ×œ×¨×¦×¤×ª ×”×™×™×˜×§
    const tileWidth = 256; 
    const tileHeight = 256;
    const groutWidth = 2; // ×—×™×‘×•×¨×™× ×“×§×™× ×‘×™×Ÿ ×”××¨×™×—×™×
    
    // ×¦×™×•×¨ ×”××¨×™×—×™× ×”××¤×•×¨×™× ×”×›×”×™×
    for (let x = 0; x < canvas.width; x += tileWidth) {
        for (let y = 0; y < canvas.height; y += tileHeight) {
            // ×•×¨×™××¦×™×” ×§×œ×” ×‘×’×•×•×Ÿ ×”××¤×•×¨ ×œ×ª×ª ××¨××” ××¦×™××•×ª×™
            const variation = Math.random() * 10;
            const grayValue = 100 + variation; // ×¢×¨×›×™× × ××•×›×™× ×™×•×ª×¨ = ××¤×•×¨ ×›×”×” ×™×•×ª×¨
            
            // ×¦×™×•×¨ ×”××¨×™×— ×¢×¦××•
            ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
            ctx.fillRect(x + groutWidth/2, y + groutWidth/2, 
                tileWidth - groutWidth, tileHeight - groutWidth);
            
            // ×”×•×¡×¤×ª ××¨×§× ×¢×“×™×Ÿ ×œ××¨×™×—
            addTileTexture(ctx, x + groutWidth/2, y + groutWidth/2, 
                tileWidth - groutWidth, tileHeight - groutWidth);
        }
    }
    
    // ×™×¦×™×¨×ª ×˜×§×¡×˜×•×¨×” ××”×§× ×‘×¡
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(2, 2); // ×¤×—×•×ª ×—×–×¨×•×ª ×œ××¨×™×—×™× ×’×“×•×œ×™× ×™×•×ª×¨
    
    return texture;
};

// ×¤×•× ×§×¦×™×” ×œ×”×•×¡×¤×ª ××¨×§× ×¢×“×™×Ÿ ×œ××¨×™×— ××¤×•×¨ ×›×”×”
const addTileTexture = (ctx, x, y, width, height) => {
    // ×”×•×¡×¤×ª ××¨×§× ×¢×“×™×Ÿ ×¢× ××¢×˜ ×‘×¨×§
    for (let i = 0; i < width * height / 400; i++) {
        const px = x + Math.random() * width;
        const py = y + Math.random() * height;
        const size = Math.random() * 1.5 + 0.5;
        
        // × ×§×•×“×•×ª ×‘×¨×§ ××§×¨××™×•×ª - ×‘×’×•×•×Ÿ ××¤×•×¨ ×‘×”×™×¨ ×¢× ×©×§×™×¤×•×ª
        ctx.fillStyle = `rgba(150, 150, 150, ${Math.random() * 0.15})`;
        ctx.beginPath();
        ctx.arc(px, py, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // ×”×•×¡×¤×ª ×§×•×•×™× ×“×§×™× ×•×¢×“×™× ×™× ×‘×’×•×•×Ÿ ××¤×•×¨ ×›×”×” ×™×•×ª×¨ ××• ×‘×”×™×¨ ×™×•×ª×¨ ×œ××¨××” ××¨×™×—×™× ××™×›×•×ª×™×™×
    const numLines = 8;
    ctx.strokeStyle = 'rgba(80, 80, 80, 0.2)';
    ctx.lineWidth = 0.5;
    
    for (let i = 0; i < numLines; i++) {
        const startX = x + Math.random() * width;
        const startY = y + Math.random() * height;
        const endX = startX + (Math.random() * 40 - 20);
        const endY = startY + (Math.random() * 40 - 20);
        
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    }
    
    // ×”×•×¡×¤×ª ××¢×˜ ×‘×¨×§ ×‘×¤×™× ×•×ª ××§×¨××™×•×ª ×œ×“××•×ª ×”×—×–×¨ ××•×¨
    for (let i = 0; i < 4; i++) {
        const cornerX = x + (i === 0 || i === 2 ? 0 : width);
        const cornerY = y + (i < 2 ? 0 : height);
        
        const gradient = ctx.createRadialGradient(
            cornerX, cornerY, 0,
            cornerX, cornerY, 20 + Math.random() * 10
        );
        
        gradient.addColorStop(0, 'rgba(140, 140, 140, 0.2)');
        gradient.addColorStop(1, 'rgba(100, 100, 100, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(cornerX, cornerY, 20 + Math.random() * 10, 0, Math.PI * 2);
        ctx.fill();
    }
};
// ×¤×•× ×§×¦×™×” ×œ×”×•×¡×¤×ª ×˜×§×¡×˜×•×¨×” ×œ×›×œ ××‘×Ÿ
const addStoneTexture = (ctx, x, y, width, height) => {
    // ×”×•×¡×¤×ª ××¨×§× ××—×•×¡×¤×¡ ×œ××‘×Ÿ
    for (let i = 0; i < width * height / 40; i++) {
        const px = x + Math.random() * width;
        const py = y + Math.random() * height;
        const size = Math.random() * 2 + 0.5;
        
        // ×¦×‘×¢ ××§×¨××™ ×œ×›×ª× - ×’×•×•×Ÿ ×©×œ ×—×•× ×›×”×”
        ctx.fillStyle = `rgba(45, 30, 20, ${Math.random() * 0.3})`;
        ctx.beginPath();
        ctx.arc(px, py, size, 0, Math.PI * 2);
        ctx.fill();
    }
};

// ×¤×•× ×§×¦×™×” ×œ×”×•×¡×¤×ª ×©×—×™×§×”, ×¡×“×§×™× ×•×›×ª××™× ×¢×œ ×”×¨×¦×¤×”
const addWearAndTear = (ctx, width, height, tileWidth, tileHeight, groutWidth) => {
    // ×”×•×¡×¤×ª ×¡×“×§×™× ××§×¨××™×™×
    for (let i = 0; i < 120; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const length = 8 + Math.random() * 30;
        const angle = Math.random() * Math.PI * 2;
        
        ctx.strokeStyle = `rgba(30, 20, 15, ${Math.random() * 0.6 + 0.2})`;
        ctx.lineWidth = Math.random() * 1.5 + 0.5;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // ×¡×“×§ ××¤×•×ª×œ
        let currentX = x;
        let currentY = y;
        const segments = 2 + Math.floor(Math.random() * 3);
        const segmentLength = length / segments;
        
        for (let j = 0; j < segments; j++) {
            const segAngle = angle + (Math.random() * 0.5 - 0.25);
            currentX += Math.cos(segAngle) * segmentLength;
            currentY += Math.sin(segAngle) * segmentLength;
            ctx.lineTo(currentX, currentY);
        }
        
        ctx.stroke();
    }
    
    // ×”×•×¡×¤×ª ×›×ª××™× ×•×›×”×•×™×•×ª
    for (let i = 0; i < 300; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const size = 5 + Math.random() * 15;
        
        // ×¦×‘×¢×™× ×©×•× ×™× ×œ×›×ª××™×
        let color;
        const type = Math.random();
        
        if (type < 0.6) {
            // ×›×ª× ×›×”×” ×™×•×ª×¨ (×©×—×™×§×”)
            color = `rgba(20, 15, 10, ${Math.random() * 0.3})`;
        } else if (type < 0.9) {
            // ×›×ª× ×—×•× ×›×”×” (×œ×›×œ×•×š)
            color = `rgba(40, 25, 15, ${Math.random() * 0.4})`;
        } else {
            // ×›×ª× ×—×•×-××“××“× (×—×œ×•×“×”)
            color = `rgba(60, 30, 20, ${Math.random() * 0.3})`;
        }
        
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // ×¦×™×•×¨ ×§×•×•×™ ×—×™×‘×•×¨ ×‘×™×Ÿ ×”××œ×‘× ×™× ×‘×¦×‘×¢ ×›×”×” ×™×•×ª×¨
    // ×§×•×•×™× ×× ×›×™×™×
    for (let x = 0; x < width; x += tileWidth) {
        ctx.strokeStyle = `rgba(15, 10, 5, 0.9)`; // ×—×™×‘×•×¨×™× ×›×”×™× ×™×•×ª×¨
        ctx.lineWidth = groutWidth;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
    }
    
    // ×§×•×•×™× ××•×¤×§×™×™×
    for (let y = 0; y < height; y += tileHeight) {
        ctx.strokeStyle = `rgba(15, 10, 5, 0.9)`;
        ctx.lineWidth = groutWidth;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
    }
    
    // ×”×•×¡×¤×ª ××¤×§×˜ ×¨×˜×™×‘×•×ª ××§×¨××™
    for (let i = 0; i < 15; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const size = 30 + Math.random() * 80;
        
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
        gradient.addColorStop(0, 'rgba(25, 15, 10, 0.3)');
        gradient.addColorStop(0.7, 'rgba(25, 15, 10, 0.1)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // ×”×•×¡×¤×ª ××¢×˜ ×‘×¨×§ ×œ××‘× ×™× ×‘× ×§×•×“×•×ª ××¡×•×™××•×ª (×›××• ×©×™×© ×œ×¤×¢××™× ×‘×¨×¦×¤×•×ª ×™×©× ×•×ª)
    for (let i = 0; i < 100; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const size = 1 + Math.random() * 3;
        
        ctx.fillStyle = `rgba(100, 80, 60, ${Math.random() * 0.2 + 0.1})`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
};
        
        // ×™×¦×™×¨×ª ×§×¨×§×¢ ×©×˜×•×—×” ×‘×¡×’× ×•×Ÿ ×›×‘×™×©
// ×™×¦×™×¨×ª ×§×¨×§×¢ ×©×˜×•×—×” ×‘×¡×’× ×•×Ÿ ×›×‘×™×©
// ×™×¦×™×¨×ª ×§×¨×§×¢ ×©×˜×•×—×” ×‘×¦×•×¨×ª ×¨×™×‘×•×¢ ×××™×ª×™
const createFlatRoadGround = () => {
    // ×™×¦×™×¨×ª ×¨×™×‘×•×¢ ×××™×ª×™ ×›×¨×¦×¤×”
    const boxWidth = 200;
    const boxDepth = 200;
    const boxHeight = 1; // ×’×•×‘×” ×“×§ ×××•×“
    
    // ×©×™××•×© ×‘-BoxGeometry ×©×™×•×¦×¨×ª ×¨×™×‘×•×¢ ××•×©×œ×
    const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
    
    // ×™×¦×™×¨×ª ×”××˜×¨×™××œ ×¢× ×˜×§×¡×˜×•×¨×ª ×¨×¦×¤×ª ××©×¨×“ ×”×™×™×˜×§ ×‘×’×•×•×Ÿ ××¤×•×¨ ×›×”×”
    const officeFloorTexture = createOfficeFloorTexture();
    
    // ×”×’×“×¨×ª ××¢×¨×š ×©×œ ××˜×¨×™××œ×™× ×œ×›×œ ×¤××” ×©×œ ×”×§×•×¤×¡×”
    const materials = [
        new THREE.MeshStandardMaterial({ color: 0x666666 }), // ×¦×“ ×™××™×Ÿ - ××¤×•×¨ ×›×”×”
        new THREE.MeshStandardMaterial({ color: 0x666666 }), // ×¦×“ ×©×××œ - ××¤×•×¨ ×›×”×”
        new THREE.MeshStandardMaterial({ 
            map: officeFloorTexture,
            roughness: 0.2, // ×¢×¨×š × ××•×š = ××‘×¨×™×§ ×™×•×ª×¨
            metalness: 0.05, // ×¢×¨×š × ××•×š ×××•×“ ×œ××¤×•×¨ (×¤×—×•×ª ××ª×›×ª×™)
            envMapIntensity: 1.0 // ×”×—×–×¨×™ ××•×¨ ××ª×•× ×™×
        }), // ×œ××¢×œ×” (×”×¨×¦×¤×” ×¢×¦××”)
        new THREE.MeshStandardMaterial({ color: 0x666666 }), // ×œ××˜×” - ××¤×•×¨ ×›×”×”
        new THREE.MeshStandardMaterial({ color: 0x666666 }), // ×—×–×™×ª - ××¤×•×¨ ×›×”×”
        new THREE.MeshStandardMaterial({ color: 0x666666 })  // ×’×‘ - ××¤×•×¨ ×›×”×”
    ];
    
    ground = new THREE.Mesh(geometry, materials);
    
    // ××™×§×•× ×”×¨×¦×¤×” ×‘×’×•×‘×” 0
    ground.position.y = -3; // ×—×¦×™ ××”×’×•×‘×” ×›×“×™ ×©×”×—×œ×§ ×”×¢×œ×™×•×Ÿ ×™×”×™×” ×‘×“×™×•×§ ×‘×’×•×‘×” 0
    ground.receiveShadow = true;
    scene.add(ground);
    
    return ground;
};
        
        // ×™×¦×™×¨×ª ×§×•×œ×™×“×¨×™× ×œ×§×™×¨×•×ª ×”×× ×”×¨×”
        const createTunnelColliders = (startPoint, endPoint, tunnelRadius) => {
    // × ×™×§×•×™ ××¢×¨×š ×”×§×•×œ×™×“×¨×™× ×”×§×™×™×
    tunnelWalls = [];
    
    // ×—×™×©×•×‘ ×”×›×™×•×•×Ÿ ×•×”××•×¨×š ×©×œ ×”×× ×”×¨×”
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    const tunnelLength = direction.length();
    
    // × ×¨××•×œ ×”×›×™×•×•×Ÿ
    const normalizedDirection = direction.clone().normalize();
    
    // ×™×¦×™×¨×ª ×•×§×˜×•×¨ × ×™×¦×‘ ×œ×›×™×•×•×Ÿ ×”×× ×”×¨×”
    const perpendicular = new THREE.Vector3();
    if (Math.abs(normalizedDirection.y) < 0.99) {
        perpendicular.set(0, 1, 0);
    } else {
        perpendicular.set(1, 0, 0);
    }
    perpendicular.cross(normalizedDirection).normalize();
    
    // ××¡×¤×¨ ×”×§×•×œ×™×“×¨×™× ×¡×‘×™×‘ ×”×™×§×£ ×”×× ×”×¨×”
    const numColliders = 8;
    
    // ×™×¦×™×¨×ª ×§×•×œ×™×“×¨×™× ×¡×‘×™×‘ ×”×™×§×£ ×”×× ×”×¨×”
    for (let i = 0; i < numColliders; i++) {
        const angle = (i / numColliders) * Math.PI * 2;
        
        // ×•×§×˜×•×¨ ×‘×›×™×•×•×Ÿ ×”×§×•×œ×™×“×¨ ×”× ×•×›×—×™
        const ringVector = perpendicular.clone().applyAxisAngle(normalizedDirection, angle);
        
        // × ×§×•×“×•×ª ×œ××•×¨×š ×”×§×•×œ×™×“×¨
        const colliderPoints = [];
        
        // ××¡×¤×¨ ×”× ×§×•×“×•×ª ×œ××•×¨×š ×”×× ×”×¨×”
        const numPoints = 4;
        
        // ×™×¦×™×¨×ª × ×§×•×“×•×ª ×œ××•×¨×š ×”×× ×”×¨×”
        for (let j = 0; j <= numPoints; j++) {
            const t = j / numPoints;
            
            // × ×§×•×“×” ×¢×œ ×§×• ×”×× ×”×¨×”
            const pointOnLine = new THREE.Vector3().lerpVectors(startPoint, endPoint, t);
            
            // × ×§×•×“×” ×¢×œ ×§×™×¨ ×”×× ×”×¨×”
            const pointOnWall = pointOnLine.clone().add(
                ringVector.clone().multiplyScalar(tunnelRadius * 0.9) // ××¢×˜ ×¤× ×™××” ××”×¨×“×™×•×¡ ×”×××™×ª×™
            );
            
            colliderPoints.push(pointOnWall);
        }
        
        // ×©××™×¨×ª ××™×“×¢ ×”×§×•×œ×™×“×¨
        tunnelWalls.push({
    points: colliderPoints,
    radius: 0.5 // ×”×’×“×œ×” ×œ×§×•×œ×™×“×¨×™× ×¨×—×‘×™× ×™×•×ª×¨ ×œ×× ×”×¨×” ×”×’×“×•×œ×”
});
    }
};
        
        // ×‘×“×™×§×ª ×”×ª× ×’×©×•×ª ×¢× ×§×™×¨×•×ª ×”×× ×”×¨×”
        const checkTunnelCollisions = (position) => {
    // ×× ××™×Ÿ ×§×™×¨×•×ª ×× ×”×¨×”, ×”×—×–×¨ false ×ª××™×“
    if (!tunnelWalls || tunnelWalls.length === 0) {
        return false;
    }
    
    // ×”××©×š ×”×§×•×“ ×”×§×™×™× ×× ×™×© ×§×™×¨×•×ª ×× ×”×¨×”
    // ×¨×“×™×•×¡ ×”×©×—×§×Ÿ
    const playerRadius = 0.5;
    
    for (const wall of tunnelWalls) {
        // ×‘×“×™×§×ª ×›×œ ××§×˜×¢ ×©×œ ×”×§×™×¨
        for (let i = 0; i < wall.points.length - 1; i++) {
            // ×§×•×“ ×§×™×™×...
        }
    }
    
    return false;
};
        
        // ×™×¦×™×¨×ª ×¦×™× ×•×¨/×× ×”×¨×” ×©×”×©×—×§×Ÿ ×™×•×›×œ ×œ×”×™×›× ×¡ ××œ×™×•
        const createTunnel = () => {
    // × ×§×•×“×•×ª ×”×ª×—×œ×” ×•×¡×™×•× ×”×× ×”×¨×” (× ×§×•×“×•×ª ×—×“×©×•×ª)
    const startPoint = new THREE.Vector3(-9.63, 13.0, 26.94); // ×”×ª×—×œ×ª ×”×× ×”×¨×” ×”×—×“×©×” ×¢× ×’×•×‘×” 13
    const endPoint = new THREE.Vector3(33.19, 13.0, -38.43); // ×¡×•×£ ×”×× ×”×¨×” ×”×—×“×© ×¢× ×’×•×‘×” 13
    
    // ×—×™×©×•×‘ ×”×›×™×•×•×Ÿ ×•×”××•×¨×š ×©×œ ×”×× ×”×¨×”
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    const tunnelLength = direction.length();
    
    // ×¨×“×™×•×¡ ×”×¦×™× ×•×¨ - ××•×’×“×œ ×œ-8 ××˜×¨
    const tunnelRadius = 8; // ×¨×“×™×•×¡ ×—×“×©
    // ××¡×¤×¨ ×”××§×˜×¢×™× ×œ××•×¨×š ×•×‘×”×™×§×£ ×”×¦×™× ×•×¨
    const radialSegments = 16;
    const heightSegments = 30;
    
    
    // ×™×¦×™×¨×ª ×’×™××•××˜×¨×™×ª ×¦×™×œ×™× ×“×¨ ×¤×ª×•×— ×‘×©× ×™ ×”×§×¦×•×•×ª
    const geometry = new THREE.CylinderGeometry(
        tunnelRadius, // ×¨×“×™×•×¡ ×¢×œ×™×•×Ÿ
        tunnelRadius, // ×¨×“×™×•×¡ ×ª×—×ª×•×Ÿ
        tunnelLength, // ××•×¨×š
        radialSegments, // ××¡×¤×¨ ××§×˜×¢×™× ×‘×”×™×§×£
        heightSegments, // ××¡×¤×¨ ××§×˜×¢×™× ×œ××•×¨×š
        true // ×¤×ª×•×— ×‘×©× ×™ ×”×§×¦×•×•×ª
    );
    
    
    // ×™×¦×™×¨×ª ×˜×§×¡×˜×•×¨×” ×œ×× ×”×¨×” ×‘×¡×’× ×•×Ÿ ×¨×˜×¨×• ×¡×’×œ×’×œ
    const createRetroTunnelTexture = () => {
        const textureSize = 1024;
        const canvas = document.createElement('canvas');
        canvas.width = textureSize;
        canvas.height = textureSize;
        const ctx = canvas.getContext('2d');
        
        // ×¦×‘×¢ ×¨×§×¢ ×¡×’×•×œ ×›×”×”
        ctx.fillStyle = '#2a1a3a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ×™×¦×™×¨×ª ×§×•×•×™ ×¨×©×ª × ×™××•×Ÿ ×‘×¡×’× ×•×Ÿ ×¨×˜×¨×•
        const gridSpacing = 64; // ××¨×•×•×— ×’×“×•×œ ×™×•×ª×¨ ×‘×™×Ÿ ×§×•×•×™ ×”×¨×©×ª
        const gridColor = '#9c3fd4'; // ×¡×’×•×œ × ×™××•× ×™ ×™×•×ª×¨
        
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 3;
        
        // ×¦×™×•×¨ ×§×•×•×™× ××•×¤×§×™×™×
        for (let y = 0; y < canvas.height; y += gridSpacing) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
            
            // ×”×•×¡×¤×ª ××¤×§×˜ ×–×•×”×¨ ×œ×§×•×•×™×
            ctx.strokeStyle = 'rgba(200, 120, 255, 0.5)';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
            
            // ×—×–×¨×” ×œ×¡×’× ×•×Ÿ ×”××§×•×¨×™
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 3;
        }
        
        // ×¦×™×•×¨ ×§×•×•×™× ×× ×›×™×™×
        for (let x = 0; x < canvas.width; x += gridSpacing) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
            
            // ×”×•×¡×¤×ª ××¤×§×˜ ×–×•×”×¨ ×œ×§×•×•×™×
            ctx.strokeStyle = 'rgba(200, 120, 255, 0.5)';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
            
            // ×—×–×¨×” ×œ×¡×’× ×•×Ÿ ×”××§×•×¨×™
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 3;
        }
        
        // ×”×•×¡×¤×ª × ×§×•×“×•×ª ×–×•×”×¨×•×ª ×‘×¡×’× ×•×Ÿ ×›×•×›×‘×™×
        for (let i = 0; i < 300; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 3 + 1;
            
            // ×¦×‘×¢ ×–×•×”×¨ ×‘×’×•×•× ×™× ×©×œ ×¡×’×•×œ/×•×¨×•×“
            const r = 200 + Math.random() * 55;
            const g = 50 + Math.random() * 100;
            const b = 200 + Math.random() * 55;
            
            // ×™×¦×™×¨×ª ×–×•×”×¨ ×‘×’×¨×“×™×× ×˜ ×¡×‘×™×‘ ×”× ×§×•×“×”
            const glow = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
            glow.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
            glow.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.3)`);
            glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(x, y, size * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // × ×§×•×“×” ××¨×›×–×™×ª ×‘×”×™×¨×” ×™×•×ª×¨
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ×”×•×¡×¤×ª ××œ×× ×˜×™× ×’×™××•××˜×¨×™×™× ×¨×˜×¨×• (××©×•×œ×©×™×/××¨×•×‘×¢×™×) ×‘×’×“×œ×™× ×©×•× ×™×
        for (let i = 0; i < 50; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 30 + 10;
            
            // ×¦×‘×¢ ×œ××œ× ×‘×’×•×•× ×™ ×¡×’×•×œ/×•×¨×•×“
            const r = 130 + Math.random() * 50;
            const g = 20 + Math.random() * 40;
            const b = 180 + Math.random() * 70;
            const a = 0.2 + Math.random() * 0.3;
            
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
            
            // ×‘×—×™×¨×” ××§×¨××™×ª ×‘×™×Ÿ ××©×•×œ×© ×•××¨×•×‘×¢
            if (Math.random() > 0.5) {
                // ××©×•×œ×©
                ctx.beginPath();
                ctx.moveTo(x, y - size / 2);
                ctx.lineTo(x - size / 2, y + size / 2);
                ctx.lineTo(x + size / 2, y + size / 2);
                ctx.closePath();
                ctx.fill();
                
                // ×§×• ×ª×•×—× ×–×•×”×¨
                ctx.strokeStyle = `rgba(255, 200, 255, 0.7)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            } else {
                // ××¨×•×‘×¢ ××¡×•×‘×‘ (×™×”×œ×•×)
                ctx.beginPath();
                ctx.moveTo(x, y - size / 2);
                ctx.lineTo(x + size / 2, y);
                ctx.lineTo(x, y + size / 2);
                ctx.lineTo(x - size / 2, y);
                ctx.closePath();
                ctx.fill();
                
                // ×§×• ×ª×•×—× ×–×•×”×¨
                ctx.strokeStyle = `rgba(255, 200, 255, 0.7)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        // ×™×¦×™×¨×ª ×˜×§×¡×˜×•×¨×” ××”×§× ×‘×¡
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(4, 8); // ×—×–×¨×” ×©×•× ×” ×‘××•×¤×§×™ ×•×× ×›×™
        
        return texture;
    };
    
    // ×™×¦×™×¨×ª ××¨×§× ×× ×”×¨×” ×¨×˜×¨×•
    const tunnelTexture = createRetroTunnelTexture();
    
    // ×™×¦×™×¨×ª ××˜×¨×™××œ ×œ×¦×™× ×•×¨
    const material = new THREE.MeshStandardMaterial({
        map: tunnelTexture,
        roughness: 0.7,
        metalness: 0.3,
        side: THREE.DoubleSide, 
        emissive: new THREE.Color(0x4d0099), // ××¤×§×˜ ×¤×œ×™×˜×” ×‘×’×•×•×Ÿ ×¡×’×•×œ
        emissiveIntensity: 0.2, // ×¢×•×¦××ª ×”×¤×œ×™×˜×”
        transparent: false
    });
    
    // ×™×¦×™×¨×ª ×”×× ×”×¨×”
    const tunnel = new THREE.Mesh(geometry, material);
    
    // ×—×™×©×•×‘ ×•×”×’×“×¨×ª ×”×¡×™×‘×•×‘ ×©×œ ×”×× ×”×¨×”
    // ×”×¦×™×œ×™× ×“×¨ ××™×•×¦×¨ ×œ××•×¨×š ×¦×™×¨ ×”-Y, ××– ×× ×—× ×• ×¦×¨×™×›×™× ×œ×¡×•×‘×‘ ××•×ª×•
    // ×›×“×™ ×©×™×”×™×” ×‘×›×™×•×•×Ÿ ×”× ×›×•×Ÿ
    
    // ×—×™×©×•×‘ ×”× ×•×¨××œ ×©×œ ×”×›×™×•×•×Ÿ
    direction.normalize();
    
    // ×”×’×“×¨×ª ×•×§×˜×•×¨ ×™×™×—×•×¡ - ×‘×“×¨×š ×›×œ×œ ×¦×™×¨ ×”-Y
    const yAxis = new THREE.Vector3(0, 1, 0);
    
    // ×—×™×©×•×‘ ×”×§×•×•×˜×¨× ×™×•×Ÿ ×œ×”×¡×ª×•×‘×‘×•×ª ××¦×™×¨ ×”-Y ×œ×›×™×•×•×Ÿ ×©×œ× ×•
    const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction);
    tunnel.setRotationFromQuaternion(quaternion);
    
    // ××™×§×•× ×”×× ×”×¨×” - ×‘×××¦×¢ ×‘×™×Ÿ × ×§×•×“×ª ×”×”×ª×—×œ×” ×•×”×¡×™×•×
    const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
    tunnel.position.copy(midPoint);
    
    // ×”×•×¡×¤×ª ×¦×œ×œ×™×
    tunnel.castShadow = true;
    tunnel.receiveShadow = true;
    
    // ×”×•×¡×¤×ª ×”×× ×”×¨×” ×œ×¡×¦× ×”
    scene.add(tunnel);
    
    // ×©××™×¨×ª ×”×× ×”×¨×” ×œ××©×ª× ×” ×”×’×œ×•×‘×œ×™
    tunnelObject = tunnel;
    
    // ×™×¦×™×¨×ª ×§×•×œ×™×“×¨×™× ×œ×§×™×¨×•×ª ×”×× ×”×¨×”
    createTunnelColliders(startPoint, endPoint, tunnelRadius);
    
    // ×”×•×¡×¤×ª ××•×¨×•×ª ×‘×ª×•×š ×”×× ×”×¨×” ×‘×¡×’× ×•×Ÿ ×¨×˜×¨×•
    addRetroTunnelLights(tunnel, tunnelLength, startPoint, endPoint);
    
    return tunnel;
};
const addRetroTunnelLights = (tunnel, tunnelLength, startPoint, endPoint) => {
    // ××¡×¤×¨ ×”××•×¨×•×ª ×œ××•×¨×š ×”×× ×”×¨×”
    const numLights = 20; // ×”×’×“×œ× ×• ××ª ××¡×¤×¨ ×”××•×¨×•×ª ×œ××•×¨×š ×”×× ×”×¨×” ×”××¨×•×›×” ×™×•×ª×¨
    // ×—×™×©×•×‘ ×”×•×§×˜×•×¨ ×‘×™×Ÿ × ×§×•×“×ª ×”×”×ª×—×œ×” ×œ× ×§×•×“×ª ×”×¡×™×•×
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    // ××¨×—×§ ×‘×™×Ÿ ×”××•×¨×•×ª
    const spacing = tunnelLength / numLights;
    
    // ×¦×‘×¢×™× × ×™××•×Ÿ ××ª×—×œ×¤×™× ×œ×¡×’× ×•×Ÿ ×¨×˜×¨×•
    const retroColors = [
        0xff00ff, // ××’'× ×˜×”
        0x9932CC, // ×¡×’×•×œ ×›×”×”
        0xff1493, // ×•×¨×•×“ ×¢××•×§
        0x8a2be2, // ×›×—×•×œ-×¡×’×•×œ
        0x9400d3  // ×¡×’×•×œ ×›×”×”
    ];
    
    // ×™×¦×™×¨×ª ××•×¨×•×ª ×œ××•×¨×š ×”×× ×”×¨×”
    for (let i = 0; i < numLights; i++) {
        // ××™×§×•× ×”××•×¨ ×›× ×§×•×“×” ×¢×œ ×”×§×• ×‘×™×Ÿ × ×§×•×“×ª ×”×”×ª×—×œ×” ×œ× ×§×•×“×ª ×”×¡×™×•×
        const ratio = (i * spacing) / tunnelLength;
        const lightPosition = new THREE.Vector3()
            .copy(startPoint)
            .lerp(endPoint, ratio);
        
        // ×”×–×–×ª ×”××•×¨ ×œ×¦×“×“×™× ×•×œ××¢×œ×” ×œ××¤×§×˜ ××¢× ×™×™×Ÿ ×™×•×ª×¨
        const offset = 6.5; // ×”×’×“×œ×ª ×”××¨×—×§ ××”××¨×›×– ×œ×”×ª××™× ×œ×× ×”×¨×” ×”×¨×—×‘×” ×™×•×ª×¨
        const side = i % 2 === 0 ? 1 : -1; // ×¦×“ ×™××™×Ÿ ××• ×©×××œ ×œ×¡×™×¨×•×’×™×Ÿ
        
        // ×—×™×©×•×‘ ×•×§×˜×•×¨ × ×™×¦×‘ ×œ×›×™×•×•×Ÿ ×”×× ×”×¨×”
        const normalizedDirection = direction.clone().normalize();
        const perpendicular = new THREE.Vector3();
        
        if (Math.abs(normalizedDirection.y) < 0.99) {
            perpendicular.set(0, 1, 0);
        } else {
            perpendicular.set(1, 0, 0);
        }
        perpendicular.cross(normalizedDirection).normalize();
        
        // ×”×–×–×ª ×”××•×¨ ×œ×¦×“ ×”××ª××™× ×©×œ ×”×× ×”×¨×” ×•××¢×˜ ×œ××¢×œ×”
        lightPosition.add(perpendicular.clone().multiplyScalar(side * offset * 0.7));
        // ×”×’×‘×”×ª ×”××•×¨×•×ª ××¢×˜ ×™×•×ª×¨
        lightPosition.y += 3 + Math.sin(i) * 1.5; // ×•×¨×™××¦×™×” ×’×“×•×œ×” ×™×•×ª×¨ ×‘×’×•×‘×”
        
        // ××•×¨ × ×§×•×“×ª×™ ×‘×¦×‘×¢ × ×™××•×Ÿ
        const colorIndex = i % retroColors.length;
        const light = new THREE.PointLight(retroColors[colorIndex], 0.6, 8);
        light.position.copy(lightPosition);
        scene.add(light);
        
        // ×’×•×¤×™ ×ª××•×¨×” ×•×™×–×•××œ×™×™× - ×¡×¤×™×¨×•×ª ×§×˜× ×•×ª ×¢× ××¤×§×˜ ×–×•×”×¨
        const bulbGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const bulbMaterial = new THREE.MeshBasicMaterial({ 
            color: retroColors[colorIndex],
            transparent: true,
            opacity: 0.9
        });
        const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
        bulb.position.copy(light.position);
        scene.add(bulb);
        
        // ×”×•×¡×¤×ª ×”×™×œ×” ××¡×‘×™×‘ ×œ××•×¨
        const glowGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({ 
            color: retroColors[colorIndex],
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.copy(light.position);
        scene.add(glow);
        
        // ×”×•×¡×¤×ª ×¨×™×‘×•×¢×™×/××¢×•×™× ×™× × ×™××•×Ÿ ×‘×¡×’× ×•×Ÿ ×¨×˜×¨×• ×œ××•×¨×š ×”×× ×”×¨×”
        if (i % 3 === 0) { // ××¡×¤×¨ ××•×¢×˜ ×©×œ ××œ×× ×˜×™× ×“×§×•×¨×˜×™×‘×™×™×
            const size = 0.5 + Math.random() * 0.3;
            
            // ×™×¦×™×¨×ª ×¦×•×¨×” ×’×™××•××˜×¨×™×ª
            const shapeGeometry = new THREE.PlaneGeometry(size, size);
            const shapeMaterial = new THREE.MeshBasicMaterial({ 
                color: retroColors[(colorIndex + 2) % retroColors.length],
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const shape = new THREE.Mesh(shapeGeometry, shapeMaterial);
            
            // ××™×§×•× ×”×¦×•×¨×” ××¢×˜ ×”×¦×™×“×” ××”××•×¨
            const shapePosition = lightPosition.clone();
            shapePosition.add(perpendicular.clone().multiplyScalar(side * -1 * 0.8)); // ×¦×“ ×”×¤×•×š ××”××•×¨
            shape.position.copy(shapePosition);
            
            // ×¡×™×‘×•×‘ ××§×¨××™ ×œ×¦×•×¨×”
            shape.rotation.z = Math.PI / 4; // ×¡×™×‘×•×‘ ×‘-45 ××¢×œ×•×ª
            shape.rotation.y = Math.random() * Math.PI;
            
            scene.add(shape);
        }
    }
    
    // ×”×•×¡×¤×ª ××•×¨ ×¡×’×•×œ ××ª×¤×©×˜ ×‘××–×•×¨ ×”×›× ×™×¡×” ×œ×× ×”×¨×”
    const entranceLight = new THREE.PointLight(0x9400d3, 1, 10);
    entranceLight.position.copy(startPoint);
    entranceLight.position.y += 1;
    scene.add(entranceLight);
    
    // ×”×•×¡×¤×ª ××•×¨ ×¡×’×•×œ ××ª×¤×©×˜ ×‘××–×•×¨ ×”×™×¦×™××” ××”×× ×”×¨×”
    const exitLight = new THREE.PointLight(0xff00ff, 1, 10);
    exitLight.position.copy(endPoint);
    exitLight.position.y += 1;
    scene.add(exitLight);
};

        // ×”×•×¡×¤×ª ××•×¨×•×ª ×œ××•×¨×š ×”×× ×”×¨×”
        const addTunnelLights = (tunnel, tunnelLength, startPoint, endPoint) => {
            // ××¡×¤×¨ ×”××•×¨×•×ª ×œ××•×¨×š ×”×× ×”×¨×”
            const numLights = 10;
            // ×—×™×©×•×‘ ×”×•×§×˜×•×¨ ×‘×™×Ÿ × ×§×•×“×ª ×”×”×ª×—×œ×” ×œ× ×§×•×“×ª ×”×¡×™×•×
            const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
            // ××¨×—×§ ×‘×™×Ÿ ×”××•×¨×•×ª
            const spacing = tunnelLength / numLights;
            
            // ×™×¦×™×¨×ª ××•×¨×•×ª ×œ××•×¨×š ×”×× ×”×¨×”
            for (let i = 0; i < numLights; i++) {
                // ××™×§×•× ×”××•×¨ ×›× ×§×•×“×” ×¢×œ ×”×§×• ×‘×™×Ÿ × ×§×•×“×ª ×”×”×ª×—×œ×” ×œ× ×§×•×“×ª ×”×¡×™×•×
                const ratio = (i * spacing) / tunnelLength;
                const lightPosition = new THREE.Vector3()
                    .copy(startPoint)
                    .lerp(endPoint, ratio);
                
                // ×”×–×–×ª ×”××•×¨ ×›×œ×¤×™ ××¢×œ×” ×‘××¢×˜ ×›×“×™ ×©×™×”×™×” ××¢×œ ×¨××© ×”×©×—×§×Ÿ
                lightPosition.y += 0.5;
                
                // ××•×¨ × ×§×•×“×ª×™
                const light = new THREE.PointLight(0xffffcc, 0.3, 5);
                light.position.copy(lightPosition);
                scene.add(light);
                
                // ×’×•×¤×™ ×ª××•×¨×” ×•×™×–×•××œ×™×™× - ×¡×¤×™×¨×•×ª ×§×˜× ×•×ª
                const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const bulbMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffee,
                    transparent: true,
                    opacity: 0.8
                });
                const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
                bulb.position.copy(light.position);
                scene.add(bulb);
            }
        };
        
        // ×™×¦×™×¨×ª ××¢×¨×›×ª ×©×œ×™×˜×” ×‘×’×•×£ ×¨××©×•×Ÿ
        const setupFirstPersonControls = () => {
            controls = new THREE.FirstPersonControls(camera, renderer.domElement);
            controls.movementSpeed = 4;
            controls.lookSpeed = 0.03; // ×”×•×¨×“×ª ×”×¨×’×™×©×•×ª ×-0.1 ×œ-0.05
            controls.lookVertical = true;
            controls.constrainVertical = true;
            controls.verticalMin = Math.PI / 6; // ×”×’×‘×œ×ª ××‘×˜ ×œ××¢×œ×”
            controls.verticalMax = Math.PI / 1.8; // ×”×’×‘×œ×ª ××‘×˜ ×œ××˜×”
            
            // ×”×’×“×¨×ª ××–×•×¨ ××ª ×‘×§×¦×•×•×ª ×”××¡×š ×©×™×¢×¦×•×¨ ××ª ×”×ª×–×•×–×”
            const boundaryThreshold = 0.05; // 5% ××”×§×¦×” (95% ××”××¡×š ×¤×¢×™×œ)
            
            // ×”××–× ×” ×œ×ª×–×•×–×ª ×”×¢×›×‘×¨
            document.addEventListener('mousemove', (e) => {
                const mouseX = e.clientX / window.innerWidth;
                const mouseY = e.clientY / window.innerHeight;
                
                // ×‘×“×™×§×” ×× ×”×¢×›×‘×¨ × ××¦× ×‘××–×•×¨ ×”××ª (×§×¨×•×‘ ×œ×§×¦×•×•×ª)
                const isNearLeftEdge = mouseX < boundaryThreshold;
                const isNearRightEdge = mouseX > (1 - boundaryThreshold);
                const isNearTopEdge = mouseY < boundaryThreshold;
                const isNearBottomEdge = mouseY > (1 - boundaryThreshold);
                
                // ×¢×¦×™×¨×ª ×”×ª×–×•×–×” ×× ×”×¢×›×‘×¨ ×‘×§×¦×•×•×ª
                if (isNearLeftEdge || isNearRightEdge || isNearTopEdge || isNearBottomEdge) {
                    if (controls.activeLook !== false) {
                        controls.activeLook = false;
                    }
                } else {
                    if (controls.activeLook !== true) {
                        controls.activeLook = true;
                    }
                }
            });
        };
        
        // ×˜×¢×™× ×ª ××•×“×œ GLB (×¨×§ tunnel.glb)
        const loadTunnelModel = () => {
    const loader = new THREE.GLTFLoader();
    
    // ×”×¦×’×ª ×”×•×“×¢×ª ×˜×¢×™× ×”
    document.getElementById('loading').style.display = 'block';
    document.getElementById('loading').textContent = '×˜×•×¢×Ÿ ××ª ×”××•×“×œ...';
    
    loader.load(
        '3d/lab.glb',
        (gltf) => {
            const model = gltf.scene;
            
            // ×”×’×“×¨×ª ×¦×œ×œ×™× ×œ×›×œ ×”××©×™× ×‘××•×“×œ
            model.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // ×”×™×¤×•×š ×”× ×•×¨××œ×™× ×× ×–×” ×œ× ××•×“×œ ×©×”×•×¢×œ×” ×¢×œ-×™×“×™ ×”××©×ª××©

                }
            });
            
            // ×©××™×¨×” ×¢×œ ×”×¡×§×™×™×œ ×•×”××™×§×•× ×”××§×•×¨×™×™× ×©×œ ×”××•×“×œ
            model.scale.set(8, 4, 8);
            model.position.set(0, 10, 0); // ×©××™×¨×” ×¢×œ ×”×’×•×‘×” ×”××§×•×¨×™
            model.rotation.z = Math.PI * -0.07; 
            // ×©××™×¨×ª ×”××•×“×œ ×œ××©×ª× ×” ×”×’×œ×•×‘×œ×™
            worldModel = model;
            
            scene.add(model);
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;
        },
        (xhr) => {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            document.getElementById('loading').textContent = 
                `×˜×•×¢×Ÿ ××ª ×”××•×“×œ... ${Math.round(percentComplete)}%`;
        },
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª ×”××•×“×œ:', error);
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;
        }
    );
};
        // ×˜×¢×™× ×ª ×”×©×•×œ×—×Ÿ ×•×”××—×©×‘×™×
// ×˜×¢×™× ×ª ×”×©×•×œ×—×Ÿ ×•×”××—×©×‘×™× - ××¢×•×“×›×Ÿ
const loadFurniture = () => {
    const loader = new THREE.GLTFLoader();
    
    // ×˜×¢×™× ×ª ×”×©×•×œ×—×Ÿ
    loader.load(
        '3d/table.glb',
        (gltf) => {
            const table = gltf.scene;
            table.visible = false;
            // ×”×’×“×¨×ª ×¦×œ×œ×™× ×œ×©×•×œ×—×Ÿ
            table.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // ×¡×™××•×Ÿ ×”×©×•×œ×—×Ÿ ×œ×¦×•×¨×š ×”×¡×ª×¨×” ×‘×¢×ª×™×“
            table.userData.isTable = true;
            
            // ××™×§×•× ×”×©×•×œ×—×Ÿ
            table.position.set(-0.28, -1, -0.60);
            table.scale.set(3, 3, 3);
            table.rotation.y = Math.PI / 2;
            scene.add(table);
            
            // ××—×¨×™ ×©×”×©×•×œ×—×Ÿ × ×˜×¢×Ÿ, × ×˜×¢×Ÿ ××ª ×”××—×©×‘×™× ×©×¦×¨×™×›×™× ×œ×”×™×•×ª ××¢×œ×™×•
            loadComputers(table);
        },
        (xhr) => {
            console.log('×˜×¢×™× ×ª ×©×•×œ×—×Ÿ: ' + (xhr.loaded / xhr.total * 100) + '% ×˜×¢×•×Ÿ');
        },
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×©×•×œ×—×Ÿ:', error);
        }
    );
};

// ×˜×¢×™× ×ª ×”××—×©×‘×™× - ××¢×•×“×›×Ÿ
const loadComputers = (table) => {
    const loader = new THREE.GLTFLoader();
    
    // ×—×™×©×•×‘ ×’×•×‘×” ×”×©×•×œ×—×Ÿ ×œ×¦×•×¨×š ×”×¦×‘×ª ×”××—×©×‘×™×
    const tableHeight = 0.75; 
    
    // ×˜×¢×™× ×ª ×”××—×©×‘ ×”×™×©×Ÿ
    loader.load(
        '3d/oldComputer.glb',
        (gltf) => {
            const oldComputer = gltf.scene;
            oldComputer.visible = false;
            oldComputer.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // ×¡×™××•×Ÿ ×”××—×©×‘ ×”×™×©×Ÿ
            oldComputer.userData.isOldComputer = true;
            oldComputer.rotation.y = Math.PI / 2;
            // ××™×§×•× ×”××—×©×‘ ×”×™×©×Ÿ ×‘××¨×›×– ×”×©×•×œ×—×Ÿ
            oldComputer.position.set(0.27, tableHeight+0.6, -1.89);
            oldComputer.scale.set(1.2, 1.2, 1.2);
            
            scene.add(oldComputer);
        },
        (xhr) => {
            console.log('×˜×¢×™× ×ª ××—×©×‘ ×™×©×Ÿ: ' + (xhr.loaded / xhr.total * 100) + '% ×˜×¢×•×Ÿ');
        },
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª ×”××—×©×‘ ×”×™×©×Ÿ:', error);
        }
    );
    
    // ×˜×¢×™× ×ª ×”××—×©×‘ ×”×—×“×©
    loader.load(
        '3d/newComputer.glb',
        (gltf) => {
            const newComputer = gltf.scene;
            newComputer.visible = false;
            newComputer.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // ×”×‘×”×¨×ª ×”×—×•××¨×™×
                    if (node.material) {
                        if (!Array.isArray(node.material)) {
                            node.material.color.multiplyScalar(2.0);
                            node.material.emissive = new THREE.Color(0x333333);
                            if (node.material.roughness !== undefined) node.material.roughness = 0.3;
                            if (node.material.metalness !== undefined) node.material.metalness = 0.7;
                        } else {
                            node.material.forEach(mat => {
                                mat.color.multiplyScalar(2.0);
                                mat.emissive = new THREE.Color(0x333333);
                                if (mat.roughness !== undefined) mat.roughness = 0.3;
                                if (mat.metalness !== undefined) mat.metalness = 0.7;
                            });
                        }
                    }
                }
            });
            
            // ×¡×™××•×Ÿ ×”××—×©×‘ ×”×—×“×©
            newComputer.userData.isNewComputer = true;
            newComputer.rotation.y = Math.PI / 2;
            // ××™×§×•× ×”××—×©×‘ ×”×—×“×© ×œ×¦×“ ×”××—×©×‘ ×”×™×©×Ÿ
            newComputer.position.set(0.15, tableHeight+0.6, 0.71);
            newComputer.scale.set(1.2, 1.2, 1.2);
            
            // ×”×•×¡×¤×ª ××•×¨ ××™×•×—×“ ×œ××—×©×‘ ×”×—×“×©
            const computerLight = new THREE.PointLight(0xFFFFFF, 1.5, 3);
            computerLight.position.set(7.80, tableHeight+1.2, 0.06);
            scene.add(computerLight);
            
            scene.add(newComputer);
        },
        (xhr) => {
            console.log('×˜×¢×™× ×ª ××—×©×‘ ×—×“×©: ' + (xhr.loaded / xhr.total * 100) + '% ×˜×¢×•×Ÿ');
        },
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª ×”××—×©×‘ ×”×—×“×©:', error);
        }
    );
};
        // ×—×–×¨×” ×œ×¢×•×œ×
        document.getElementById('back-button').addEventListener('click', () => {
            document.getElementById('next-screen').style.display = 'none';
            controls.enabled = true; // ×”×¤×¢×œ×ª ×”×©×œ×™×˜×” ××—×“×©
        });
        
        // ×”×ª×××ª ×’×•×“×œ ×”×—×œ×•×Ÿ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (controls) {
                controls.handleResize();
            }
        });
        
        // ×”×’×“×¨×ª ×¡××•× ×“ ×œ×”×œ×™×›×”
        const setupWalkSound = () => {
    // ×™×¦×™×¨×ª ××•×‘×™×™×§×˜ ×¡××•× ×“ ×œ×”×œ×™×›×” ×¢× ×”××•×¤×¦×™×” ×œ×”×¤×¢×œ×” ×—×•×–×¨×ª (loop)
    walkSound = new Howl({
        src: ['audio/walk.mp3'],
        loop: true,
        volume: 0.7
    });
            
            // ×”×•×¡×¤×ª ×××–×™×Ÿ ×œ××™×¨×•×¢ ×œ×—×™×¦×” ×¢×œ ×›×¤×ª×•×¨ ×”×¢×›×‘×¨
            document.addEventListener('mousedown', (e) => {
                // ×‘×“×™×§×” ×× ×œ×—×¥ ×›×¤×ª×•×¨ ×©×××œ×™ (0) ××• ×™×× ×™ (2)
                if ((e.button === 0 || e.button === 2) && !isWalking) {
                    walkSound.play();
                    isWalking = true;
                }
            });
            
            // ×”×•×¡×¤×ª ×××–×™×Ÿ ×œ××™×¨×•×¢ ×©×—×¨×•×¨ ×›×¤×ª×•×¨ ×”×¢×›×‘×¨
            document.addEventListener('mouseup', (e) => {
                // ×‘×“×™×§×” ×× ×©×•×—×¨×¨ ×›×¤×ª×•×¨ ×©×××œ×™ (0) ××• ×™×× ×™ (2)
                if ((e.button === 0 || e.button === 2) && isWalking) {
                    walkSound.pause();
                    isWalking = false;
                }
            });
            
            // ×× ×™×¢×ª ×ª×¤×¨×™×˜ ×§×œ×™×§ ×™×× ×™
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        };
        const areModelsVisible = () => {
    let visible = true;
    
    scene.traverse((object) => {
        if (object.userData && (object.userData.isTable || 
            object.userData.isOldComputer || 
            object.userData.isNewComputer)) {
            if (!object.visible) {
                visible = false;
            }
        }
    });
    
    return visible;
};
// ×¤×•× ×§×¦×™×” ×œ×”×¦×’×ª ××•×“×œ ×”×¡×¨×˜×•×Ÿ
const setupVideoModal = () => {
    const videoModal = document.getElementById('video-modal');
    const introVideo = document.getElementById('intro-video');
    const closeBtn = document.getElementById('close-video-modal');
    
    // ×”×¦×’×ª ×”××•×“×œ ××—×¨×™ 3 ×©× ×™×•×ª
    setTimeout(() => {
        videoModal.style.display = 'flex';
        
        // ×¢×¦×™×¨×ª ×”×ª× ×•×¢×” ×•×”×¦×œ×™×œ
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
        
        // ×”×©×‘×ª ×©×œ×™×˜×” ×‘×–××Ÿ ×”×¦×’×ª ×”×¡×¨×˜×•×Ÿ
        if (controls) {
            controls.enabled = false;
        }
        
        // ×”×¤×¢×œ×ª ×”×¡×¨×˜×•×Ÿ ××•×˜×•××˜×™×ª
        introVideo.play();
        
        // ×”×•×¡×¤×ª ×××–×™×Ÿ ×œ×¡×™×•× ×”×¡×¨×˜×•×Ÿ
        introVideo.addEventListener('ended', () => {
            closeVideoAndShowMission();
        });
        
        // ×”×•×¡×¤×ª ×××–×™×Ÿ ×œ×›×¤×ª×•×¨ ×”×¡×’×™×¨×”
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                closeVideoAndShowMission();
            });
        }
    }, 3000); // 3 ×©× ×™×•×ª
};

// ×¤×•× ×§×¦×™×” ×œ×¡×’×™×¨×ª ×”×¡×¨×˜×•×Ÿ ×•×”×¦×’×ª ×”××©×™××”
const closeVideoAndShowMission = () => {
    const videoModal = document.getElementById('video-modal');
    const introVideo = document.getElementById('intro-video');
    const missionPopup = document.getElementById('mission-popup');
    
    // ×¢×¦×™×¨×ª ×”×¡×¨×˜×•×Ÿ
    introVideo.pause();
    
    // ×¡×’×™×¨×ª ×”××•×“×œ
    videoModal.style.display = 'none';
    
    // ×”×—×–×¨×ª ×”×©×œ×™×˜×” ×œ××©×ª××©
    if (controls) {
        controls.enabled = true;
    }
    
    // ×•×™×“×•× ×©×”×ª× ×•×¢×” ××•×¤×¡×§×ª
    if (controls) {
        controls.moveForward = false;
        controls.moveBackward = false;
    }
    movingForward = false;
    movingBackward = false;
    
    // ×”×¦×’×ª ×”××©×™××” ××—×¨×™ ×©× ×™×”
    setTimeout(() => {
        if (missionPopup) {
            missionPopup.style.opacity = '1';
            missionPopup.style.transition = 'opacity 1.5s ease-out';
        }
    }, 1000);
};

// ×¤×•× ×§×¦×™×” ×œ×˜×¢×™× ×ª ××•×“×œ×™ ×”×“××•×™×•×ª
const loadCharacterModels = () => {
    const loader = new THREE.GLTFLoader();
    
    // ×˜×¢×™× ×ª ××•×“×œ yossi
    loader.load(
        '3d/yossi.glb',
        (gltf) => {
            yossiModel = gltf.scene;
            
            // ×”×’×“×¨×ª ×¦×œ×œ×™×
            yossiModel.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // ×¡×™××•×Ÿ ×”××•×“×œ ×›×“××•×ª
            yossiModel.userData.isCharacter = true;
            
            // ××™×§×•× ××•×“×œ yossi ×œ×™×“ ×”×©×•×œ×—×Ÿ
            yossiModel.position.set(4.4, -0.5, -5.64);  // ××™××™×Ÿ ×œ×©×•×œ×—×Ÿ
            yossiModel.scale.set(2, 2, 2);
            yossiModel.rotation.y = Math.PI / 2; // ×¤×•× ×” ××¢×˜ ×¤× ×™××”
            
            // ×”×¡×ª×¨×ª ×”××•×“×œ ×‘×”×ª×—×œ×”
            yossiModel.visible = false;
            
            scene.add(yossiModel);
            console.log('××•×“×œ yossi × ×˜×¢×Ÿ ×‘×”×¦×œ×—×”');
        },
        (xhr) => {
            console.log('×˜×¢×™× ×ª yossi: ' + (xhr.loaded / xhr.total * 100) + '% ×˜×¢×•×Ÿ');
        },
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª yossi:', error);
        }
    );
    
    // ×˜×¢×™× ×ª ××•×“×œ jordan
    loader.load(
        '3d/jordan.glb',
        (gltf) => {
            jordanModel = gltf.scene;
            
            // ×”×’×“×¨×ª ×¦×œ×œ×™×
            jordanModel.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // ×¡×™××•×Ÿ ×”××•×“×œ ×›×“××•×ª
            jordanModel.userData.isCharacter = true;
            
            // ××™×§×•× ××•×“×œ jordan ×‘×—×œ×§ ×”××—×•×¨×™ ×©×œ ×”×©×•×œ×—×Ÿ
            jordanModel.position.set(3.6, -0.9, 3.8);  // ×××—×•×¨×™ ×”×©×•×œ×—×Ÿ
            jordanModel.scale.set(1.5, 1.5, 1.5);
            jordanModel.rotation.y = Math.PI * 0.5;  // ×¤×•× ×” ××¢×˜ ×”×—×•×¦×”
            
            // ×”×¡×ª×¨×ª ×”××•×“×œ ×‘×”×ª×—×œ×”
            jordanModel.visible = false;
            
            scene.add(jordanModel);
            console.log('××•×“×œ jordan × ×˜×¢×Ÿ ×‘×”×¦×œ×—×”');
        },
        (xhr) => {
            console.log('×˜×¢×™× ×ª jordan: ' + (xhr.loaded / xhr.total * 100) + '% ×˜×¢×•×Ÿ');
        },
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª jordan:', error);
        }
    );
    
    // ×˜×¢×™× ×ª ××•×“×œ omer
    loader.load(
        '3d/omer.glb',
        (gltf) => {
            omerModel = gltf.scene;
            
            // ×”×’×“×¨×ª ×¦×œ×œ×™×
            omerModel.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // ×¡×™××•×Ÿ ×”××•×“×œ ×›×“××•×ª
            omerModel.userData.isCharacter = true;
            
            // ××™×§×•× ××•×“×œ omer ×‘×¦×“ ×”×©×××œ×™ ×©×œ ×”×©×•×œ×—×Ÿ
            omerModel.position.set(4.3, -0.9, 6.62);  // ××©×××œ ×œ×©×•×œ×—×Ÿ
            omerModel.scale.set(1.5, 1.5, 1.5);
            omerModel.rotation.y = Math.PI * 0.5;  // ×¤×•× ×” ××¢×˜ ×¤× ×™××”
            
            // ×”×¡×ª×¨×ª ×”××•×“×œ ×‘×”×ª×—×œ×”
            omerModel.visible = false;
            
            scene.add(omerModel);
            console.log('××•×“×œ omer × ×˜×¢×Ÿ ×‘×”×¦×œ×—×”');
        },
        (xhr) => {
            console.log('×˜×¢×™× ×ª omer: ' + (xhr.loaded / xhr.total * 100) + '% ×˜×¢×•×Ÿ');
        },
        (error) => {
            console.error('×©×’×™××” ×‘×˜×¢×™× ×ª omer:', error);
        }
    );
};
// ×”×•×¡×£ ××©×ª× ×” ×’×œ×•×‘×œ×™ ×œ×¢×§×•×‘ ××—×¨×™ ××¦×‘ ×”×ª× ×•×¢×”
let movingForward = false;
let movingBackward = false;

// ×©×›×ª×‘ ××ª ×”×”××–× ×” ×œ××™×¨×•×¢×™ ×”×¢×›×‘×¨
const setupMovementControls = () => {
    // ×”×•×¡×¤×ª ×××–×™×Ÿ ×œ××™×¨×•×¢ ×œ×—×™×¦×” ×¢×œ ×›×¤×ª×•×¨ ×”×¢×›×‘×¨
    document.addEventListener('mousedown', (e) => {
        // ×‘×“×™×§×” ×× ×œ×—×¥ ×›×¤×ª×•×¨ ×©×××œ×™ (0)
        if (e.button === 0) {
            movingForward = true;
            if (controls) controls.moveForward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
        // ×‘×“×™×§×” ×× ×œ×—×¥ ×›×¤×ª×•×¨ ×™×× ×™ (2)
        else if (e.button === 2) {
            movingBackward = true;
            if (controls) controls.moveBackward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
    });
    
    // ×”×•×¡×¤×ª ×××–×™×Ÿ ×œ××™×¨×•×¢ ×©×—×¨×•×¨ ×›×¤×ª×•×¨ ×”×¢×›×‘×¨
    document.addEventListener('mouseup', (e) => {
        // ×‘×“×™×§×” ×× ×©×•×—×¨×¨ ×›×¤×ª×•×¨ ×©×××œ×™ (0)
        if (e.button === 0) {
            movingForward = false;
            if (controls) controls.moveForward = false;
            
            // ×¢×•×¦×¨ ×¦×œ×™×œ ×¨×§ ×× ×’× ×§×“×™××” ×•×’× ××—×•×¨×” ×œ× ×¤×¢×™×œ×™×
            if (isWalking && !movingBackward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
        // ×‘×“×™×§×” ×× ×©×•×—×¨×¨ ×›×¤×ª×•×¨ ×™×× ×™ (2)
        else if (e.button === 2) {
            movingBackward = false;
            if (controls) controls.moveBackward = false;
            
            // ×¢×•×¦×¨ ×¦×œ×™×œ ×¨×§ ×× ×’× ×§×“×™××” ×•×’× ××—×•×¨×” ×œ× ×¤×¢×™×œ×™×
            if (isWalking && !movingForward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // ×¢×¦×™×¨×ª ×ª× ×•×¢×” ××•×˜×•××˜×™×ª ×›×©×¢×•×–×‘×™× ××ª ×”×¢××•×“ ××• ×¢×•×‘×¨×™× ×œ×œ×©×•× ×™×ª ××—×¨×ª
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            // ×× ×”×¢××•×“ ×”×•×¡×ª×¨, ×¢×¦×•×¨ ××ª ×›×œ ×”×ª× ×•×¢×”
            if (controls) {
                controls.moveForward = false;
                controls.moveBackward = false;
            }
            movingForward = false;
            movingBackward = false;
            
            if (isWalking && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // ×¢×¦×™×¨×ª ×ª× ×•×¢×” ×›×©×¢×•×–×‘×™× ××ª ×”×¢××•×“
    window.addEventListener('beforeunload', () => {
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
    });
    
    // ×× ×™×¢×ª ×ª×¤×¨×™×˜ ×§×œ×™×§ ×™×× ×™
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
};
const init = () => {
    // ×”×’×“×¨×ª ×ª××•×¨×”
    setupLighting();
    
    // ×™×¦×™×¨×ª ×§×¨×§×¢ ×©×˜×•×—×”
    createFlatRoadGround();
    
    // ×”×’×“×¨×ª ×©×œ×™×˜×” ×‘×’×•×£ ×¨××©×•×Ÿ
    setupFirstPersonControls();
    
    // ×”×’×“×¨×ª ×¡××•× ×“ ×œ×”×œ×™×›×”
    setupWalkSound();
    
    // ×”×•×¡×¤×ª ×‘×§×¨×•×ª ×ª× ×•×¢×” ××©×•×¤×¨×•×ª
    setupMovementControls();
    
    // ×”×ª×§× ×ª ××•×“××œ ×”××—×©×‘
    setupComputerModal();
    
    // ×™×¦×™×¨×ª ××¤×§×˜ ×¤×•×¨×˜×œ ×¢× ×¢×©×Ÿ ×¡×’×•×œ
    createPortalEffect();
    
    // ××™×§×•× ×”×©×—×§×Ÿ ×‘× ×§×•×“×ª ×”×”×ª×—×œ×”
    camera.position.set(1.12, PLAYER_HEIGHT, 7.13);
    addGameImage();
    
    // ×”×¦×’×ª ××•×“×œ ×”×¡×¨×˜×•×Ÿ
    setupVideoModal();
    
    // ×˜×¢×™× ×ª ××•×“×œ×™×
    loadTunnelModel();
    loadFurniture();
    loadNewPcModel(); // ×˜×¢×™× ×ª ×”××•×“×œ ×”×—×“×©
    loadCharacterModels(); // ×˜×¢×™× ×ª ××•×“×œ×™ ×”×“××•×™×•×ª
    // ×•×™×“×•× ×©×”××•×“×œ×™× ××™× × ×’×œ×•×™×™× ×‘×”×ª×—×œ×”
    ensureModelsHidden();
    
    // ×˜×™×™××¨ ×œ×˜×¢×™× ×”
    setTimeout(() => {
        if (document.getElementById('loading').style.display !== 'none') {
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;
        }
    }, 5000);
    
    // ×”×ª×—×œ×ª ×œ×•×œ××ª ×”×× ×™××¦×™×”
    animate();
};

// ×¤×•× ×§×¦×™×” ×—×“×©×” ×©××•×•×“××ª ×©×”××•×“×œ×™× ××•×¡×ª×¨×™×
function ensureModelsHidden() {
    // ××¡×ª×™×¨×” ××ª ×”××•×“×œ×™× ×’× ×× × ×˜×¢× ×• ×¢× visible=true
    setTimeout(() => {
        scene.traverse((object) => {
            if (object.userData && (object.userData.isTable || 
                object.userData.isOldComputer || 
                object.userData.isNewComputer ||
                object.userData.isCharacter)) {  // ×”×•×¡×¤× ×• ××ª ×”×“××•×™×•×ª
                object.visible = false;
            }
        });
    }, 1000); // ×§×¦×ª ×–××Ÿ ××—×¨×™ ×˜×¢×™× ×” ×œ×”×‘×˜×™×— ×©×”××•×“×œ×™× ××›×Ÿ × ×˜×¢× ×•
}
        // ×¤×•× ×§×¦×™×™×ª ×× ×™××¦×™×”
        const animate = () => {
            requestAnimationFrame(animate);
            
            if (isLoaded) {
                const delta = clock.getDelta();
                
                if (controls) {
                    // ×©××™×¨×ª ×”××™×§×•× ×”×§×•×“× ×œ×¤× ×™ ×”×¢×“×›×•×Ÿ
                    const previousPosition = camera.position.clone();
                    
                    // ×¢×“×›×•×Ÿ ×”×©×œ×™×˜×”
                    controls.update(delta);
                    
                    // ×‘×“×™×§×ª ×”×ª× ×’×©×•×ª ×¢× ×§×™×¨×•×ª ×”×× ×”×¨×”
                    if (checkTunnelCollisions(camera.position)) {
                        // ×× ×™×© ×”×ª× ×’×©×•×ª, ×—×–×¨×” ×œ××™×§×•× ×”×§×•×“×
                        camera.position.copy(previousPosition);
                    }
                    
                    // ×©××™×¨×ª ×’×•×‘×” ×§×‘×•×¢ ××¢×œ ×”×¨×¦×¤×” (×¨×¦×¤×” ×©×˜×•×—×”)
                    camera.position.y = PLAYER_HEIGHT;
                    
                    // ×”×“×¤×¡×ª ×”××™×§×•× ×”× ×•×›×—×™ ×©×œ ×”×©×—×§×Ÿ ×œ×§×•× ×¡×•×œ ×•×œ××¡×š ×‘×›×œ ×¤×¨×™×™×
                    const positionInfo = `××™×§×•× ×©×—×§×Ÿ: X: ${camera.position.x.toFixed(2)}, Y: ${camera.position.y.toFixed(2)}, Z: ${camera.position.z.toFixed(2)}`;
                    console.log(positionInfo);
                    
                    // ×”×¦×’×ª ×”××™×§×•× ×¢×œ ×”××¡×š
                    if (!window.positionDisplay) {
                        window.positionDisplay = document.createElement('div');
                        window.positionDisplay.style.position = 'absolute';
                        window.positionDisplay.style.bottom = '10px';
                        window.positionDisplay.style.left = '10px';
                        window.positionDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                        window.positionDisplay.style.color = 'white';
                        window.positionDisplay.style.padding = '5px';
                        window.positionDisplay.style.fontFamily = 'monospace';
                        window.positionDisplay.style.fontSize = '14px';
                        window.positionDisplay.style.borderRadius = '3px';
                        window.positionDisplay.style.zIndex = '1000';
                        document.body.appendChild(window.positionDisplay);
                    }
                    window.positionDisplay.textContent = positionInfo;
                    
                    // ×‘×“×™×§×ª ×× ×”×’×¢× ×• ×œ× ×§×•×“×ª ×”×¤×•×¨×˜×œ
                    checkCustomLocationPoints(camera.position);
                }
                
                // ×× ×™××¦×™×” ×œ×¤×•×¨×˜×œ ×¢× ×¢×©×Ÿ ×¡×’×•×œ
                animatePortal();
            }
            
            renderer.render(scene, camera);
        };
        // × ×™×§×•×™ ×‘×¢×ª ×¢×–×™×‘×ª ×”×“×£
window.addEventListener('beforeunload', () => {
    if (computerCheckTimer) {
        clearInterval(computerCheckTimer);
    }
});
        // ×”×¤×¢×œ×ª ×”××ª×—×•×œ ×›×©×”×“×£ × ×˜×¢×Ÿ
        window.addEventListener('load', init);
// ×”××–× ×” ×œ×”×•×“×¢×•×ª ××”-iframe
// ×”××–× ×” ×œ×”×•×“×¢×•×ª ××”-iframe
// ×”××–× ×” ×œ×”×•×“×¢×•×ª ××”-iframe
// ×”××–× ×” ×œ×”×•×“×¢×•×ª ××”-iframe
window.addEventListener('message', function(event) {
    if (newPcModalHasBeenClosed) return;

    console.log('ğŸ“¨ ×”×ª×§×‘×œ×” ×”×•×“×¢×” ××”-iframe:', event.data);

    if (event.data && typeof event.data === 'object') {
        // âœ… ×¡×’×™×¨×ª iframe ××”×›×¤×ª×•×¨ ×‘×¤× ×™×
        if (event.data.action === 'closeIframe' && event.data.game === 'oneline') {
            console.log('ğŸ“© ×¡×’×™×¨×ª ×”××•×“××œ ××”-iframe');

            // âœ… ×¡×’×™×¨×” ××œ××” ×¢× ×‘×™×˜×•×œ ×¤×ª×™×—×” ×—×•×–×¨×ª
            closeNewPcModal();

            // âœ… ×©×™× ×•×™ ×”×˜×§×¡×˜ ×‘××©×™××”
// âœ… ×©×™× ×•×™ ×”×˜×§×¡×˜ ×‘××©×™××” ×¢× ×©××™×¨×” ×¢×œ ××•×ª×• ×’×•×“×œ
const missionPopup = document.getElementById('mission-popup');
            if (missionPopup) {
                const messageElement = missionPopup.querySelector('div > div > div');
                if (messageElement) {
                    messageElement.textContent = "×”×¡×ª×•×‘×‘×• ×•×”×ª×§×¨×‘×• ×œ×©×•×œ×—×Ÿ ×”××—×©×‘×™×";
                    
                    // ×•×™×“×•× ×©×”×’×•×“×œ ×•×”×¢×™×¦×•×‘ × ×©××¨×™× ×œ××¨×•×ª ×”×˜×§×¡×˜ ×”××¨×•×š ×™×•×ª×¨
                    messageElement.style.fontSize = "28px"; 
                    messageElement.style.fontWeight = "bold";
                    messageElement.style.color = "#FF5722";
                    messageElement.style.textShadow = "0 0 4px rgba(255, 255, 255, 0.9)";
                    messageElement.style.letterSpacing = "1px";
                    messageElement.style.padding = "5px 0";
                }
            }

            // âœ… ×”×—×–×¨×ª ××•×“×œ×™×
            showModelsAfterGameClosure();
        }

        // ğŸ•’ ×”×•×“×¢×” ×¢×œ ×¡×™×•× ×”××©×—×§ â€” ×œ× ××—×–×™×¨×” ××ª ×”××•×“×œ×™× ×œ×¤×™ ×”×œ×•×’×™×§×” ×©×œ×š
        if (event.data.action === 'gameOver' && event.data.game === 'oneline') {
            console.log('ğŸ•’ ×”××©×—×§ Oneline × ×’××¨ ×‘×–××Ÿ, ××š ×œ× ××¦×™×’×™× ××ª ×”××•×“×œ×™× ××—×“×©');
            // ×× ×‘×¢×ª×™×“ ×ª×—×œ×™×˜ ×›×Ÿ ×œ×”×—×–×™×¨ ××•×“×œ×™× ×›××Ÿ:
            // showModelsAfterGameClosure();
        }
    }
});

// ×¤×•× ×§×¦×™×” ×—×“×©×” ×œ×”×¦×’×ª ×”××•×“×œ×™× ×¨×§ ××—×¨×™ ×œ×—×™×¦×” ×¢×œ ×›×¤×ª×•×¨ ×”×¡×’×™×¨×”
// ×¤×•× ×§×¦×™×” ×—×“×©×” ×œ×”×¦×’×ª ×”××•×“×œ×™× ×¨×§ ××—×¨×™ ×œ×—×™×¦×” ×¢×œ ×›×¤×ª×•×¨ ×”×¡×’×™×¨×”
function showModelsAfterGameClosure() {
    // ×¢×•×‘×¨ ×¢×œ ×›×œ ×”××•×‘×™×™×§×˜×™× ×‘×¡×¦× ×” ×•××¦×™×’ ×¨×§ ××ª ×”××•×“×œ×™× ×”×¨×œ×•×•× ×˜×™×™×
    scene.traverse((object) => {
        if (object.userData && object.userData.isTable) {
            object.visible = true;
        }
        if (object.userData && object.userData.isOldComputer) {
            object.visible = true;
        }
        if (object.userData && object.userData.isNewComputer) {
            object.visible = true;
        }
        if (object.userData && object.userData.isCharacter) {
            object.visible = true;  // ×”×¦×’×ª ×”×“××•×™×•×ª
        }
    });
    
    // ×”×—×œ×¤×ª ×”×ª××•× ×” ×œ-oneline2.jpg
    updateGameImage();
}

    </script>
</body>
</html>