<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>注 转转  注 Three.js</title>
    <!-- 注转 住驻专转 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/FirstPersonControls.js"></script>
    <!-- 注转 住驻专转 Audio -->
    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: default;
        }
        
        #scene-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        
        #controls-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        
        #next-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        
        #back-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <!-- Modal for video -->
<div id="video-modal" style="
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
z-index: 1000;
font-family: 'Varela Round', Arial, sans-serif;
">
<div style="
    position: relative;
    background-color: #000;
    margin: 5% auto;
    width: 90%;
    max-width: 800px;
    border-radius: 25px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    animation: modalPopIn 0.7s;
    direction: rtl;
    border: 8px solid #FF5722;
">
    <div style="
        background: linear-gradient(to left, #FF5722, #FF8A65);
        color: white;
        padding: 20px;
        border-radius: 17px 17px 0 0;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
    ">
        <div style="position: relative; display: inline-block;">
            <h2 style="margin: 0; font-size: 32px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); font-weight: bold;">专  注 专拽!</h2>
        </div>
        <span id="close-video-modal" style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); color: white; font-size: 36px; font-weight: bold; cursor: pointer;">锔</span>
    </div>
    <div style="padding: 0; background-color: black; border-radius: 0 0 17px 17px;">
        <video id="intro-video" width="100%" controls style="display: block; border-radius: 0 0 17px 17px;">
            <source src="vid/3.mp4" type="video/mp4">
            驻驻 砖  转 转转 .
        </video>
    </div>
</div>
</div>

<style>
@keyframes modalPopIn {
0% { transform: scale(0.5); opacity: 0; }
50% { transform: scale(1.05); opacity: 0.8; }
100% { transform: scale(1); opacity: 1; }
}
</style>
<!-- Mission popup -->
<!-- Mission popup -  -->
<div id="mission-popup" style="
    opacity: 0;
    position: fixed;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 999;
    width: auto;
    max-width: 95%;
    animation: float 3s ease-in-out infinite;
">
    <div style="
        background: linear-gradient(135deg, rgba(230, 250, 240, 0.9), rgba(210, 240, 255, 0.95));
        border: 5px solid #FF5722;
        border-radius: 20px;
        padding: 5px;
        box-shadow: 0 0 20px rgba(255, 87, 34, 0.8), 0 0 35px rgba(0, 0, 0, 0.3);
    ">
        <div style="
            background: rgba(255, 255, 255, 0.85);
            border-radius: 15px;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            position: relative;
            z-index: 1;
        ">
            <div style="
                font-size: 40px;
                margin-left: 20px;
                color: #FF5722;
                text-shadow: 0 0 15px rgba(255, 87, 34, 0.9);
            "></div>
            <div style="text-align: right;">
                <div style="
                    color: #333;
                    font-size: 24px;
                    font-weight: bold;
                    text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
                ">注 驻砖 转 住 专拽, 专 砖!</div>
            </div>
        </div>
    </div>
</div>

<style>
@keyframes float {
    0% { transform: translate(-50%, 0px); }
    50% { transform: translate(-50%, -10px); }
    100% { transform: translate(-50%, 0px); }
}
</style>
    <div id="scene-container"></div>
    
    <div id="loading">注 转 注...</div>
    
    <div id="controls-info">
        <p>转注 拽: 拽砖 注 拽拽 砖 注专</p>
        <p>转注 专: 拽砖 注 拽拽  注专</p>
        <p>:  转 注专</p>
    </div>
    
    <div id="crosshair">+</div>
    
    <div id="next-screen">
        <h1>注转 注!</h1>
        <p> 住 .</p>
        <button id="back-button">专 注</button>
    </div>
    // 住祝 转 拽  拽 -HTML,  专  #next-screen:

document.body.insertAdjacentHTML('beforeend', `
<div id="collision-modal" style="
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 1000;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    font-family: Arial, sans-serif;
    text-align: center;
    direction: rtl;
">
    <div style="
        background-color: #fff;
        padding: 30px;
        border-radius: 10px;
        max-width: 400px;
    ">
        <h2 style="color: #e74c3c; margin-top: 0;"> !</h2>
        <p style="font-size: 18px; margin-bottom: 20px;">转 驻注 ! 住 砖.</p>
        <button id="retry-button" style="
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        ">砖专</button>
    </div>
</div>`);
    
    <script>
        // 爪专转 住爪, 爪 专专专
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-12.86, 10.20, 32.68); // 拽 转转 砖 砖拽
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 爪 专 转专
        
        // 专转 爪注 专拽注 砖 
        renderer.setClearColor(0x6495ED);
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // 砖转 
        let controls;
        let worldModel;
        let isLoaded = false;
        let clock = new THREE.Clock();
        let ground; // 砖转 砖专转 专爪驻
        let tunnelObject; // 砖转 砖专转 专
        let tunnelWalls = []; // 注专 砖专转 拽专 砖 拽专转 专
        // 砖转  转
let carModel;
let carPath; // 住 转
let carProgress = 0; // 转拽转 转 注 住
const CAR_SPEED = 0.05; // 专转 转 ( = 转 转专)
// 砖转  转
let taxiModel;
let taxiPath;
let taxiProgress = 0.5; // 转 转 转 拽 砖 转 专砖
const TAXI_SPEED = 0.04; // 专转 注 砖 转 专砖
        // 砖转 
        let walkSound;
        let isWalking = false;
        let backgroundMusic; // 砖转 拽转 专拽注
        let crashSound
        const PLAYER_HEIGHT = 1.6;
        // 拽转 注专 转 住 
        const specialPortalPoint = new THREE.Vector3(33.42, PLAYER_HEIGHT, -23.09); // 注  驻专
        const portalRadius = 6; // 专住  转专 专 驻专
        let portalParticles; // 砖转 砖专转 注专转 拽拽 砖 驻专
        // 住祝 砖转   爪 转砖转
let isCollisionActive = false;
const COLLISION_DISTANCE = 1.5; // 专拽 转砖转 注  专
// 砖转  转 砖拽
let marioModel;
let pacmanModel;
let sonicModel;
// 砖转  住驻 爪转 住拽
let sonicMixer; // AnimationMixer 住拽
let sonicRunAnimation; // 爪 注爪
// 驻拽爪 拽转 转砖转 注  专
let sonicRadius = 20; // 专住 注
let sonicAngle = 20; // 转 转转转
// 砖转  转注转 住拽
let sonicPath;
let sonicProgress = 0;
const SONIC_SPEED = 0.07; // 专转  转专 转   住拽!
// 砖转  转 驻
let mafia1Model;
let mafia2Model;

// 驻拽爪 注转 转 驻
// 住祝 砖转  注拽 专 爪 转注
let movingForward = false;
let movingBackward = false;

// 驻拽爪 砖 转注
const setupMovementControls = () => {
    // 住驻转  专注 爪 注 驻转专 注专
    document.addEventListener('mousedown', (e) => {
        // 拽  抓 驻转专 砖 (0)
        if (e.button === 0) {
            movingForward = true;
            if (controls) controls.moveForward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
        // 拽  抓 驻转专  (2)
        else if (e.button === 2) {
            movingBackward = true;
            if (controls) controls.moveBackward = true;
            
            if (!isWalking && walkSound) {
                walkSound.play();
                isWalking = true;
            }
        }
    });
    
    // 住驻转  专注 砖专专 驻转专 注专
    document.addEventListener('mouseup', (e) => {
        // 拽  砖专专 驻转专 砖 (0)
        if (e.button === 0) {
            movingForward = false;
            if (controls) controls.moveForward = false;
            
            // 注爪专 爪 专拽   拽  专  驻注
            if (isWalking && !movingBackward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
        // 拽  砖专专 驻转专  (2)
        else if (e.button === 2) {
            movingBackward = false;
            if (controls) controls.moveBackward = false;
            
            // 注爪专 爪 专拽   拽  专  驻注
            if (isWalking && !movingForward && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // 注爪专转 转注 转 砖注 转 注  注专 砖转 专转
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            //  注 住转专, 注爪专 转  转注
            if (controls) {
                controls.moveForward = false;
                controls.moveBackward = false;
            }
            movingForward = false;
            movingBackward = false;
            
            if (isWalking && walkSound) {
                walkSound.pause();
                isWalking = false;
            }
        }
    });
    
    // 注爪专转 转注 砖注 转 注
    window.addEventListener('beforeunload', () => {
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
    });
    
    // 注转 转驻专 拽拽 
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
};
const loadMafiaCharacters = () => {
    const loader = new THREE.GLTFLoader();
    
    // 注转 mafia1
    loader.load(
        '3d/mafia1.glb',
        (gltf) => {
            mafia1Model = gltf.scene;
            
            // 专转 爪
            mafia1Model.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // 专转 
            mafia1Model.scale.set(2, 2, 2);
            
            // 拽 mafia1
            mafia1Model.position.set(24.59, 1.90, -22.21);
            
            // 住 拽专
            mafia1Model.rotation.y = Math.PI /-2; // 45 注转
            
            // 住驻 住爪
            scene.add(mafia1Model);
            console.log('mafia1 注 爪');
        },
        (xhr) => {
            console.log('注转 mafia1: ' + (xhr.loaded / xhr.total * 100) + '% 注');
        },
        (error) => {
            console.error('砖 注转 mafia1:', error);
        }
    );
    
    // 注转 mafia2
    loader.load(
        '3d/mafia2.glb',
        (gltf) => {
            mafia2Model = gltf.scene;
            
            // 专转 爪
            mafia2Model.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // 专转 
            mafia2Model.scale.set(2, 2, 2);
            
            // 拽 mafia2
            mafia2Model.position.set(30.04, 1.90, -17.67);
            
            // 住 - 驻 转  注 砖
            mafia2Model.rotation.y = -Math.PI / 6; // -30 注转
            
            // 住驻 住爪
            scene.add(mafia2Model);
            console.log('mafia2 注 爪');
        },
        (xhr) => {
            console.log('注转 mafia2: ' + (xhr.loaded / xhr.total * 100) + '% 注');
        },
        (error) => {
            console.error('砖 注转 mafia2:', error);
        }
    );
};

const checkVehicleCollisions = () => {
    if (isCollisionActive) return false; //  专 砖 转砖转 驻注,  转拽 砖
    
    const playerPosition = camera.position.clone();
    let hasCollision = false;
    
    // 拽转 转砖转 注 转 专砖
    if (carModel) {
        const carPosition = carModel.position.clone();
        // 转注   爪专 拽转 转砖转
        playerPosition.y = 0;
        carPosition.y = 0;
        
        const distanceToCar = playerPosition.distanceTo(carPosition);
        if (distanceToCar < COLLISION_DISTANCE) {
            hasCollision = true;
            console.log('转砖转 注 转!');
        }
    }
    
    // 拽转 转砖转 注 转
    if (taxiModel) {
        const taxiPosition = taxiModel.position.clone();
        // 转注   爪专 拽转 转砖转
        playerPosition.y = 0;
        taxiPosition.y = 0;
        
        const distanceToTaxi = playerPosition.distanceTo(taxiPosition);
        if (distanceToTaxi < COLLISION_DISTANCE) {
            hasCollision = true;
            console.log('转砖转 注 转!');
        }
    }
    
    //  砖 转砖转, 驻注 转  砖注 转 爪
    if (hasCollision) {
        // 砖注转 爪 转砖转
        if (crashSound) {
            crashSound.play();
        }
        
        showCollisionModal();
    }
    
    return hasCollision;
};
// 驻拽爪 爪转  砖砖 转砖转
// 驻拽爪 爪转  砖砖 转砖转
const showCollisionModal = () => {
    isCollisionActive = true;
    
    // 注爪专转 爪  转
    if (walkSound && isWalking) {
        walkSound.pause();
        isWalking = false;
    }
    
    // 转 注爪转 拽 驻 
    if (backgroundMusic && backgroundMusic.playing()) {
        backgroundMusic.volume(0.2); // 专转 注爪 -20%
    }
    
    // 砖转转 砖
    if (controls) {
        controls.enabled = false;
    }
    
    // 爪转 
    const modal = document.getElementById('collision-modal');
    modal.style.display = 'flex';
};

// 驻拽爪 驻住 砖拽
// 驻拽爪 驻住 砖拽
// 驻拽爪 驻住 砖拽
const resetGame = () => {
    // 住转专转 
    const modal = document.getElementById('collision-modal');
    modal.style.display = 'none';
    
    // 专转 砖拽 拽转 转
    camera.position.set(-40, PLAYER_HEIGHT, 8.64);
    
    // 驻住 爪 转注
    movingForward = false;
    movingBackward = false;
    if (controls) {
        controls.moveForward = false;
        controls.moveBackward = false;
    }
    
    // 驻注转 砖 砖
    if (controls) {
        controls.enabled = true;
    }
    
    // 专转 注爪转 拽 专 拽专转
    if (backgroundMusic && backgroundMusic.playing()) {
        backgroundMusic.volume(0.5); // 专 注爪 拽专转
    }
    
    // 驻住  转砖转
    isCollisionActive = false;
};
// 住驻转  专注 驻转专 砖专
document.getElementById('retry-button').addEventListener('click', resetGame);
        // 爪专转 驻专 注 拽拽 注砖 住
        const createPortalEffect = () => {
            // 爪专转 专 拽拽
            const particleCount = 500;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            // 专转 注砖 注 住 拽转 驻专
            for (let i = 0; i < particleCount; i++) {
                // 拽 拽专 转 住驻专
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * portalRadius;
                const height = Math.random() * 5; //  拽拽
                
                // 住驻转 专转 拽 拽
                positions[i * 3] = specialPortalPoint.x + Math.cos(angle) * radius;
                positions[i * 3 + 1] = specialPortalPoint.y + height;
                positions[i * 3 + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                
                // 爪注 住 注 专爪转 拽转
                colors[i * 3] = 0.5 + Math.random() * 0.2; // 
                colors[i * 3 + 1] = 0; // 专拽
                colors[i * 3 + 2] = 0.8 + Math.random() * 0.2; // 
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // 爪专转 专 拽拽 注 住 注专 (Blending) 转 注砖
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.4,
                transparent: true,
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            // 爪专转 注专转 拽拽
            portalParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(portalParticles);
            
            // 住驻转 专 拽转 住 专 驻专
            const portalLight = new THREE.PointLight(0x9932CC, 1, 10);
            portalLight.position.copy(specialPortalPoint);
            portalLight.position.y += 1.5; // 专转 专 注
            scene.add(portalLight);
        };
        
        // 爪 驻专
        const animatePortal = () => {
            if (portalParticles) {
                const positions = portalParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // 转注 拽专转 拽
                    positions[i] += (Math.random() - 0.5) * 0.05;
                    positions[i + 1] += Math.random() * 0.05; // 转注 拽 注
                    positions[i + 2] += (Math.random() - 0.5) * 0.05;
                    
                    // 专 拽拽 砖爪 专 专 驻专
                    const dx = positions[i] - specialPortalPoint.x;
                    const dz = positions[i + 2] - specialPortalPoint.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance > portalRadius || positions[i + 1] > specialPortalPoint.y + 5) {
                        //  拽拽 爪 转, 专 转 拽 砖 转 驻专
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * portalRadius * 0.7;
                        
                        positions[i] = specialPortalPoint.x + Math.cos(angle) * radius;
                        positions[i + 1] = specialPortalPoint.y + Math.random() * 2.5;
                        positions[i + 2] = specialPortalPoint.z + Math.sin(angle) * radius;
                    }
                }
                
                portalParticles.geometry.attributes.position.needsUpdate = true;
            }
        };
        
        // 驻拽爪 拽转 拽 砖 注专 住 
// 驻拽爪 拽转 拽 砖 注专 住 
const checkCustomLocationPoints = (position) => {
    // 拽转 专拽 拽转 驻专 转
    const distanceToPortal = position.distanceTo(specialPortalPoint);
    
    if (distanceToPortal < portalRadius / 2) {
        // 注爪专转 转注 爪 驻 注专 祝
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        // 注爪专转 拽 驻 注专 祝 专
        if (backgroundMusic && backgroundMusic.playing()) {
            backgroundMusic.stop();
        }
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
        
        // 注专 祝 games.html
        window.location.href = 'games.html';
        return true;
    }
    
    return false;
};
        
        // 拽注  砖拽 注 
        
        
        // 转专 驻拽
        const setupLighting = () => {
            // 专 住
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // 专 砖砖 专砖
            const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.0);
            sunLight.position.set(10, 20, 15);
            sunLight.castShadow = true;
            
            // 专转 爪 转转 转专
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            sunLight.shadow.bias = -0.0003;
            
            scene.add(sunLight);
            
            // 拽转 专 砖转 转专转 
            const fillLight = new THREE.DirectionalLight(0xc2d1ff, 0.5);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
            
            // 专 拽转 注 专 住爪
            const pointLight = new THREE.PointLight(0xffedbe, 0.5, 20);
            pointLight.position.set(0, 12, 0);
            scene.add(pointLight);
            
            // 注专驻 转砖转 注拽
            scene.fog = new THREE.FogExp2(0x8eb5e0, 0.006); // 拽转 注专 爪驻驻转   转专
        };
        
        // 爪专转 拽住专转 专爪驻 住 砖
// 爪专转 拽住专转 专爪驻 住 砖  住
// 爪专转 拽住专转 专爪驻 住 专 砖 注 专爪驻转 转   
function createRoadTexture() {
  const textureSize = 1024;
  const canvas = document.createElement('canvas');
  canvas.width = textureSize;
  canvas.height = textureSize;
  const ctx = canvas.getContext('2d');
  
  // 爪注 专拽注 住驻 
  ctx.fillStyle = '#222222';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // 住驻转 拽住专转 住驻
  for (let i = 0; i < 5000; i++) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const size = Math.random() * 2 + 0.5;
    
    //  拽转 住驻
    ctx.fillStyle = `rgba(${40 + Math.random() * 30}, ${40 + Math.random() * 30}, ${40 + Math.random() * 30}, 0.3)`;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // 住驻转 住拽 拽
  for (let i = 0; i < 50; i++) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const length = 10 + Math.random() * 30;
    const angle = Math.random() * Math.PI * 2;
    
    ctx.strokeStyle = `rgba(40, 40, 40, ${Math.random() * 0.5 + 0.2})`;
    ctx.lineWidth = Math.random() * 1 + 0.5;
    
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
    ctx.stroke();
  }
  
  // 住驻转 拽 砖 爪
  const borderWidth = canvas.width * 0.05; // 5% 专 砖  爪
  
  // 砖 爪 爪
  ctx.fillStyle = '#FFCC00';
  // 砖 砖
  ctx.fillRect(0, 0, borderWidth, canvas.height);
  // 砖 
  ctx.fillRect(canvas.width - borderWidth, 0, borderWidth, canvas.height);
  
  // 住驻转 驻住 注专 爪
  const crossingWidth = canvas.width * 0.6; // 专 注专 爪
  const crossingOffset = (canvas.width - crossingWidth) / 2; // 专拽 爪
  const stripeCount = 7; // 住驻专 驻住
  const stripeWidth = crossingWidth / (stripeCount * 2 - 1); // 专  驻住
  
  // 爪专 驻住 注专 爪
  ctx.fillStyle = 'white';
  for (let i = 0; i < stripeCount; i++) {
    const x = crossingOffset + i * stripeWidth * 2;
    const y = canvas.height * 0.4; // 拽  砖 注专 爪
    const height = canvas.height * 0.2; //  注专 爪
    
    ctx.fillRect(x, y, stripeWidth, height);
  }
  
  // 住驻转 拽  拽拽 爪注
  ctx.strokeStyle = 'white';
  ctx.lineWidth = borderWidth * 0.8;
  ctx.setLineDash([canvas.height / 15, canvas.height / 15]); // 拽 拽拽
  
  ctx.beginPath();
  ctx.moveTo(canvas.width / 2, 0);
  ctx.lineTo(canvas.width / 2, canvas.height);
  ctx.stroke();
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(1, 5); // 专转 专 砖
  
  return texture;
}

// 驻拽爪 住驻转 拽住专  
function addStoneTexture(ctx, x, y, width, height) {
  // 住驻转 专拽  转 - 住驻住  转专
  for (let i = 0; i < width * height / 60; i++) {
    const px = x + Math.random() * width;
    const py = y + Math.random() * height;
    const size = Math.random() * 1.5 + 0.5;
    
    ctx.fillStyle = `rgba(60, 60, 60, ${Math.random() * 0.3})`;
    ctx.beginPath();
    ctx.arc(px, py, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function addWearAndTear(ctx, width, height) {
  // 住驻转 砖拽 转
  for (let i = 0; i < 200; i++) {
    const x = Math.random() * width;
    const y = Math.random() * height;
    const size = 5 + Math.random() * 10;
    
    // 住 转
    const type = Math.random();
    let color;
    
    if (type < 0.7) {
      // 砖拽 专
      color = `rgba(50, 50, 50, ${Math.random() * 0.25})`;
    } else {
      // 转 
      color = `rgba(30, 30, 30, ${Math.random() * 0.3})`;
    }
    
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
}
function createPavementTexture() {
  const textureSize = 1024;
  const canvas = document.createElement('canvas');
  canvas.width = textureSize;
  canvas.height = textureSize;
  const ctx = canvas.getContext('2d');
  
  // 爪注 专拽注   砖拽砖转
  ctx.fillStyle = '#050B14';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // 专转  砖转转
  const tileWidth = 60;
  const tileHeight = 30;
  const groutWidth = 3;
  
  // 爪专 转转  砖转转
  for (let x = 0; x < canvas.width; x += tileWidth) {
    for (let y = 0; y < canvas.height; y += tileHeight) {
      // 专爪 拽  
      const variation = Math.random() * 8 - 4;
      
      // 砖砖   砖拽砖转 注 专爪 拽
      // 驻专 转 注专 拽 爪注
      const r = 5 + variation;  // 05 拽 爪注
      const g = 11 + variation; // 0B 拽 爪注
      const b = 20 + variation; // 14 拽 爪注
      
      // 爪注转 
      ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
      ctx.fillRect(x + groutWidth/2, y + groutWidth/2,
                 tileWidth - groutWidth, tileHeight - groutWidth);
      
      // 住驻转 拽住专 住驻住 
      addStoneDarkTexture(ctx, x + groutWidth/2, y + groutWidth/2,
                     tileWidth - groutWidth, tileHeight - groutWidth);
    }
  }
  
  // 拽 专  转专  
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = groutWidth;
  
  // 拽 
  for (let x = 0; x < canvas.width; x += tileWidth) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  
  // 拽 驻拽
  for (let y = 0; y < canvas.height; y += tileHeight) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
  
  // 住驻转 砖拽 转 转 爪注 
  addDarkWearAndTear(ctx, canvas.width, canvas.height);
  
  // 爪专转 拽住专
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(8, 8); 
  
  return texture;
}
function addStoneDarkTexture(ctx, x, y, width, height) {
  // 住驻转 专拽  
  for (let i = 0; i < width * height / 60; i++) {
    const px = x + Math.random() * width;
    const py = y + Math.random() * height;
    const size = Math.random() * 1.5 + 0.5;
    
    // 专拽   注 注 
    ctx.fillStyle = `rgba(10, 15, 25, ${Math.random() * 0.3})`;
    ctx.beginPath();
    ctx.arc(px, py, size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // 住驻转 拽转 专拽转 转  专 
  for (let i = 0; i < width * height / 200; i++) {
    const px = x + Math.random() * width;
    const py = y + Math.random() * height;
    const size = Math.random() * 0.8 + 0.2;
    
    ctx.fillStyle = `rgba(100, 120, 140, ${Math.random() * 0.2})`;
    ctx.beginPath();
    ctx.arc(px, py, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function addDarkWearAndTear(ctx, width, height) {
  // 住驻转 砖拽 转 转 爪注  
  for (let i = 0; i < 200; i++) {
    const x = Math.random() * width;
    const y = Math.random() * height;
    const size = 5 + Math.random() * 10;
    
    // 住 转
    const type = Math.random();
    let color;
    
    if (type < 0.7) {
      // 砖拽 拽 转专 (  注 转专 专)
      color = `rgba(20, 25, 30, ${Math.random() * 0.25})`;
    } else if (type < 0.9) {
      // 转  
      color = `rgba(0, 0, 5, ${Math.random() * 0.3})`;
    } else {
      // 转 注   注
      color = `rgba(10, 20, 40, ${Math.random() * 0.25})`;
    }
    
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
}
function createPavementAndRoad() {
  if (ground) {
    scene.remove(ground); // 拽转 专爪驻 拽转 专
  }
  
  // 拽转 转 住祝 砖
  const startPoint = new THREE.Vector3(-18, 0, 36.16);
  const endPoint = new THREE.Vector3(-29, 0, -32.71);
  
  // 砖  专 砖
  const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
  const roadLength = direction.length();
  const normalizedDirection = direction.clone().normalize();
  
  // 爪专转 拽专 爪  砖
  const perpendicular = new THREE.Vector3();
  if (Math.abs(normalizedDirection.y) < 0.99) {
    perpendicular.set(0, 1, 0);
  } else {
    perpendicular.set(1, 0, 0);
  }
  perpendicular.cross(normalizedDirection).normalize();
  
  // 转
  const roadWidth = 12; // 专  转专
  const pavementWidth = 120; // 专  专爪驻转  砖转转
  
  // 拽住专转
  const pavementTexture = createPavementTexture();
  const roadTexture = createRoadTexture();
  
  // 爪专转 专爪驻转  砖转转
  const pavementGeometry = new THREE.BoxGeometry(pavementWidth, 0.2, pavementWidth);
  const pavementMaterial = new THREE.MeshStandardMaterial({
    map: pavementTexture,
    roughness: 0.9,
    metalness: 0.1
  });
  
  const pavement = new THREE.Mesh(pavementGeometry, pavementMaterial);
  pavement.position.y = -0.1; // 拽  转转 砖
  pavement.receiveShadow = true;
  scene.add(pavement);
  
  // 爪专转 砖
  const roadGeometry = new THREE.BoxGeometry(roadWidth, 0.1, roadLength);
  const roadMaterial = new THREE.MeshStandardMaterial({
    map: roadTexture,
    roughness: 0.8,
    metalness: 0.2
  });
  
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  
  // 拽 砖 爪注  拽转 转 住
  const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
  road.position.copy(midPoint);
  
  // 砖 住 住 爪专 Y  砖砖   
  const angle = Math.atan2(direction.x, direction.z);
  road.rotation.y = angle;
  
  // 专转 砖 注 注 专爪驻 注转 -驻
  road.position.y = 0;
  
  road.receiveShadow = true;
  scene.add(road);
  
  return { pavement, road };
}
        // 爪专转 拽专拽注 砖 住 砖
// 爪专转 拽专拽注 砖 住 砖
// 爪专转 拽专拽注 砖 爪专转 专注 转
const createFlatRoadGround = () => {
    // 爪专转 专注 转 专爪驻
    const boxWidth = 200;
    const boxDepth = 200;
    const boxHeight = 1; //  拽 
    
    // 砖砖 -BoxGeometry 砖爪专转 专注 砖
    const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
    
    // 爪专转 专 注 拽住专转 砖
    const roadTexture = createRoadTexture();
    
    // 专转 注专 砖 专  驻 砖 拽驻住
    const materials = [
        new THREE.MeshStandardMaterial({ color: 0x555555 }), // 爪 
        new THREE.MeshStandardMaterial({ color: 0x555555 }), // 爪 砖
        new THREE.MeshStandardMaterial({ map: roadTexture, roughness: 0.9, metalness: 0.1 }), // 注 (专爪驻 注爪)
        new THREE.MeshStandardMaterial({ color: 0x555555 }), // 
        new THREE.MeshStandardMaterial({ color: 0x555555 }), // 转
        new THREE.MeshStandardMaterial({ color: 0x555555 })  // 
    ];
    
    ground = new THREE.Mesh(geometry, materials);
    
    // 拽 专爪驻  0
    ground.position.y = -0.5; // 爪   砖拽 注  拽  0
    ground.receiveShadow = true;
    scene.add(ground);
    
    return ground;
};
        
        // 爪专转 拽专 拽专转 专
        const createTunnelColliders = (startPoint, endPoint, tunnelRadius) => {
    // 拽 注专 拽专 拽
    tunnelWalls = [];
    
    // 砖  专 砖 专
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    const tunnelLength = direction.length();
    
    // 专 
    const normalizedDirection = direction.clone().normalize();
    
    // 爪专转 拽专 爪  专
    const perpendicular = new THREE.Vector3();
    if (Math.abs(normalizedDirection.y) < 0.99) {
        perpendicular.set(0, 1, 0);
    } else {
        perpendicular.set(1, 0, 0);
    }
    perpendicular.cross(normalizedDirection).normalize();
    
    // 住驻专 拽专 住 拽祝 专
    const numColliders = 8;
    
    // 爪专转 拽专 住 拽祝 专
    for (let i = 0; i < numColliders; i++) {
        const angle = (i / numColliders) * Math.PI * 2;
        
        // 拽专  拽专 
        const ringVector = perpendicular.clone().applyAxisAngle(normalizedDirection, angle);
        
        // 拽转 专 拽专
        const colliderPoints = [];
        
        // 住驻专 拽转 专 专
        const numPoints = 4;
        
        // 爪专转 拽转 专 专
        for (let j = 0; j <= numPoints; j++) {
            const t = j / numPoints;
            
            // 拽 注 拽 专
            const pointOnLine = new THREE.Vector3().lerpVectors(startPoint, endPoint, t);
            
            // 拽 注 拽专 专
            const pointOnWall = pointOnLine.clone().add(
                ringVector.clone().multiplyScalar(tunnelRadius * 0.9) // 注 驻 专住 转
            );
            
            colliderPoints.push(pointOnWall);
        }
        
        // 砖专转 注 拽专
        tunnelWalls.push({
    points: colliderPoints,
    radius: 0.5 //  拽专 专 转专 专 
});
    }
};
        
        // 拽转 转砖转 注 拽专转 专
        const checkTunnelCollisions = (position) => {
    //   拽专转 专, 专 false 转
    if (!tunnelWalls || tunnelWalls.length === 0) {
        return false;
    }
    
    // 砖 拽 拽  砖 拽专转 专
    // 专住 砖拽
    const playerRadius = 0.5;
    
    for (const wall of tunnelWalls) {
        // 拽转  拽注 砖 拽专
        for (let i = 0; i < wall.points.length - 1; i++) {
            // 拽 拽...
        }
    }
    
    return false;
};
        
        // 爪专转 爪专/专 砖砖拽  住 
        const createTunnel = () => {
    // 拽转 转 住 专 (拽转 砖转)
    const startPoint = new THREE.Vector3(-9.63, 13.0, 26.94); // 转转 专 砖 注  13
    const endPoint = new THREE.Vector3(33.19, 13.0, -38.43); // 住祝 专 砖 注  13
    
    // 砖  专 砖 专
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    const tunnelLength = direction.length();
    
    // 专住 爪专 -  -8 专
    const tunnelRadius = 8; // 专住 砖
    // 住驻专 拽注 专 拽祝 爪专
    const radialSegments = 16;
    const heightSegments = 30;
    
    
    // 爪专转 专转 爪专 驻转 砖 拽爪转
    const geometry = new THREE.CylinderGeometry(
        tunnelRadius, // 专住 注
        tunnelRadius, // 专住 转转
        tunnelLength, // 专
        radialSegments, // 住驻专 拽注 拽祝
        heightSegments, // 住驻专 拽注 专
        true // 驻转 砖 拽爪转
    );
    
    
    // 爪专转 拽住专 专 住 专专 住
    const createRetroTunnelTexture = () => {
        const textureSize = 1024;
        const canvas = document.createElement('canvas');
        canvas.width = textureSize;
        canvas.height = textureSize;
        const ctx = canvas.getContext('2d');
        
        // 爪注 专拽注 住 
        ctx.fillStyle = '#2a1a3a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 爪专转 拽 专砖转  住 专专
        const gridSpacing = 64; // 专  转专  拽 专砖转
        const gridColor = '#9c3fd4'; // 住  转专
        
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 3;
        
        // 爪专 拽 驻拽
        for (let y = 0; y < canvas.height; y += gridSpacing) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
            
            // 住驻转 驻拽 专 拽
            ctx.strokeStyle = 'rgba(200, 120, 255, 0.5)';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
            
            // 专 住 拽专
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 3;
        }
        
        // 爪专 拽 
        for (let x = 0; x < canvas.width; x += gridSpacing) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
            
            // 住驻转 驻拽 专 拽
            ctx.strokeStyle = 'rgba(200, 120, 255, 0.5)';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
            
            // 专 住 拽专
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 3;
        }
        
        // 住驻转 拽转 专转 住 
        for (let i = 0; i < 300; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 3 + 1;
            
            // 爪注 专  砖 住/专
            const r = 200 + Math.random() * 55;
            const g = 50 + Math.random() * 100;
            const b = 200 + Math.random() * 55;
            
            // 爪专转 专 专 住 拽
            const glow = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
            glow.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
            glow.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.3)`);
            glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(x, y, size * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // 拽 专转 专 转专
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // 住驻转  专 专专 (砖砖/专注)  砖
        for (let i = 0; i < 50; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 30 + 10;
            
            // 爪注   住/专
            const r = 130 + Math.random() * 50;
            const g = 20 + Math.random() * 40;
            const b = 180 + Math.random() * 70;
            const a = 0.2 + Math.random() * 0.3;
            
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
            
            // 专 拽专转  砖砖 专注
            if (Math.random() > 0.5) {
                // 砖砖
                ctx.beginPath();
                ctx.moveTo(x, y - size / 2);
                ctx.lineTo(x - size / 2, y + size / 2);
                ctx.lineTo(x + size / 2, y + size / 2);
                ctx.closePath();
                ctx.fill();
                
                // 拽 转 专
                ctx.strokeStyle = `rgba(255, 200, 255, 0.7)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            } else {
                // 专注 住 ()
                ctx.beginPath();
                ctx.moveTo(x, y - size / 2);
                ctx.lineTo(x + size / 2, y);
                ctx.lineTo(x, y + size / 2);
                ctx.lineTo(x - size / 2, y);
                ctx.closePath();
                ctx.fill();
                
                // 拽 转 专
                ctx.strokeStyle = `rgba(255, 200, 255, 0.7)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        // 爪专转 拽住专 拽住
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(4, 8); // 专 砖 驻拽 
        
        return texture;
    };
    
    // 爪专转 专拽 专 专专
    const tunnelTexture = createRetroTunnelTexture();
    
    // 爪专转 专 爪专
    const material = new THREE.MeshStandardMaterial({
        map: tunnelTexture,
        roughness: 0.7,
        metalness: 0.3,
        side: THREE.DoubleSide, 
        emissive: new THREE.Color(0x4d0099), // 驻拽 驻  住
        emissiveIntensity: 0.2, // 注爪转 驻
        transparent: false
    });
    
    // 爪专转 专
    const tunnel = new THREE.Mesh(geometry, material);
    
    // 砖 专转 住 砖 专
    // 爪专 爪专 专 爪专 -Y,   爪专 住 转
    //  砖  
    
    // 砖 专 砖 
    direction.normalize();
    
    // 专转 拽专 住 - 专  爪专 -Y
    const yAxis = new THREE.Vector3(0, 1, 0);
    
    // 砖 拽专 住转转 爪专 -Y  砖
    const quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction);
    tunnel.setRotationFromQuaternion(quaternion);
    
    // 拽 专 - 爪注  拽转 转 住
    const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
    tunnel.position.copy(midPoint);
    
    // 住驻转 爪
    tunnel.castShadow = true;
    tunnel.receiveShadow = true;
    
    // 住驻转 专 住爪
    scene.add(tunnel);
    
    // 砖专转 专 砖转 
    tunnelObject = tunnel;
    
    // 爪专转 拽专 拽专转 专
    createTunnelColliders(startPoint, endPoint, tunnelRadius);
    
    // 住驻转 专转 转 专 住 专专
    addRetroTunnelLights(tunnel, tunnelLength, startPoint, endPoint);
    
    return tunnel;
};
const addRetroTunnelLights = (tunnel, tunnelLength, startPoint, endPoint) => {
    // 住驻专 专转 专 专
    const numLights = 20; //  转 住驻专 专转 专 专 专 转专
    // 砖 拽专  拽转 转 拽转 住
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    // 专拽  专转
    const spacing = tunnelLength / numLights;
    
    // 爪注  转驻 住 专专
    const retroColors = [
        0xff00ff, // '
        0x9932CC, // 住 
        0xff1493, // 专 注拽
        0x8a2be2, // -住
        0x9400d3  // 住 
    ];
    
    // 爪专转 专转 专 专
    for (let i = 0; i < numLights; i++) {
        // 拽 专 拽 注 拽  拽转 转 拽转 住
        const ratio = (i * spacing) / tunnelLength;
        const lightPosition = new THREE.Vector3()
            .copy(startPoint)
            .lerp(endPoint, ratio);
        
        // 转 专 爪 注 驻拽 注 转专
        const offset = 6.5; // 转 专拽 专 转 专 专 转专
        const side = i % 2 === 0 ? 1 : -1; // 爪   砖 住专
        
        // 砖 拽专 爪  专
        const normalizedDirection = direction.clone().normalize();
        const perpendicular = new THREE.Vector3();
        
        if (Math.abs(normalizedDirection.y) < 0.99) {
            perpendicular.set(0, 1, 0);
        } else {
            perpendicular.set(1, 0, 0);
        }
        perpendicular.cross(normalizedDirection).normalize();
        
        // 转 专 爪 转 砖 专 注 注
        lightPosition.add(perpendicular.clone().multiplyScalar(side * offset * 0.7));
        // 转 专转 注 转专
        lightPosition.y += 3 + Math.sin(i) * 1.5; // 专爪  转专 
        
        // 专 拽转 爪注 
        const colorIndex = i % retroColors.length;
        const light = new THREE.PointLight(retroColors[colorIndex], 0.6, 8);
        light.position.copy(lightPosition);
        scene.add(light);
        
        // 驻 转专  - 住驻专转 拽转 注 驻拽 专
        const bulbGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const bulbMaterial = new THREE.MeshBasicMaterial({ 
            color: retroColors[colorIndex],
            transparent: true,
            opacity: 0.9
        });
        const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
        bulb.position.copy(light.position);
        scene.add(bulb);
        
        // 住驻转  住 专
        const glowGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({ 
            color: retroColors[colorIndex],
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.copy(light.position);
        scene.add(glow);
        
        // 住驻转 专注/注  住 专专 专 专
        if (i % 3 === 0) { // 住驻专 注 砖  拽专
            const size = 0.5 + Math.random() * 0.3;
            
            // 爪专转 爪专 专转
            const shapeGeometry = new THREE.PlaneGeometry(size, size);
            const shapeMaterial = new THREE.MeshBasicMaterial({ 
                color: retroColors[(colorIndex + 2) % retroColors.length],
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const shape = new THREE.Mesh(shapeGeometry, shapeMaterial);
            
            // 拽 爪专 注 爪 专
            const shapePosition = lightPosition.clone();
            shapePosition.add(perpendicular.clone().multiplyScalar(side * -1 * 0.8)); // 爪 驻 专
            shape.position.copy(shapePosition);
            
            // 住 拽专 爪专
            shape.rotation.z = Math.PI / 4; // 住 -45 注转
            shape.rotation.y = Math.random() * Math.PI;
            
            scene.add(shape);
        }
    }
    
    // 住驻转 专 住 转驻砖 专 住 专
    const entranceLight = new THREE.PointLight(0x9400d3, 1, 10);
    entranceLight.position.copy(startPoint);
    entranceLight.position.y += 1;
    scene.add(entranceLight);
    
    // 住驻转 专 住 转驻砖 专 爪 专
    const exitLight = new THREE.PointLight(0xff00ff, 1, 10);
    exitLight.position.copy(endPoint);
    exitLight.position.y += 1;
    scene.add(exitLight);
};

        // 住驻转 专转 专 专
        const addTunnelLights = (tunnel, tunnelLength, startPoint, endPoint) => {
            // 住驻专 专转 专 专
            const numLights = 10;
            // 砖 拽专  拽转 转 拽转 住
            const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
            // 专拽  专转
            const spacing = tunnelLength / numLights;
            
            // 爪专转 专转 专 专
            for (let i = 0; i < numLights; i++) {
                // 拽 专 拽 注 拽  拽转 转 拽转 住
                const ratio = (i * spacing) / tunnelLength;
                const lightPosition = new THREE.Vector3()
                    .copy(startPoint)
                    .lerp(endPoint, ratio);
                
                // 转 专 驻 注 注  砖 注 专砖 砖拽
                lightPosition.y += 0.5;
                
                // 专 拽转
                const light = new THREE.PointLight(0xffffcc, 0.3, 5);
                light.position.copy(lightPosition);
                scene.add(light);
                
                // 驻 转专  - 住驻专转 拽转
                const bulbGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const bulbMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffee,
                    transparent: true,
                    opacity: 0.8
                });
                const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
                bulb.position.copy(light.position);
                scene.add(bulb);
            }
        };
        
        // 爪专转 注专转 砖 祝 专砖
        const setupFirstPersonControls = () => {
            controls = new THREE.FirstPersonControls(camera, renderer.domElement);
            controls.movementSpeed = 4;
            controls.lookSpeed = 0.03; // 专转 专砖转 -0.1 -0.05
            controls.lookVertical = true;
            controls.constrainVertical = true;
            controls.verticalMin = Math.PI / 6; // 转  注
            controls.verticalMax = Math.PI / 1.8; // 转  
            
            // 专转 专 转 拽爪转 住 砖注爪专 转 转
            const boundaryThreshold = 0.05; // 5% 拽爪 (95% 住 驻注)
            
            //  转转 注专
            document.addEventListener('mousemove', (e) => {
                const mouseX = e.clientX / window.innerWidth;
                const mouseY = e.clientY / window.innerHeight;
                
                // 拽  注专 爪 专 转 (拽专 拽爪转)
                const isNearLeftEdge = mouseX < boundaryThreshold;
                const isNearRightEdge = mouseX > (1 - boundaryThreshold);
                const isNearTopEdge = mouseY < boundaryThreshold;
                const isNearBottomEdge = mouseY > (1 - boundaryThreshold);
                
                // 注爪专转 转  注专 拽爪转
                if (isNearLeftEdge || isNearRightEdge || isNearTopEdge || isNearBottomEdge) {
                    if (controls.activeLook !== false) {
                        controls.activeLook = false;
                    }
                } else {
                    if (controls.activeLook !== true) {
                        controls.activeLook = true;
                    }
                }
            });
        };
        
        // 注转  GLB (专拽 tunnel.glb)
        const loadTunnelModel = () => {
    const loader = new THREE.GLTFLoader();
    
    // 爪转 注转 注
    document.getElementById('loading').style.display = 'block';
    document.getElementById('loading').textContent = '注 转 ...';
    
    loader.load(
        '3d/enterance.glb',
        (gltf) => {
            const model = gltf.scene;
            
            // 专转 爪  砖 
            model.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    
                    // 驻 专     砖注 注- 砖转砖

                }
            });
            
            // 砖专 注 住拽 拽 拽专 砖 
            model.scale.set(15, 7, 10);
            model.position.set(0, 10, 0); // 砖专 注  拽专
            
            // 砖专转  砖转 
            worldModel = model;
            
            scene.add(model);
document.getElementById('loading').style.display = 'none';
isLoaded = true;

// 驻注转 拽 砖 注
if (backgroundMusic && !backgroundMusic.playing()) {
    backgroundMusic.play();
    console.log('拽转 专拽注 驻注');
}
        },
        (xhr) => {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            document.getElementById('loading').textContent = 
                `注 转 ... ${Math.round(percentComplete)}%`;
        },
        (error) => {
            console.error('砖 注转 :', error);
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;
        }
    );
};
        
        // 专 注
  // 专 注
document.getElementById('back-button').addEventListener('click', () => {
    document.getElementById('next-screen').style.display = 'none';
    controls.enabled = true; // 驻注转 砖 砖
    
    //  砖拽 转转 砖专 注
    if (backgroundMusic && !backgroundMusic.playing()) {
        backgroundMusic.play();
    }
});
        
        // 转转  
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (controls) {
                controls.handleResize();
            }
        });
        
        // 专转 住 
// 专转 住 
const setupWalkSound = () => {
    // 爪专转 拽 住  注 驻爪 驻注 专转 (loop)
    walkSound = new Howl({
        src: ['audio/walk.mp3'],
        loop: true,
        volume: 0.7
    });

            
            // 住驻转  专注 爪 注 驻转专 注专
            document.addEventListener('mousedown', (e) => {
                // 拽  抓 驻转专 砖 (0)   (2)
                if ((e.button === 0 || e.button === 2) && !isWalking) {
                    walkSound.play();
                    isWalking = true;
                }
            });
            
            // 住驻转  专注 砖专专 驻转专 注专
            document.addEventListener('mouseup', (e) => {
                // 拽  砖专专 驻转专 砖 (0)   (2)
                if ((e.button === 0 || e.button === 2) && isWalking) {
                    walkSound.pause();
                    isWalking = false;
                }
            });
            
            // 注转 转驻专 拽拽 
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        };
        // 专转 注专转 砖注转 拽转 专拽注 专转
function setupBackgroundMusic() {
    // 注专 砖 转 拽爪 拽
    const musicTracks = [
        'audio/enter/1.mp3',
        'audio/enter/2.mp3',
        'audio/enter/3.mp3',
        'audio/enter/4.mp3'
    ];
    
    // 专转 砖专 拽专 注专
    const randomTrackIndex = Math.floor(Math.random() * musicTracks.length);
    const selectedTrack = musicTracks[randomTrackIndex];
    
    // 爪专转 拽 住 拽转 专拽注
    backgroundMusic = new Howl({
        src: [selectedTrack],
        loop: true,      //  专
        volume: 0.5,     // 注爪转 砖注 (0-1)
        autoplay: false  //  转 转
    });
    
    console.log(`专 砖专 专拽注: ${selectedTrack}`);
    
    // 爪专转 驻转专 砖转拽转 拽
    createMusicToggleButton();
    
    return backgroundMusic;
}

// 爪专转 驻转专 砖转拽转 拽
function createMusicToggleButton() {
    // 拽  驻转专 专 拽
    if (document.getElementById('music-toggle')) {
        return;
    }
    
    // 爪专转 驻转专 砖转拽转 拽
    const musicToggleBtn = document.createElement('button');
    musicToggleBtn.id = 'music-toggle';
    musicToggleBtn.title = '砖转拽/驻注 拽';
    musicToggleBtn.textContent = '';
    musicToggleBtn.style.position = 'absolute';
    musicToggleBtn.style.top = '10px';
    musicToggleBtn.style.left = '10px';
    musicToggleBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    musicToggleBtn.style.color = 'white';
    musicToggleBtn.style.border = 'none';
    musicToggleBtn.style.borderRadius = '5px';
    musicToggleBtn.style.padding = '5px 10px';
    musicToggleBtn.style.fontSize = '20px';
    musicToggleBtn.style.cursor = 'pointer';
    musicToggleBtn.style.zIndex = '100';
    
    document.body.appendChild(musicToggleBtn);
    
    // 住驻转  专注 驻转专
    musicToggleBtn.addEventListener('click', () => {
        console.log('驻转专 砖转拽 抓');
        
        if (backgroundMusic) {
            if (backgroundMusic.playing()) {
                backgroundMusic.pause();
                musicToggleBtn.textContent = '';
                console.log('拽 砖转拽');
            } else {
                backgroundMusic.play();
                musicToggleBtn.textContent = '';
                console.log('拽 驻注');
            }
        } else {
            console.error('拽 拽  爪!');
        }
    });
    
    // 住驻转  专注 拽砖 M 砖转拽转/驻注转 拽
    document.addEventListener('keydown', (e) => {
        if (e.key === 'm' || e.key === 'M' || e.key === '') {
            if (backgroundMusic) {
                if (backgroundMusic.playing()) {
                    backgroundMusic.pause();
                    musicToggleBtn.textContent = '';
                    console.log('拽 砖转拽');
                } else {
                    backgroundMusic.play();
                    musicToggleBtn.textContent = '';
                    console.log('拽 驻注');
                }
            }
        }
    });
}
// 注转  转
const loadCarModel = () => {
    const loader = new THREE.GLTFLoader();
    
    loader.load(
        '3d/oldcar.glb',
        (gltf) => {
            carModel = gltf.scene;
            
            // 专转 爪  砖  转
            carModel.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // 转转  转 - 转 砖转爪专 砖转 转 注专 
            carModel.scale.set(2.5, 2.5, 2.5);
            
            // 住 转   (转 砖转爪专 转 转 )
            carModel.rotation.y = Math.PI; // 住 -180 注转
            
            // 住驻转 转 住爪
            scene.add(carModel);
            
            // 爪专转 住 住注 转
            createCarPath();
            
            console.log(' 转 注 爪');
        },
        (xhr) => {
            console.log('注转 转: ' + (xhr.loaded / xhr.total * 100) + '% 注');
        },
        (error) => {
            console.error('砖 注转  转:', error);
        }
    );
};
// 注转  转
const loadTaxiModel = () => {
    const loader = new THREE.GLTFLoader();
    
    loader.load(
        '3d/taxi.glb',
        (gltf) => {
            taxiModel = gltf.scene;
            
            // 专转 爪  砖  转
            taxiModel.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // 转转  转
            taxiModel.scale.set(2.5, 2.5, 2.5);
            
            // 住 转  
            taxiModel.rotation.y = Math.PI ;
           
            
            // 住驻转 转 住爪
            scene.add(taxiModel);
            
            // 爪专转 住 住注 转 (转 砖)
            createTaxiPath();
            
            console.log(' 转 注 爪');
        },
        (xhr) => {
            console.log('注转 转: ' + (xhr.loaded / xhr.total * 100) + '% 注');
        },
        (error) => {
            console.error('砖 注转  转:', error);
        }
    );
};
// 爪专转 住 住注 砖 转 - 转 砖
const createTaxiPath = () => {
    // 拽转 住 住住转
    const startPoint = new THREE.Vector3(-18, 0, 36.16);
    const endPoint = new THREE.Vector3(-29, 0, -32.71);
    
    // 砖  砖
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    
    // 爪专转 拽专 爪  砖 ( 砖)
    const perpendicular = new THREE.Vector3();
    perpendicular.set(0, 1, 0).cross(direction).normalize();
    
    // 住 砖 (专拽 转 专 砖)
    const offsetAmount = -2.5; // 注专 砖 住 砖
    const offset = perpendicular.clone().multiplyScalar(offsetAmount);
    
    // 住驻转 住 拽转 住
    const leftLaneStart = startPoint.clone().add(offset);
    const leftLaneEnd = endPoint.clone().add(offset);
    
    // 爪专转 拽转  注 住 砖
    const midPoint1 = new THREE.Vector3(-20, 0, 20).add(offset);
    const midPoint2 = new THREE.Vector3(-25, 0, 0).add(offset);
    const midPoint3 = new THREE.Vector3(-27, 0, -15).add(offset);
    
    // 爪专转 住 爪专转 注拽转 spline 转 砖
    taxiPath = new THREE.CatmullRomCurve3([
        leftLaneStart,
        midPoint1,
        midPoint2,
        midPoint3,
        leftLaneEnd
    ]);
    
    // 住专转 住 爪专 驻
    taxiPath.closed = true;
    
    // 爪 砖 住 (驻爪)
    //visualizeTaxiPath();
};

// 爪 砖 住 转 (驻爪)
const visualizeTaxiPath = () => {
    const points = taxiPath.getPoints(50);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({ color: 0xffff00 }); // 爪 住 转
    
    const pathLine = new THREE.Line(geometry, material);
    pathLine.position.y = 0.1; // 专 拽 注 砖
    scene.add(pathLine);
    
    // 住专转 砖专  爪专 住驻 -  专拽 拽
    setTimeout(() => {
        scene.remove(pathLine);
    }, 10000); // 住专转 爪 专 10 砖转
};
// 注 拽 转 注 住
const updateTaxiPosition = (delta) => {
    if (!taxiModel || !taxiPath) return;
    
    // 注 转拽转 转 注 住 (0-1)
    taxiProgress -= TAXI_SPEED * delta; // 砖  住 住 拽 驻住
    if (taxiProgress < 0) taxiProgress += 1;
    
    // 砖 拽  注 住
    const currentPosition = taxiPath.getPointAt(taxiProgress);
    
    // 注 拽 转
    taxiModel.position.copy(currentPosition);
    taxiModel.position.y += 1; //  驻 砖拽砖转
    
    // 砖  住注 ( 住)
    const tangent = taxiPath.getTangentAt(taxiProgress).normalize();
    
    // 砖 住 砖 转 驻  住注
    const angle = Math.atan2(tangent.x, tangent.z);
    
    // 注 住 转
    taxiModel.rotation.y = angle + Math.PI; // 住驻转 PI  转 住转转  驻
};
// 爪专转 住 住注 砖 转
// 爪专转 住 住注 砖 转 - 注 转 
const createCarPath = () => {
    // 拽转 住 住住转
    const startPoint = new THREE.Vector3(-18, 0, 36.16);
    const endPoint = new THREE.Vector3(-29, 0, -32.71);
    
    // 砖  砖
    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
    
    // 爪专转 拽专 爪  砖 ( )
    const perpendicular = new THREE.Vector3();
    perpendicular.set(0, 1, 0).cross(direction).normalize();
    
    // 住  (专拽 转 专 砖)
    const offsetAmount = 2.5; // 转 驻 爪专
    const offset = perpendicular.clone().multiplyScalar(offsetAmount);
    
    // 住驻转 住 拽转 住
    const rightLaneStart = startPoint.clone().add(offset);
    const rightLaneEnd = endPoint.clone().add(offset);
    
    // 爪专转 拽转  注 住 
    const midPoint1 = new THREE.Vector3(-20, 0, 20).add(offset);
    const midPoint2 = new THREE.Vector3(-25, 0, 0).add(offset);
    const midPoint3 = new THREE.Vector3(-27, 0, -15).add(offset);
    
    // 爪专转 住 爪专转 注拽转 spline 转 
    carPath = new THREE.CatmullRomCurve3([
        rightLaneStart,
        midPoint1,
        midPoint2,
        midPoint3,
        rightLaneEnd
    ]);
    
    // 住专转 住 爪专 驻
    carPath.closed = true;
    
    // 爪 砖 住 (驻爪)
   // visualizeCarPath();
};

// 爪 砖 住 转 (驻爪)
// 爪 砖驻专转 砖 住 转
const visualizeCarPath = () => {
    // 爪 砖 住 转  ()
    const rightLanePoints = carPath.getPoints(50);
    const rightLaneGeometry = new THREE.BufferGeometry().setFromPoints(rightLanePoints);
    const rightLaneMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    
    const rightLaneLine = new THREE.Line(rightLaneGeometry, rightLaneMaterial);
    rightLaneLine.position.y = 0.1; // 专 拽 注 砖
    scene.add(rightLaneLine);
    
    // 住专转 砖专  爪专 住驻 -  专拽 拽
    setTimeout(() => {
        scene.remove(rightLaneLine);
    }, 10000); // 住专转 爪 专 10 砖转
};
// 注 拽 转 注 住
const updateCarPosition = (delta) => {
    if (!carModel || !carPath) return;
    
    // 注 转拽转 转 注 住 (0-1)
    carProgress += CAR_SPEED * delta;
    if (carProgress > 1) carProgress -= 1; // 驻 住
    
    // 砖 拽  注 住
    const currentPosition = carPath.getPointAt(carProgress);
    
    // 注 拽 转
    carModel.position.copy(currentPosition);
    
    // 砖  住注 ( 住)
    const tangent = carPath.getTangentAt(carProgress).normalize();
    
    // 砖 住 砖 转 驻  住注
    //  砖转 -Z+ 住转转 拽
    const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 0, 1),
        tangent
    );
    
    // 住 拽 砖 转
    carModel.quaternion.slerp(targetQuaternion, 0.1);
    carModel.position.y += 1;
};
// 注转 转: 专, 驻拽 住拽
const loadGameCharacters = () => {
    const loader = new THREE.GLTFLoader();
    
    // 注转 专
    loader.load(
        '3d/mario.glb',
        (gltf) => {
            marioModel = gltf.scene;
            
            // 专转 爪
            marioModel.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // 专转    专
            marioModel.scale.set(7, 7, 7);
            
            // 拽 专
            marioModel.position.set(0.43, 5.60, 6.16);
            
            // 住驻 住爪
            scene.add(marioModel);
            console.log('专 注 爪');
        },
        (xhr) => {
            console.log('注转 专: ' + (xhr.loaded / xhr.total * 100) + '% 注');
        },
        (error) => {
            console.error('砖 注转 专:', error);
        }
    );
    
    // 注转 驻拽
    loader.load(
        '3d/pacman.glb',
        (gltf) => {
            pacmanModel = gltf.scene;
            
            // 专转 爪
            pacmanModel.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            // 专转  (拽 转专 专)
            pacmanModel.scale.set(2, 2, 2);
            
            // 拽 驻拽
            pacmanModel.position.set(4.66, 1.60, -19.79);
            
            // 住驻 住爪
            scene.add(pacmanModel);
            console.log('驻拽 注 爪');
        },
        (xhr) => {
            console.log('注转 驻拽: ' + (xhr.loaded / xhr.total * 100) + '% 注');
        },
        (error) => {
            console.error('砖 注转 驻拽:', error);
        }
    );
    
    // 注转 住拽
    // 注转 住拽
    // 注转 住拽
// 注 转 loadGameCharacters() - 拽 砖 住拽:
loader.load(
    '3d/sonic.glb',
    (gltf) => {
        sonicModel = gltf.scene;
        
        // 专转 爪
        sonicModel.traverse((node) => {
            if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        
        // 专转 
        sonicModel.scale.set(2, 2, 2);
        
        // 爪专转 住 专爪 住拽
        createSonicPath();
        
        // 拽 转转 注 注  updateSonicPosition
        
        // 住驻 住爪
        scene.add(sonicModel);
        
        // 专转 注专转 爪
        sonicMixer = new THREE.AnimationMixer(sonicModel);
        
        // 拽转 爪转 转
        console.log('爪转 转 住拽:', gltf.animations);
        
        // 驻砖 爪转 runfast
        gltf.animations.forEach((clip) => {
            console.log('砖 爪:', clip.name);
            
            if (clip.name.toLowerCase().includes('run') || 
                clip.name.toLowerCase().includes('fast') || 
                clip.name.toLowerCase() === 'runfast') {
                
                sonicRunAnimation = sonicMixer.clipAction(clip);
                sonicRunAnimation.loop = THREE.LoopRepeat;
                sonicRunAnimation.play();
                console.log(`驻注转 爪转 ${clip.name}`);
            }
        });
        
        //   爪 爪 住驻爪驻转, 驻注 转 爪 专砖
        if (!sonicRunAnimation && gltf.animations.length > 0) {
            sonicRunAnimation = sonicMixer.clipAction(gltf.animations[0]);
            sonicRunAnimation.loop = THREE.LoopRepeat;
            sonicRunAnimation.play();
            console.log(`驻注转 爪 专砖: ${gltf.animations[0].name}`);
        }
        
        console.log('住拽 注 爪');
    },
    (xhr) => {
        console.log('注转 住拽: ' + (xhr.loaded / xhr.total * 100) + '% 注');
    },
    (error) => {
        console.error('砖 注转 住拽:', error);
    }
);}

// 爪 驻砖 转 - 住 注 爪专
// 爪 转
// 爪 转
const animateCharacters = (delta) => {
    // 住 专
    if (marioModel) {
        marioModel.rotation.y += 0.5 * delta;
    }
    
    // 住 驻拽
    if (pacmanModel) {
        pacmanModel.rotation.y += 0.7 * delta;
    }
    
    // 注 爪转 住拽
    if (sonicMixer) {
        sonicMixer.update(delta);
    }
};
// 爪专转 住 专爪 砖 住拽 - 爪  砖 砖
// 爪专转 住 专爪 砖 住拽
// 爪专转 住 专爪 砖 住拽 - 拽专 转专 驻拽
const createSonicPath = () => {
    // 拽 砖 驻拽: (4.66, 1.60, -19.79)
    const pacmanPosition = new THREE.Vector3(4.66, 0, -19.79);
    
    // 爪专转 住 注 住 驻拽
    const radius = 6; // 专住 住
    const center = pacmanPosition.clone();
    
    // 拽转 住 -  拽转 注 注 住 驻拽
    const points = [];
    const numPoints = 8; // 住驻专 拽转 住
    
    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * Math.PI * 2;
        const x = center.x + Math.cos(angle) * radius;
        const z = center.z + Math.sin(angle) * radius;
        points.push(new THREE.Vector3(x, 0, z));
    }
    
    // 爪专转 住 spline 住专
    sonicPath = new THREE.CatmullRomCurve3(points);
    sonicPath.closed = true;
    
    console.log("住 砖 砖 住拽 爪专 爪 - 拽专 驻拽");
};
// 注 拽 住拽 注 住
const updateSonicPosition = (delta) => {
    if (!sonicModel || !sonicPath) return;
    
    // 注 转拽转 住拽 注 住 (0-1)
    sonicProgress += SONIC_SPEED * delta;
    if (sonicProgress > 1) sonicProgress -= 1;
    
    // 砖 拽  注 住
    const currentPosition = sonicPath.getPointAt(sonicProgress);
    
    // 注 拽 住拽
    sonicModel.position.copy(currentPosition);
    sonicModel.position.y = 0; // 砖专 注  拽注
    
    // 砖  专爪 ( 住)
    const tangent = sonicPath.getTangentAt(sonicProgress).normalize();
    
    // 砖 住 砖 住拽 驻  专爪
    const angle = Math.atan2(tangent.x, tangent.z);
    
    // 注 住 住拽
    sonicModel.rotation.y = angle + Math.PI / 2; // 转转 住  专爪
    
    // 注 专转 爪 驻 专转 转注
    if (sonicRunAnimation) {
        sonicRunAnimation.timeScale = 1.0 + SONIC_SPEED * 10;
    }
};
// 转 住爪
// 驻拽爪 爪转  住专
const setupVideoModal = () => {
    const videoModal = document.getElementById('video-modal');
    const introVideo = document.getElementById('intro-video');
    const closeBtn = document.getElementById('close-video-modal');
    
    // 爪转  专 3 砖转
    setTimeout(() => {
        videoModal.style.display = 'flex';
        
        // 注爪专转 转注
        if (controls) {
            controls.moveForward = false;
            controls.moveBackward = false;
        }
        movingForward = false;
        movingBackward = false;
        
        // 砖转 砖  爪转 住专
        if (controls) {
            controls.enabled = false;
        }
        
        // 砖转 拽  住专
        if (backgroundMusic && backgroundMusic.playing()) {
            backgroundMusic.pause();
        }
        
        if (isWalking && walkSound) {
            walkSound.pause();
            isWalking = false;
        }
        
        // 驻注转 住专 转
        introVideo.play();
        
        // 住驻转  住 住专
        introVideo.addEventListener('ended', () => {
            closeVideoAndShowMission();
        });
        
        // 住驻转  驻转专 住专
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                closeVideoAndShowMission();
            });
        }
    }, 3000); // 3 砖转
};

// 驻拽爪 住专转 住专 爪转 砖
const closeVideoAndShowMission = () => {
    const videoModal = document.getElementById('video-modal');
    const introVideo = document.getElementById('intro-video');
    const missionPopup = document.getElementById('mission-popup');
    
    // 注爪专转 住专
    introVideo.pause();
    
    // 住专转 
    videoModal.style.display = 'none';
    
    // 专转 砖 砖转砖
    if (controls) {
        controls.enabled = true;
    }
    
    // 专转 拽
    if (backgroundMusic && !backgroundMusic.playing()) {
        backgroundMusic.play();
    }
    
    // 爪转 砖 专 砖
    setTimeout(() => {
        if (missionPopup) {
            missionPopup.style.opacity = '1';
            missionPopup.style.transition = 'opacity 1.5s ease-out';
        }
    }, 1000);
};
// 注转 爪 转砖转
const setupCrashSound = () => {
    crashSound = new Howl({
        src: ['audio/crash.mp3'],
        volume: 1.0, // 注爪 
        loop: false //  爪专 驻
    });
};
// 转 住爪
const init = () => {
    // 专转 转专
    setupLighting();
    
    // 爪专转 拽专拽注  注 砖  砖转转
    createPavementAndRoad();
    
    // 专转 砖 祝 专砖
    setupFirstPersonControls();
    
    // 专转 住 
    setupWalkSound();
    
    // 专转 拽专转 转注
    setupMovementControls();
    
    // 专转 爪 转砖转 - 住驻转 砖专 
    setupCrashSound();
    
    // 专转 拽转 专拽注
    setupBackgroundMusic();
    
    // 爪专转 驻拽 驻专 注 注砖 住
    createPortalEffect();
    
    // 拽 砖拽 拽转 转 砖,  注  注
    camera.position.set(-40, PLAYER_HEIGHT, 8.64);
    
    // 注转  GLB 砖 专  -  砖 转  砖 
    loadTunnelModel();
    loadCarModel();
    loadTaxiModel();
    loadGameCharacters();
    loadMafiaCharacters();
    
    // 爪转  住专
    setupVideoModal();

    // 专 注
    setTimeout(() => {
        if (document.getElementById('loading').style.display !== 'none') {
            document.getElementById('loading').style.display = 'none';
            isLoaded = true;
        }
        
        // 驻注转 拽 转爪注转 住 住专
    }, 5000);
    
    // 转转 转 爪
    animate();
};
        
        // 驻拽爪转 爪
// 注 驻拽爪转 animate
const animate = () => {
    requestAnimationFrame(animate);
    
    if (isLoaded) {
        const delta = clock.getDelta();
        animateCharacters(delta);
        if (controls && controls.enabled) {
            // 砖专转 拽 拽 驻 注
            const previousPosition = camera.position.clone();
            
            // 注 砖
            controls.update(delta);
            
            // 拽转 转砖转 注 拽专转 专
            if (checkTunnelCollisions(camera.position)) {
                //  砖 转砖转, 专 拽 拽
                camera.position.copy(previousPosition);
            }
            
            // 拽转 转砖转 注  专
            checkVehicleCollisions();
            
            // 砖专转  拽注 注 专爪驻
            camera.position.y = PLAYER_HEIGHT;
            
            // 驻住转 拽  砖 砖拽
            const positionInfo = `拽 砖拽: X: ${camera.position.x.toFixed(2)}, Y: ${camera.position.y.toFixed(2)}, Z: ${camera.position.z.toFixed(2)}`;
            console.log(positionInfo);
            
            // 爪转 拽 注 住
            if (!window.positionDisplay) {
                window.positionDisplay = document.createElement('div');
                window.positionDisplay.style.position = 'absolute';
                window.positionDisplay.style.bottom = '10px';
                window.positionDisplay.style.left = '10px';
                window.positionDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                window.positionDisplay.style.color = 'white';
                window.positionDisplay.style.padding = '5px';
                window.positionDisplay.style.fontFamily = 'monospace';
                window.positionDisplay.style.fontSize = '14px';
                window.positionDisplay.style.borderRadius = '3px';
                window.positionDisplay.style.zIndex = '1000';
                document.body.appendChild(window.positionDisplay);
            }
            window.positionDisplay.textContent = positionInfo;
            
            // 拽转  注 拽转 驻专
            checkCustomLocationPoints(camera.position);
        }
        
        // 注 拽 转
        updateCarPosition(delta);
        
        // 注 拽 转
        updateTaxiPosition(delta);
        updateSonicPosition(delta);

        // 爪 驻专 注 注砖 住
        animatePortal();
    }
    
    renderer.render(scene, camera);
};
        
        // 驻注转 转 砖祝 注
        window.addEventListener('load', init);
    </script>
</body>
</html>